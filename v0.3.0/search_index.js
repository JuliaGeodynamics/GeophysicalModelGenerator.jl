var documenterSearchIndex = {"docs":
[{"location":"man/dataimport/#Data-importing","page":"Data Import","title":"Data importing","text":"","category":"section"},{"location":"man/dataimport/","page":"Data Import","title":"Data Import","text":"We have a number of ways to import data, besides using any of the additional packages in julia to read files.","category":"page"},{"location":"man/dataimport/","page":"Data Import","title":"Data Import","text":"GeophysicalModelGenerator.Screenshot_To_GeoData\nGeophysicalModelGenerator.Screenshot_To_CartData","category":"page"},{"location":"man/dataimport/#GeophysicalModelGenerator.Screenshot_To_GeoData","page":"Data Import","title":"GeophysicalModelGenerator.Screenshot_To_GeoData","text":"Screenshot_To_GeoData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing)\n\nTake a screenshot of Georeferenced image (either a lat/lon map at a given depth or a profile) and converts it to a GeoData struct, which can be saved to Paraview\n\nThe lower left and upper right coordinates of the image need to be specified in tuples of (lon,lat,depth), where depth is negative in the Earth.\n\nThe lower right and upper left corners can be specified optionally (to take non-orthogonal images into account). If they are not specified, the image is considered orthogonal and the corners are computed from the other two.\n\n\n\n\n\n","category":"function"},{"location":"man/dataimport/#GeophysicalModelGenerator.Screenshot_To_CartData","page":"Data Import","title":"GeophysicalModelGenerator.Screenshot_To_CartData","text":"Data = Screenshot_To_CartData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing)\n\nDoes the same as Screenshot_To_GeoData, but returns a Cartesian data structure\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_loadirregular3DSeismicData/#D-tomography-model-that-is-re-interpolated-on-a-regular-grid","page":"Interpolate irregular 3D seismic tomography","title":"3D tomography model that is re-interpolated on a regular grid","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#Goal","page":"Interpolate irregular 3D seismic tomography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"This explains how to load a 3D seismic data set that is given in CSV format (comma separated ASCII), and plot it in paraview. The example is a shear-wave velocity model of the Alpine-Mediterranean region, described in:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"El-Sharkawy et al. (2020), The Slab Puzzle of the Alpine‐Mediterranean Region: Insights from a new, High‐Resolution, Shear‐Wave Velocity Model of the Upper Mantle, G^3 https://doi.org/10.1029/2020GC008993","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"As the data is not given in a regular lon/lat grid, we first interpolate it to a different mesh.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#Steps","page":"Interpolate irregular 3D seismic tomography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Download-data","page":"Interpolate irregular 3D seismic tomography","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The data is can be downloaded from https://www.seismologie.ifg.uni-kiel.de/en/research/research-data/mere2020model. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Read-data-into-Julia","page":"Interpolate irregular 3D seismic tomography","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The main data-file, El-Sharkawy-etal-G3.2020_MeRE2020_Mediterranean.csv, has 23 lines of comments (indicated with #), after which the data starts. We can use the build-in package DelimitedFiles to read in the data, and tell it that the data is seperated by |. We also want the resulting data to be stored as double precision values (Float64), and the end of every line is a linebreak (\\n).","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using DelimitedFiles\njulia> data=readdlm(\"El-Sharkawy-etal-G3.2020_MeRE2020_Mediterranean.csv\",'|',Float64,'\\n', skipstart=23,header=false)\n3695678×4 Matrix{Float64}:\n 32.12  -11.0    50.0  4.57\n 36.36  -11.0    50.0  4.47\n 38.32  -10.99   50.0  4.4\n 49.77  -10.99   50.0  4.52\n 29.82  -10.98   50.0  4.44\n 34.1   -10.98   50.0  4.56\n 40.26  -10.98   50.0  4.36\n 42.19  -10.97   50.0  4.38\n 44.1   -10.97   50.0  4.38\n  ⋮ ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Next, extract vectors from it:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> lat  = data[:,1];\njulia> lon  = data[:,2];\njulia> depth=-data[:,3];\njulia> Vs   = data[:,4];","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Note that we put a minus sign in front of depth, as that is what GeophysicalModelGenerator.jl expects.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Reformat-the-data","page":"Interpolate irregular 3D seismic tomography","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#.1-Load-and-plot-the-data-layout","page":"Interpolate irregular 3D seismic tomography","title":"3.1 Load and plot the data layout","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The data is now available as a bunch of data points. In principle we can plot that in Paraview, but it is better to reformat it into a 3D grid.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Let's first have a look at how the data is distributed at a given depth level. For that, extract all points at 50 km depth and plot it (make sure you have the Plots.l package installed)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> ind=findall(x -> x==-50.0, depth)\njulia> using Plots\njulia> scatter(lon[ind],lat[ind],marker_z=Vs[ind], ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, clims=(3.9, 4.8))","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The result looks like this:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"So this is somewhat regular but not entirely and in some areas data points are missing. It is possible to create a VTK mesh that exactly respects this data, but for that we need knowledge on how the points are connected in 3D. The comments in the file do not provide this information, which is why we interpolate it on a regular lon/lat grid here which uses the same depth levels as in the data.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We extract the available depth levels with ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> Depth_vec = unique(depth)\n301-element Vector{Float64}:\n  -50.0\n  -51.0\n  -52.0\n  -53.0\n  -54.0\n  -55.0\n  -56.0\n    ⋮\n -345.0\n -346.0\n -347.0\n -348.0\n -349.0\n -350.0","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"which shows that the data set goes from [-350:1:-50]. Let's create a regular grid, which describes a somewhat smaller area than the data-points to ensure that we can do an interpolation without having to extrapolate","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeophysicalModelGenerator \njulia> Lon,Lat,Depth     =   LonLatDepthGrid(-10:0.5:40,32:0.25:50,Depth_vec);\njulia> size(Lon)\n(101, 73, 301)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The last command shows the size of our new grid.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We can plot our new Lon/Lat grid on top of the previous data:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> scatter!(Lon[:,:,1],Lat[:,:,1],color=:white, markersize=1.5, markertype=\"+\",legend=:none)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_2)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.2-Interpolate-to-a-regular-grid","page":"Interpolate irregular 3D seismic tomography","title":"3.2 Interpolate to a regular grid","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Next, we need a method to interpolate the irregular datapoints @ a certain depth level to the white data points. ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"There are a number of ways to do this, for example by employing GMT.jl, or by using GeoStats.jl.  In this example, we will employ GeoStats. If you haven't installed it yet, do that with","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> ]\n(@v1.6) pkg> add GeoStats","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We will first show how to interpolate data @ 50 km depth.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeoStats\njulia> Cgrid = CartesianGrid((size(Lon,1),size(Lon,2)),(minimum(Lon),minimum(Lat)),(Lon[2,2,2]-Lon[1,1,1],Lat[2,2,2]-Lat[1,1,1]))\n101×73 CartesianGrid{2,Float64}\n  minimum: Point(-10.0, 32.0)\n  maximum: Point(40.5, 50.25)\n  spacing: (0.5, 0.25)\njulia> coord = PointSet([lon[ind]'; lat[ind]'])\n12278 PointSet{2,Float64}\n  └─Point(-11.0, 32.12)\n  └─Point(-11.0, 36.36)\n  └─Point(-10.99, 38.32)\n  └─Point(-10.99, 49.77)\n  └─Point(-10.98, 29.82)\n  ⋮\n  └─Point(45.97, 42.91)\n  └─Point(45.98, 37.22)\n  └─Point(45.99, 42.07)\n  └─Point(45.99, 46.76)\n  └─Point(45.99, 50.52)\njulia> Geo   = georef((Vs=Vs[ind],), coord)\n12278 MeshData{2,Float64}\n  variables (rank 0)\n    └─Vs (Float64)\n  domain: 12278 PointSet{2,Float64}\njulia> P = EstimationProblem(Geo, Cgrid, :Vs)\n2D EstimationProblem\n  data:      12278 MeshData{2,Float64}\n  domain:    101×73 CartesianGrid{2,Float64}\n  variables: Vs (Float64)\njulia> S   = IDW(:Vs => (distance=Euclidean(),neighbors=2)); \njulia> sol = solve(P, S)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Here, we interpolated the data based on the Euclidean distance. Other methods, such as Kriging, can be used as well.  Next, we can extract the data","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia>  sol_Vs = values(sol).Vs\njulia>  Vs_2D  = reshape(sol_Vs, size(domain(sol)))\njulia>  heatmap(Lon[:,1,1],Lat[1,:,1],Vs_2D', clims=(3.9, 4.8))","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_interpolated)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The final step is to repeat this procedure for all depth levels:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> Vs_3D = zeros(size(Depth));\njulia> for iz=1:size(Depth,3)\n          println(\"Depth = $(Depth[1,1,iz])\")\n          ind   = findall(x -> x==Depth[1,1,iz], depth)\n          coord = PointSet([lon[ind]'; lat[ind]'])\n          Geo   = georef((Vs=Vs[ind],), coord)\n          P     = EstimationProblem(Geo, Cgrid, :Vs)\n          S     = IDW(:Vs => (distance=Euclidean(),neighbors=2)); \n          sol   = solve(P, S)\n          sol_Vs= values(sol).Vs\n          Vs_2D = reshape(sol_Vs, size(domain(sol)))\n          Vs_3D[:,:,iz] = Vs_2D;\n        end","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Generate-Paraview-file","page":"Interpolate irregular 3D seismic tomography","title":"4. Generate Paraview file","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Once the 3D velocity matrix has been generated, producing a Paraview file is done with the following command ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(Vs_km_s=Vs_3D,))   \nGeoData \n  size  : (101, 73, 301)\n  lon   ϵ [ -10.0 - 40.0]\n  lat   ϵ [ 32.0 - 50.0]\n  depth ϵ [ -350.0 km - -50.0 km]\n  fields: (:Vs_km_s,) \njulia> Write_Paraview(Data_set, \"MeRe_ElSharkawy\")\n1-element Vector{String}:\n \"MeRe_ElSharkawy.vts\"","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Plotting-data-in-Paraview","page":"Interpolate irregular 3D seismic tomography","title":"5. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"In paraview you can open the file and visualize it:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_Paraview)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Note that we employ the perceptually uniform color map Barlow, which you can download here.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"If you want to clip the data set @ 200 km depth, you need to select the Clip tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: Tutorial_ElSharkawy_MeRe_DataPoints_Paraview_2)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Julia-script","page":"Interpolate irregular 3D seismic tomography","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> include(\"MeRe_ElSharkawy.jl\")","category":"page"},{"location":"man/tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"","category":"section"},{"location":"man/tutorials/","page":"Overview","title":"Overview","text":"The best way to learn how to use julia and GeophysicalModelGenerator to visualize your data is to look at the tutorials.","category":"page"},{"location":"man/tutorials/","page":"Overview","title":"Overview","text":"3D seismic tomography data on regular grid. Demonstrates how to load 3D data that are defined on a regular longitude/latitude/depth grid.\nMoho topography data. Shows how to plot Moho data as 3D points in paraview, and how to fit a surface through it.\nTopography. Shows how to quickly obtain the topography of any part of the world using GMT & transfer that to paraview.\nCoastlines. Shows how to generate land/sea surfaces.\nImport screenshots. Gives examples how you can easily import screenshots from published papers and visualize them in 3D \n3D seismic tomography data on irregular grid. Shows how to interpolate 3D seismic data, given on an irregular lon/lat grid, to a regular grid and create Paraview input from it.\nTopography and geological maps. Shows how to import ETOPO1 topography, how to drape a geological map over it & transfer that to Paraview.\nISC earthquake data. Shows how to import earthquake data from the ISC catalogue.\nPlot GPS data. Shows how to load and plot GPS data as vectors.","category":"page"},{"location":"man/tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"man/tools/","page":"Tools","title":"Tools","text":"We have a number of functions with which we can extract sub-data from a 2D or 3D GeoData structure.","category":"page"},{"location":"man/tools/","page":"Tools","title":"Tools","text":"GeophysicalModelGenerator.CrossSection\nGeophysicalModelGenerator.ExtractSubvolume\nGeophysicalModelGenerator.InterpolateDataFields\nGeophysicalModelGenerator.VoteMap\nGeophysicalModelGenerator.SubtractHorizontalMean\nGeophysicalModelGenerator.AboveSurface\nGeophysicalModelGenerator.BelowSurface\nGeophysicalModelGenerator.InterpolateDataOnSurface\nGeophysicalModelGenerator.ParseColumns_CSV_File\nGeophysicalModelGenerator.RotateTranslateScale!","category":"page"},{"location":"man/tools/#GeophysicalModelGenerator.CrossSection","page":"Tools","title":"GeophysicalModelGenerator.CrossSection","text":"CrossSection(Volume::GeoData; dims=(100,100), Interpolate=false, Depth_level=nothing; Lat_level=nothing; Lon_level=nothing; Start=nothing, End=nothing )\n\nCreates a cross-section through a volumetric (3D) GeoData object. \n\nCross-sections can be horizontal (map view at a given depth), if Depth_level is specified\nThey can also be vertical, either by specifying Lon_level or Lat_level (for a fixed lon/lat), or by defining both Start=(lon,lat) & End=(lon,lat) points.\nInterpolate indicates whether we want to simply extract the data from the 3D volume (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in dims\n\nExample:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2;                # some data\njulia> Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);\njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz))); \njulia> Data_cross      =   CrossSection(Data_set3D, Depth_level=-100km)  \nGeoData \n  size  : (11, 11, 1)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -100.0 km : -100.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.ExtractSubvolume","page":"Tools","title":"GeophysicalModelGenerator.ExtractSubvolume","text":"ExtractSubvolume(V::GeoData; Interpolate=false, Lon_level=nothing, Lat_level=nothing, Depth_level=nothing, dims=(50,50,50))\n\nExtract or \"cuts-out\" a piece of a 2D or 3D GeoData set, defined by Lon, Lat and Depth coordinates.\n\nThis is useful if you are only interested in a part of a much bigger larger data set.\n\nLon_level,Lat_level and Depth_level should be tuples that indicate (minimum_value, maximum_value) along the respective direction. If not specified we use the full range. \nBy default, Interpolate=false and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).\nAlternatively, if Interpolate=true we interpolate the data onto a new grid that has dimensions dims. This can be useful to compare data sets that are originally given in different resolutions.\n\n3D Example with no interpolation:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2;                # some data\njulia> Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);\njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))\nGeoData \n  size  : (11, 11, 13)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\njulia> Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))\nGeoData \n  size  : (3, 6, 13)\n  lon   ϵ [ 10.0 : 12.0]\n  lat   ϵ [ 35.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\nBy default it extracts the data points closest to the area defined by Lonlevel/Latlevel/Depth_level.\n\n3D Example with interpolation:\n\nAlternatively, you can also interpolate the data onto a new grid:\n\njulia> Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40), Interpolate=true, dims=(50,51,52))\nGeoData \n  size  : (50, 51, 52)\n  lon   ϵ [ 10.0 : 12.0]\n  lat   ϵ [ 35.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.InterpolateDataFields","page":"Tools","title":"GeophysicalModelGenerator.InterpolateDataFields","text":"InterpolateDataFields(V::GeoData, Lon, Lat, Depth)\n\nInterpolates a data field V on a grid defined by Lon,Lat,Depth\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.VoteMap","page":"Tools","title":"GeophysicalModelGenerator.VoteMap","text":"VoteMap(DataSets::Vector{GeoData}, criteria::Vector{String}, dims=(50,50,50))\n\nCreates a Vote map which shows consistent features in different 2D/3D tomographic datasets.\n\nThe way it works is:     - Find a common region between the different GeoData sets (overlapping lon/lat/depth regions)     - Interpolate the fields of all DataSets to common coordinates     - Filter data points in one model (e.g., areas with a velocity anomaly > 2 percent). Set everything that satisfies this criteria to 1 and everything else to 0.     - Sum the results of the different datasets\n\nIf a feature is consistent between different datasets, it will have larger values. \n\nExample\n\nWe assume that we have 2 seismic velocity datasets Data_Zhao_Pwave and DataKoulakov_Alps:\n\njulia> Data_Zhao_Pwave\nGeoData \n  size  : (121, 94, 101)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> DataKoulakov_Alps\n  GeoData \n    size  : (108, 81, 35)\n    lon   ϵ [ 4.0 : 20.049999999999997]\n    lat   ϵ [ 37.035928143712574 : 49.01197604790419]\n    depth ϵ [ -700.0 km : -10.0 km]\n    fields: (:dVp_percentage, :dVs_percentage)\n\nYou can create a VoteMap which combines the two data sets with:\n\njulia> Data_VoteMap = VoteMap([Data_Zhao_Pwave,DataKoulakov_Alps],[\"dVp_Percentage>2.5\",\"dVp_percentage>3.0\"])\nGeoData \n  size  : (50, 50, 50)\n  lon   ϵ [ 4.0 : 18.0]\n  lat   ϵ [ 38.0 : 49.01197604790419]\n  depth ϵ [ -700.0 km : -10.0 km]\n  fields: (:VoteMap,)\n\nYou can also create a VoteMap of a single dataset:\n\njulia> Data_VoteMap = VoteMap(Data_Zhao_Pwave,\"dVp_Percentage>2.5\", dims=(50,51,52))\nGeoData \n  size  : (50, 51, 52)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:VoteMap,)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.SubtractHorizontalMean","page":"Tools","title":"GeophysicalModelGenerator.SubtractHorizontalMean","text":"V_sub = SubtractHorizontalMean(V::AbstractArray{T, 3}; Percentage=false)\n\nSubtracts the horizontal average of the 3D data array V.\n\nIf Percentage=true, the result is given as percentage; otherwise absolute values are returned\n\n\n\n\n\nV_sub = SubtractHorizontalMean(V::AbstractArray{T, 2}; Percentage=false)\n\nSubtracts the horizontal average of the 2D data array V.\n\nIf Percentage=true, the result is given as percentage; otherwise absolute values are returned\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.AboveSurface","page":"Tools","title":"GeophysicalModelGenerator.AboveSurface","text":"AboveSurface(Data::GeoData, DataSurface::GeoData; above=true)\n\nReturns a boolean array of size(Data.Lon), which is true for points that are above the surface DataSurface (or for points below if above=false).\n\nThis can be used, for example, to mask points above/below the Moho in a volumetric dataset or in a profile.\n\n#Example First we create a 3D data set and a 2D surface:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2; \njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon))\nGeoData \n  size  : (11, 11, 13)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData)\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,-40km);  \njulia> Data_Moho       =   GeoData(Lon,Lat,Depth+Lon*km, (MohoDepth=Depth,))\n  GeoData \n    size  : (11, 11, 1)\n    lon   ϵ [ 10.0 : 20.0]\n    lat   ϵ [ 30.0 : 40.0]\n    depth ϵ [ -30.0 km : -20.0 km]\n    fields: (:MohoDepth,)\n\nNext, we intersect the surface with the data set:\n\njulia> Above       =   AboveSurface(Data_set3D, Data_Moho); \n\nNow, Above is a boolean array that is true for points above the surface and false for points below and at the surface.\n\n\n\n\n\nAbove = AboveSurface(Data_Cart::CartData, DataSurface_Cart::CartData; above=true)\n\nDetermines if points within the 3D Data_Cart structure are above the Cartesian surface DataSurface_Cart\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.BelowSurface","page":"Tools","title":"GeophysicalModelGenerator.BelowSurface","text":"Below = BelowSurface(Data::GeoData, DataSurface::GeoData)\n\nDetermines if points within the 3D Data structure are below the GeoData surface DataSurface\n\n\n\n\n\nBelow = BelowSurface(Data_Cart::CartData, DataSurface_Cart::CartData)\n\nDetermines if points within the 3D DataCart structure are below the Cartesian surface DataSurfaceCart\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.InterpolateDataOnSurface","page":"Tools","title":"GeophysicalModelGenerator.InterpolateDataOnSurface","text":"Surf_interp = InterpolateDataOnSurface(V::CartData, Surf::CartData)\n\nInterpolates a 3D data set V on a surface defined by Surf. nex\n\nExample\n\njulia> Data\nCartData \n  size  : (33, 33, 33)\n  x     ϵ [ -3.0 : 3.0]\n  y     ϵ [ -2.0 : 2.0]\n  z     ϵ [ -2.0 : 0.0]\n  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\njulia> surf\nCartData \n  size  : (96, 96, 1)\n  x     ϵ [ -2.9671875 : 3.2671875]\n  y     ϵ [ -1.9791666666666667 : 1.9791666666666667]\n  z     ϵ [ -1.5353766679763794 : -0.69925457239151]\n  fields: (:Depth,)\njulia> Surf_interp = InterpolateDataOnSurface(Data, surf)\n  CartData \n    size  : (96, 96, 1)\n    x     ϵ [ -2.9671875 : 3.2671875]\n    y     ϵ [ -1.9791666666666667 : 1.9791666666666667]\n    z     ϵ [ -1.5353766679763794 : -0.69925457239151]\n    fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\n\n\n\n\n\nSurf_interp = InterpolateDataOnSurface(V::GeoData, Surf::GeoData)\n\nInterpolates a 3D data set V on a surface defined by Surf\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.ParseColumns_CSV_File","page":"Tools","title":"GeophysicalModelGenerator.ParseColumns_CSV_File","text":"ParseColumns_CSV_File(data_file, num_columns)\n\nThis parses numbers from CSV file that is read in with CSV.File. That is useful in case the CSV files has tables that contain both strings (e.g., station names) and numbers (lat/lon/height) and you are only intested in the numbers\n\nExample\n\nThis example assumes that the data starts at line 18, that the colums are separated by spaces, and that it contains at most 4 columns with data:\n\njulia> using CSV\njulia> data_file        =   CSV.File(\"FileName.txt\",datarow=18,header=false,delim=' ')\njulia> data = ParseColumns_CSV_File(data_file, 4)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.RotateTranslateScale!","page":"Tools","title":"GeophysicalModelGenerator.RotateTranslateScale!","text":"RotateTranslateScale!(Data::CartData; Rotate=0, Translate=(0,0,0), Scale=(1.0,1.0,1.0))\n\nDoes an in-place rotation, translation and scaling of the Cartesian dataset Data. \n\nParameters\n\nNote that we apply the transformations in exactly this order:\n\nScale:        scaling applied to the x,y,z coordinates of the data set\nRotate:       rotation around the x/y axis (around the center of the box)\nTranslate:    translation\n\nExample\n\njulia> X,Y,Z   =   XYZGrid(10:20,30:40,-50:-10);\njulia> Data_C  =   CartData(X,Y,Z,(Depth=Z,))\nCartData \n  size  : (11, 11, 41)\n  x     ϵ [ 10.0 : 20.0]\n  y     ϵ [ 30.0 : 40.0]\n  z     ϵ [ -50.0 : -10.0]\n  fields: (:Depth,)\njulia> RotateTranslateScale!(Data_C, Rotate=30);\njulia> Data_C\nCartData \n  size  : (11, 11, 41)\n  x     ϵ [ 8.169872981077807 : 21.83012701892219]\n  y     ϵ [ 28.16987298107781 : 41.83012701892219]\n  z     ϵ [ -50.0 : -10.0]\n  fields: (:Depth,)\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_MohoTopo/#Moho-topography","page":"Visualize Moho topography","title":"Moho topography","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/#Goal","page":"Visualize Moho topography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"This explains how to load the Moho topography for Italy and the Alps and create a paraview file ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Spada, M., Bianchi, I., Kissling, E., Agostinetti, N.P., Wiemer, S., 2013. Combining controlled-source seismology and receiver function information to derive 3-D Moho topography for Italy. Geophysical Journal International 194, 1050–1068. doi:10.1093/gji/ggt148","category":"page"},{"location":"man/tutorial_MohoTopo/#Steps","page":"Visualize Moho topography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/#.-Download-data","page":"Visualize Moho topography","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The data is available as digital dataset on the researchgate page of Prof. Edi Kissling https://www.researchgate.net/publication/322682919MohoMap_Data-WesternAlps-SpadaETAL2013","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"We have also uploaded it here: https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The full data set actually includes 3 different Moho's (Europe, Adria, Tyrrhenia-Corsica). To simplify matters, we have split the full file into 3 seperate ascii files and uploaded it.","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Please download the files Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho1.txt, Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho2.txt and Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho3.txt","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Read-data-into-Julia","page":"Visualize Moho topography","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The data sets start at line 39. We read this into julia as:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using DelimitedFiles\njulia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho1.txt\",' ',Float64,'\\n', skipstart=38,header=false)\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Note that depth is made negative.","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Reformat-the-data","page":"Visualize Moho topography","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Next, let's check if the data is spaced in a regular manner in Lon/Lat direction.  For that, we plot it using the Plots package (you may have to install that first on your machine).","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using Plots\njulia> scatter(lon,lat,marker_z=depth, ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, c = :roma)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"What we can see nicely here is that the data is reasonably regular but also that there are obviously locations where no data is define.","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The easiest way to transfer this to Paraview is to simply save this as 3D data points:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using GeophysicalModelGenerator\njulia> data_Moho1 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\nGeoData \n  size  : (12355,)\n  lon   ϵ [ 4.00026 - 11.99991]\n  lat   ϵ [ 42.51778 - 48.99544]\n  depth ϵ [ -57.46 km - -21.34 km]\n  fields: (:MohoDepth,)\njulia>  Write_Paraview(data_Moho1, \"Spada_Moho_Europe\", PointsData=true) ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"And we can do the same with the other two Moho's:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho2.txt\",' ',Float64,'\\n', skipstart=38,header=false);\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];\njulia> data_Moho2 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\njulia> Write_Paraview(data_Moho2, \"Spada_Moho_Adria\", PointsData=true) \njulia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho3.txt\",' ',Float64,'\\n', skipstart=38,header=false);\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];\njulia> data_Moho3 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\njulia> Write_Paraview(data_Moho3, \"Spada_Moho_Tyrrhenia\", PointsData=true) ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"If we plot this in paraview, it looks like this: (Image: DataPoints_PV)","category":"page"},{"location":"man/tutorial_MohoTopo/#.1-Fitting-a-mesh-through-the-data","page":"Visualize Moho topography","title":"3.1 Fitting a mesh through the data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"So obviously, the Moho is discontinuous between these three Mohos. Often, it looks nicer if we fit a regular surface through these data points. To do this we first combine the data points of the 3 surfaces into one set of points   ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> lon   = [data_Moho1.lon.val;   data_Moho2.lon.val;   data_Moho3.lon.val];\njulia> lat   = [data_Moho1.lat.val;   data_Moho2.lat.val;   data_Moho3.lat.val];\njulia> depth = [data_Moho1.depth.val; data_Moho2.depth.val; data_Moho3.depth.val];\njulia> data_Moho_combined = GeoData(lon, lat, depth, (MohoDepth=depth*km,))","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Next, we define a regular lon/lat grid ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> Lon,Lat,Depth     =   LonLatDepthGrid(4.1:0.1:11.9,42.5:.1:49,-30km);","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"And we will use a nearest neighbor interpolation method to fit a surface through the data. This has the advantage that it will take the discontinuities into account. We will use the package NearestNeighbors.jl for this, which you may have to install first ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using NearestNeighbors\njulia> kdtree = KDTree([lon'; lat'])\njulia> idxs, dists = knn(kdtree, [Lon[:]'; Lat[:]'], 1, true)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"idxs contains the indices of the closest points to the grid in (Lon,Lat). Next ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> Depth = zeros(size(Lon))*km;\njulia> for i=1:length(idxs)\n          Depth[i] = depth[idxs[i]][1]\n       end","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Now, we can create a GeoData structure with the regular surface and save it to paraview:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> data_Moho = GeoData(Lon, Lat, Depth, (MohoDepth=Depth,))\njulia> Write_Paraview(data_Moho, \"Spada_Moho_combined\") ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The result is shown here, where the previous points are colored white and are a bit smaller. Obviously, the datasets coincide well. (Image: DataPoints_Moho_surface)","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Julia-script","page":"Visualize Moho topography","title":"4. Julia script","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> include(\"MohoTopo_Spada.jl\")","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Extract-ETOPO1-topographic-data-using-GMT.jl-and-drape-a-geological-map-on-top-of-the-topography-(given-as-raster-graphics)","page":"ETOPO1 Topography and geological maps","title":"Extract ETOPO1 topographic data using GMT.jl and drape a geological map on top of the topography (given as raster graphics)","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Goal","page":"ETOPO1 Topography and geological maps","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"In many cases, we want to add topographic data as well a information about tectonic units to our visualization. This tutorial shows how to use GMT.jl to import data from an ETOPO1 file for a certain region, load a geological map from a raster graphics file (here: PNG), drape it over the topography and transfer that.","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"note: Note\nIt may be tricky to get GMT.jl installed and working correctly on your system (at least until someone prevides a BinaryBuilder package for julia, that is). You first need to have a working version of GMT on your system and only after that, you can install GMT.jl. See the installation instructions on their webpage for details.   On a MacBook Pro, a tested procedure to install GMT and to make it work with julia is to directly install the binaries for Julia, GMT (and possibly Ghostscript) and not use any package manager (such as spack or homebrew). ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Steps","page":"ETOPO1 Topography and geological maps","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Download-topographic-data-and-tectonic-maps-of-the-Alpine-region","page":"ETOPO1 Topography and geological maps","title":"1. Download topographic data and tectonic maps of the Alpine region","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The ETOPO1 data file used in this example can be downloaded here:   https://ngdc.noaa.gov/mgg/global/global.html. For this example we downloaded ETOPO1Iceg_gmt4.grd and stored it directly in the folder where we will be working. For the geological map, we download the data from the SPP 4DMB repository and extract the zip file (also in the current folder). In this data set, a gmt file with the data for different tectonic units is given in ./ tectonicmaps4dmb20200917/GMTexample/alcapadi_polygons.gmt . ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Create-a-tectonic-map-with-orthogonal-projection","page":"ETOPO1 Topography and geological maps","title":"2. Create a tectonic map with orthogonal projection","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"To create a png with an orthogonal map projection (which we need for the png import), we do the following in julia:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> \njulia> using GMT\njulia> filename_gmt = \"./tectonic_maps_4dmb_2020_09_17/GMT_example/alcapadi_polygons.gmt\"\njulia> plot(filename_gmt,region=\"4/20/37/49\",show=true)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"This opens a window with the plotted map. Save this image in your current working folder. Open it with a image manipulation of your choice (e.g. GIMP) and crop it to the map itself. Save the cropped image in your current working directory. For this tutorial, we have named the cropped png file tectonicmap_SPP.png. It looks like this:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"(Image: Tutorial_GMT_topography_GeologicalMap_PNG)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Import-data-to-paraview","page":"ETOPO1 Topography and geological maps","title":"3. Import data to paraview","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Now, to import the ETOPO1 topography data and to drape the geologic map over it, open julia again. Load the following packages:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> using GMT, NearestNeighbors, GeoParams, GeophysicalModelGenerator","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"First, define the filenames of the files you want to import:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> filename_topo = \"./ETOPO1/ETOPO1_Ice_g_gmt4.grd\" \njulia> filename_geo  = \"./tectonicmap_SPP.png\"","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Next, define the region that you want to visualize (note that we use the same coordinates here as we used previously for the generation of the geological map):  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> lat_min = 37.0\njulia> lat_max = 49.0\njulia> lon_min = 4.0\njulia> lon_max = 20.0","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"and import the data","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> G = gmtread(filename_topo, limits=[lon_min,lon_max,lat_min,lat_max]);\nLon,Lat,Depth    =   LonLatDepthGrid(G.x[1:end],G.y[1:end],0);\nnumel_topo       =   prod(size(Lon));\nDepth[:,:,1]     =   1e-3*G.z';\nDataTopo         =   GeophysicalModelGenerator.GeoData(Lon, Lat, Depth, (Topography=Depth*km,))","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"At this step, only the topographic data is imported. Now we have to import the tectonic map from the png file. To do so, first define the longitude and latitude of the lower left and upper right corner of the png (as we create:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> Corner_LowerLeft    =   ( lon_min, lat_min , 0.0)\njulia> Corner_UpperRight   =   (lon_max, lat_max , 0.0)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"and import the png file with the GMG function ScreenshotToGeoData:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> DataPNG = Screenshot_To_GeoData(filename_geo, Corner_LowerLeft, Corner_UpperRight)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The tricky part is then to interpolate the colors from the geological map to the topography. Here, we simply use nearesat neighbor interpolation (NearestNeighbors.jl) to do so. First, we have to set up the KDTree and determine the nearest neighbors of the points in our Lat/Lon grid","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> coord = [vec(DataPNG.lon.val)';vec(DataPNG.lat.val)'];\njulia> kdtree = KDTree(coord; leafsize = 10);\njulia> points = [vec(Lon)';vec(Lat)'];\njulia> dx,dist = nn(kdtree, points);","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Once this is done, the respective colors have to be assigned to a field in the DataTopo structure:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> red   = zeros(size(Depth));\njulia> green = zeros(size(Depth));\njulia> blue  = zeros(size(Depth));\njulia> tmp                = DataPNG.fields.colors[1];\njulia> red[1:numel_topo] = tmp[idx];\njulia> tmp                = DataPNG.fields.colors[2];\njulia> green[1:numel_topo] = tmp[idx];\njulia> tmp                = DataPNG.fields.colors[3];\njulia> blue[1:numel_topo] = tmp[idx];","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Finally, to avoid artefacts, all colors outside the region described by the tectonic map are set to white:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> ind_tmp = Lat .<  Corner_LowerLeft[2];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lat .> Corner_UpperRight[2];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lon .<  Corner_LowerLeft[1];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lon .> Corner_UpperRight[1];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Save","page":"ETOPO1 Topography and geological maps","title":"4. Save","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Transforming the to Paraview is now a piece of cake:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> Data_set        =   GeoData(Lon, Lat, Depth, (Topography=Depth*km,colors=(red,green,blue)))\njulia> Write_Paraview(Data_set, \"test_GeoMap\")","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The result is shown here:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"(Image: Tutorial_GMT_topography_GeologicalMap)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"In case you are interested: we are employing the oleron scientific colormap from Fabio Crameri's scientific colormap package here.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#D-tomography-model-in-CSV-formation","page":"3D seismic tomography from ASCII","title":"3D tomography model in CSV formation","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/#Goal","page":"3D seismic tomography from ASCII","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This explains how to load a 3D P-wave model and plot it in Paraview as a 3D volumetric data set. It also shows how you can create horizontal or vertical cross-sections through the data in a straightforward manner and how you can extract subsets of the data; The example is the P-wave velocity model of the Alps as described in: ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Zhao, L., Paul, A., Malusà, M.G., Xu, X., Zheng, T., Solarino, S., Guillot, S., Schwartz, S., Dumont, T., Salimbeni, S., Aubert, C., Pondrelli, S., Wang, Q., Zhu, R., 2016. Continuity of the Alpine slab unraveled by high-resolution P wave tomography. Journal of Geophysical Research: Solid Earth 121, 8720–8737. doi:10.1002/2016JB013310","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The data is given in ASCII format with longitude/latitude/depth/velocity anomaly (percentage) format.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#Steps","page":"3D seismic tomography from ASCII","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/#.-Download-data","page":"3D seismic tomography from ASCII","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The data is can be downloaded from https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/, where you should download the file Zhao_etal_JGR_2016_Pwave_Alps_3D_k60.txt. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Read-data-into-Julia","page":"3D seismic tomography from ASCII","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The dataset has no comments, and the data values in every row are separated by a space. In order to read this into julia as a matrix, we can use the build-in julia package DelimitedFiles.    We want the resulting data to be stored as double precision values (Float64), and the end of every line is a linebreak (\\n).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using DelimitedFiles\njulia> data=readdlm(\"Zhao_etal_JGR_2016_Pwave_Alps_3D_k60.txt\",' ',Float64,'\\n', skipstart=0,header=false)\n1148774×4 Matrix{Float64}:\n  0.0   38.0   -1001.0  -0.113\n  0.15  38.0   -1001.0  -0.081\n  0.3   38.0   -1001.0  -0.069\n  0.45  38.0   -1001.0  -0.059\n  0.6   38.0   -1001.0  -0.055\n  0.75  38.0   -1001.0  -0.057\n  ⋮                     \n 17.25  51.95     -1.0  -0.01\n 17.4   51.95     -1.0  -0.005\n 17.55  51.95     -1.0   0.003\n 17.7   51.95     -1.0   0.007\n 17.85  51.95     -1.0   0.006\n 18.0   51.95     -1.0   0.003","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next, extract vectors from it:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> lon        = data[:,1];\njulia> lat        = data[:,2];\njulia> depth      = data[:,3];\njulia> dVp_perc   = data[:,4];","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Note that depth needs to with negative numbers.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Reformat-the-data","page":"3D seismic tomography from ASCII","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Let's first have a look at the depth range of the data set:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Depth_vec = unique(depth)\n101-element Vector{Float64}:\n -1001.0\n  -991.0\n  -981.0\n  -971.0\n  -961.0\n  -951.0\n     ⋮\n   -51.0\n   -41.0\n   -31.0\n   -21.0\n   -11.0\n    -1.0","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"So the data has a vertical spacing of 10 km. Next, let's check if the data is spaced in a regular manner in Lon/Lat direction.  For that, we read the data at a given depth level (say -101km) and plot it using the Plots package (you may have to install that first on your machine).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using Plots\njulia> ind=findall(x -> x==-101.0, depth)\njulia> scatter(lon[ind],lat[ind],marker_z=dVp_perc[ind], ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, c = :roma)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Note that we employ the scientific colormap roma here. This gives an overview of available colormaps. You can download the colormaps for Paraview here.  ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Clearly, the data is given as regular Lat/Lon points:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> unique(lon[ind])\n121-element Vector{Float64}:\n  0.0\n  0.15\n  0.3\n  0.45\n  0.6\n  0.75\n  ⋮\n 17.25\n 17.4\n 17.55\n 17.7\n 17.85\n 18.0\njulia> unique(lat[ind])\n94-element Vector{Float64}:\n 38.0\n 38.15\n 38.3\n 38.45\n 38.6\n 38.75\n  ⋮\n 51.2\n 51.35\n 51.5\n 51.65\n 51.8\n 51.95","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.1-Reshape-data-and-save-to-paraview","page":"3D seismic tomography from ASCII","title":"3.1 Reshape data and save to paraview","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next, we reshape the vectors with lon/lat/depth data into 3D matrixes:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> resolution =  (length(unique(lon)), length(unique(lat)), length(unique(depth)))\n(121, 94, 101)\njulia> Lon          = reshape(lon,      resolution);\njulia> Lat          = reshape(lat,      resolution);\njulia> Depth        = reshape(depth,    resolution);\njulia> dVp_perc_3D  = reshape(dVp_perc, resolution);","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Check that the results are consistent","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> iz=findall(x -> x==-101.0, Depth[1,1,:])\n1-element Vector{Int64}:\n 91\njulia> data=dVp_perc_3D[:,:,iz];\njulia> heatmap(unique(lon), unique(lat),data[:,:,1]', c=:roma,title=\"$(Depth[1,1,iz]) km\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"So this looks good.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next we create a paraview file:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(dVp_Percentage=dVp_perc_3D,))\nGeoData \n  size  : (121, 94, 101)\n  lon   ϵ [ 0.0 - 18.0]\n  lat   ϵ [ 38.0 - 51.95]\n  depth ϵ [ -1001.0 km - -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_set, \"Zhao_etal_2016_dVp_percentage\")\n1-element Vector{String}:\n \"Zhao_etal_2016_dVp_percentage.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Plotting-data-in-Paraview","page":"3D seismic tomography from ASCII","title":"4. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In paraview you should open the *.vts file, and press Apply (left menu) after doing that. Once you did that you can select dVp_Percentage and Surface (see red ellipses below)/. In paraview you can open the file and visualize it. ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_1)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This visualisation employs the default colormap, which is not particularly good.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"You can change that by importing the roma colormap (using the link described earlier). For this, open the colormap editor and click the one with the heart on the right hand side. Next, import roma and select it.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_2)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In order to change the colorrange select the button in the red ellipse and change the lower/upper bound. (Image: Paraview_3)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you want to create a horizontal cross-section @ 200 km depth, you need to select the Slice tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_4)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"After pushing Apply, you'll see this:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_5)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you want to plot iso-surfaces (e.g. at -3%), you can use the Clip option again, but this time select scalar and don't forget to unclick invert.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_6)","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Extract-and-plot-cross-sections-of-the-data","page":"3D seismic tomography from ASCII","title":"5. Extract and plot cross-sections of the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In many cases you would like to create cross-sections through the 3D data sets as well, and visualize that in Paraview. That is in principle possible in Paraview as well (using the Slice tool, as described above). Yet, in many cases we want to have it at a specific depth, or through pre-defined lon/lat coordinates.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"There is a simple way to achieve this using the CrossSection function. To make a cross-section at a given depth:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Depth_level=-100km)  \nGeoData \n  size  : (121, 94, 1)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -101.0 km : -101.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_100km\")\n1-element Vector{String}:\n \"Zhao_CrossSection_100km.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Or at a specific longitude:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Lon_level=10)\nGeoData \n  size  : (1, 94, 101)\n  lon   ϵ [ 10.05 : 10.05]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,) \njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_Lon10\")\n1-element Vector{String}:\n \"Zhao_CrossSection_Lon10.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"As you see, this cross-section is not taken at exactly 10 degrees longitude. That is because by default we don't interpolate the data, but rather use the closest point in longitude in the original data set.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you wish to interpolate the data, specify Interpolate=true:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Lon_level=10, Interpolate=true)\nGeoData \n  size  : (1, 100, 100)\n  lon   ϵ [ 10.0 : 10.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_Lon10_interpolated\");","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"as you see, this causes the data to be interpolated on a (100,100) grid (which can be changed by adding a dims input parameter).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"We can also create a diagonal cut through the model:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Start=(1.0,39), End=(18,50))\nGeoData \n  size  : (100, 100, 1)\n  lon   ϵ [ 1.0 : 18.0]\n  lat   ϵ [ 39.0 : 50.0]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_diagonal\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Here an image that shows the resulting cross-sections: ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_7)","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Extract-a-(3D)-subset-of-the-data","page":"3D seismic tomography from ASCII","title":"6. Extract a (3D) subset of the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Sometimes, the data set covers a large region (e.g., the whole Earth), and you are only interested in a subset of this data for your project. You can obviously cut your data to the correct size in Paraview. Yet, an even easier way is the routine ExtractSubvolume:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_subset     =   ExtractSubvolume(Data_set,Lon_level=(5,12), Lat_level=(40,45))\nGeoData \n  size  : (48, 35, 101)\n  lon   ϵ [ 4.95 : 12.0]\n  lat   ϵ [ 39.95 : 45.05]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_subset, \"Zhao_Subset\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This gives the resulting image. You can obviously use that new, smaller, data set to create cross-sections etc. (Image: Paraview_8)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"By default, we extract the original data and do not interpolate it on a new grid. In some cases, you will want to interpolate the data on a different grid. Use the Interpolate=true option for that:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_subset_interp     =   ExtractSubvolume(Data_set,Lon_level=(5,12), Lat_level=(40,45), Interpolate=true)\nGeoData \n  size  : (50, 50, 50)\n  lon   ϵ [ 5.0 : 12.0]\n  lat   ϵ [ 40.0 : 45.0]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_subset, \"Zhao_Subset_interp\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Load-and-save-data-to-disk","page":"3D seismic tomography from ASCII","title":"7. Load and save data to disk","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"It would be useful to save the 3D data set we just created to disk, such that we can easily load it again at a later stage and create cross-sections etc, or compare it with other models.  It is quite easy to do so with the JLD2.jl package:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using JLD2\njulia> jldsave(\"Zhao_Pwave.jld2\"; Data_set)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you, at a later stage, want to load this file again do it as follows:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using JLD2, GeophysicalModelGenerator\njulia> Data_set_Zhao2016_Vp = load_object(\"Zhao_Pwave.jld2\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Julia-script","page":"3D seismic tomography from ASCII","title":"8. Julia script","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> include(\"Alps_VpModel_Zhao_etal_JGR2016.jl\")","category":"page"},{"location":"man/datastructures/#Data-structures","page":"Data Structures","title":"Data structures","text":"","category":"section"},{"location":"man/datastructures/","page":"Data Structures","title":"Data Structures","text":"The main data structure used in GeophysicalModelGenerator.jl is GeoData, which contains info about the latitude, longitude and depth of a data set, as well as several data sets itself.","category":"page"},{"location":"man/datastructures/","page":"Data Structures","title":"Data Structures","text":"GeophysicalModelGenerator.GeoData\nGeophysicalModelGenerator.CartData\nGeophysicalModelGenerator.LonLatDepthGrid\nGeophysicalModelGenerator.XYZGrid","category":"page"},{"location":"man/datastructures/#GeophysicalModelGenerator.GeoData","page":"Data Structures","title":"GeophysicalModelGenerator.GeoData","text":"GeoData(lon::Any, lat:Any, depth::GeoUnit, fields::NamedTuple)\n\nData structure that holds one or several fields with longitude, latitude and depth information.\n\ndepth can have units of meter, kilometer or be unitless; it will be converted to km.\nfields should ideally be a NamedTuple which allows you to specify the names of each of the fields. \nIn case you only pass one array we will convert it to a NamedTuple with default name.\nA single field should be added as (DataFieldName=Data,) (don't forget the comma at the end).\nMultiple fields  can be added as well. lon,lat,depth should all have the same size as each of the fields.\nIn case you want to display a vector field in paraview, add it as a tuple: (Velocity=(Veast,Vnorth,Vup), Veast=Veast, Vnorth=Vnorth, Vup=Vup); we automatically apply a vector transformation when transforming this to a CartData structure from which we generate Paraview output. As this changes the magnitude of the arrows, you will no longer see the [Veast,Vnorth,Vup] components in Paraview which is why it is a good ideas to store them as separate Fields.\nYet, there is one exception: if the name of the 3-component field is colors, we do not apply this vector transformation as this field is regarded to contain RGB colors. \n\nExample\n\njulia> Lat         =   1.0:10.0;\njulia> Lon         =   11.0:20.0;\njulia> Depth       =   (-20:-11)*km;\njulia> Data        =   zeros(size(Lon));\njulia> Data_set    =   GeophysicalModelGenerator.GeoData(Lon,Lat,Depth,(DataFieldName=Data,))   \nGeoData \n  size  : (10,)\n  lon   ϵ [ 1.0 : 10.0]\n  lat   ϵ [ 11.0 : 20.0]\n  depth ϵ [ -20 km : -11 km]\n  fields: (:DataFieldName,)\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.CartData","page":"Data Structures","title":"GeophysicalModelGenerator.CartData","text":"CartData(x::GeoUnit, y::GeoUnit, z::GeoUnit, values::NamedTuple)\n\nCartesian data in x/y/z coordinates to be used with Paraview This is usually generated automatically from the GeoData structure, but you can also invoke do this manually:\n\njulia> Data_set    =   GeophysicalModelGenerator.GeoData(1.0:10.0,11.0:20.0,(-20:-11)*km,(DataFieldName=(-20:-11),))   \njulia> Data_cart = convert(CartData, Data_set)\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.LonLatDepthGrid","page":"Data Structures","title":"GeophysicalModelGenerator.LonLatDepthGrid","text":"Lon, Lat, Depth = LonLatDepthGrid(Lon::Any, Lat::Any, Depth:Any)\n\nCreates 3D arrays of Lon, Lat, Depth from 1D vectors or numbers\n\nExample 1: Create 3D grid\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,(-10:-1)km);\njulia> size(Lon)\n(11, 11, 10)\n\nExample 2: Create 2D lon/lat grid @ a given depth\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,-50km);\njulia> size(Lon)\n(11, 11)\n\nExample 3: Create 2D lon/depth grid @ a given lat\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30,(-10:-1)km);\njulia> size(Lon)\n(11, 11)\n\nExample 4: Create 1D vertical line @ a given lon/lat point\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10,30,(-10:-1)km);\njulia> size(Lon)\n(10, )\n\n\n\n\n\n","category":"function"},{"location":"man/datastructures/#GeophysicalModelGenerator.XYZGrid","page":"Data Structures","title":"GeophysicalModelGenerator.XYZGrid","text":"X,Y,Z = XYZGrid(X_vec::Any, Y_vec::Any, Z_vec::Any)\n\nCreates a X,Y,Z grid. It works just as LonLatDepthGrid apart from the better suited name.\n\nExample 1: Create 3D grid\n\njulia> X,Y,Z =  XYZGrid(10:20,30:40,(-10:-1)km);\njulia> size(X)\n(11, 11, 10)\n\nSee LonLatDepthGrid for more examples.\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_Screenshot_To_Paraview/#Import-profiles/maps-from-published-papers","page":"Import screenshots","title":"Import profiles/maps from published papers","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/#Goal","page":"Import screenshots","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Ideally, all data should be availabe in digital format, after which you could use the tools described in the other tutorial to transform them into GeoData and export them to VTK. Yet, the reality is different and often data is not (yet) available, or papers are old and the authors can no longer be contacted.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For that reason, GeophysicalModelGenerator has tools that allow you to transfer a screenshot from any published paper into GeoData/Paraview and see it in 3D at the correct geographic location. This can be done for vertical profiles and for mapviews, which gives you a quick and easy way to see those papers in a new (3D) light.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Here, we explain how. ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Import profiles/maps from published papers\nGoal\nGeneral procedure\n1. Download data and crop images\n2. Read data of a cross-section & create VTS file\n3. Read data of a mapview & create *.vts file\n4. Using an automatic digitizer to pick points on map\n5. Creating a multiblock Paraview/*.vtm file\n6. Julia script","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#General-procedure","page":"Import screenshots","title":"General procedure","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Download-data-and-crop-images","page":"Import screenshots","title":"1. Download data and crop images","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For this example, we use a well-known paper about the Alps which is now openly available:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Lippitsch, R., 2003. Upper mantle structure beneath the Alpine orogen from high-resolution teleseismic tomography. J. Geophys. Res. 108, 2376. https://doi.org/10.1029/2002JB002016","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Figure 12 contains a number of horizontal slices @ different depth, whereas Figure 13 contains 3 vertical profiles and a mapview that illustrates where the profile was taken. The first profile is shown here:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_1)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"The first step is to crop the image such that we only see the profile itself:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_2)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Read-data-of-a-cross-section-and-create-VTS-file","page":"Import screenshots","title":"2. Read data of a cross-section & create VTS file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"We look at the bigger image and determine the lon,lat,depth coordinates of the lower left and upper right corners of this image. We estimate this to be at:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> Corner_LowerLeft  = ( 3.5, 46.0, -400.0)\njulia> Corner_UpperRight = (16.0, 42.5, 0.0)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once this is done, and we saved the picture under Lippitsch_Fig13a.png, you can transfer it into GeoData format with:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> using GeophysicalModelGenerator\njulia> data_profile1 = Screenshot_To_GeoData(\"Lippitsch_Fig13a.png\",Corner_LowerLeft, Corner_UpperRight)\nExtracting GeoData from: Lippitsch_Fig13a.png\n           └ Corners:         lon       lat       depth\n              └ lower left  = [3.5    ; 46.0   ;  -400.0 ]\n              └ lower right = [16.0   ; 42.5   ;  -400.0 ]\n              └ upper left  = [3.5    ; 46.0   ;  0.0    ]\n              └ upper right = [16.0   ; 42.5   ;  0.0    ]\nGeoData \n  size  : (325, 824, 1)\n  lon   ϵ [ 3.4999999999999996 : 16.0]\n  lat   ϵ [ 42.49999999999999 : 46.00000000000001]\n  depth ϵ [ -400.00000000000006 km : 0.0 km]\n  fields: (:colors,)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Finally, you save it in Paraview format as always:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> Write_Paraview(data_profile1, \"Lippitsch_Fig13a_profile\") ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"You can open this in paraview. Here, it is shown along with topographic data (made transparent):","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_1) Note that if you want to see the image with the original colors, you should unselect the Map Scalars option in the Properties tab (red ellipse).","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Read-data-of-a-mapview-and-create-*.vts-file","page":"Import screenshots","title":"3. Read data of a mapview & create *.vts file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Creating a map follows the same procedure. The only difference is that maps are sometimes distorted which means that the axis are not necessarily orthogonal in lon/lat space. In that case, you need to specify all 4 corners. Internally, we linearly interpolate between those values.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"An example is given here, which uses the mapview of Fig. 13 of the same paper (@ 150 km depth): (Image: Fig13_mapview)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Corner_LowerLeft    =   ( 3.5, 43.0 , -150.0)\nCorner_UpperRight   =   (15.5, 50.0 , -150.0)\nCorner_LowerRight   =   (15.5, 43.0 , -150.0)\nCorner_UpperLeft    =   (3.5 , 50.0 , -150.0)\ndata_Fig13_map      =   Screenshot_To_GeoData(\"Fig13_mapview.png\",Corner_LowerLeft, Corner_UpperRight, Corner_LowerRight=Corner_LowerRight,Corner_UpperLeft=Corner_UpperLeft)\nWrite_Paraview(data_Fig13_map, \"Lippitsch_Fig13_mapview\") ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once added to paraview (together with a few additional map views from the same paper):   (Image: Tutorial_ScreenShots_Lippitsch_4)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Using-an-automatic-digitizer-to-pick-points-on-map","page":"Import screenshots","title":"4. Using an automatic digitizer to pick points on map","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Often, it is not straightforward to determine the begin/end points of a profile and have to guess that by looking at the mapview (which is inprecise). To help with that, you can digitize the map and use an automatic digitizer to pick points on the map.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"A great online tool to do exactly that can be found here: https://automeris.io/WebPlotDigitizer/","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For this, you need to create a screenshot that is slightly larger and includes the axis (or a scale bar). As an example, you can use the image Digitizer_1.png which you can download here https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/main/docs/src/assets/img/Digitizer_1.png.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"If import this in the online tool and indicate this to be a 2D (X-Y) Plot, it will ask us to pick 2 points on the X axis and 2 points on the Y axis: (Image: Digitizer_2)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once the map is referenced accordingly, we can pick points (here for C' - C) and show the corresponding data values: (Image: Digitizer_3)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Which can again be used to set your profile.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Creating-a-multiblock-Paraview/*.vtm-file","page":"Import screenshots","title":"5. Creating a multiblock Paraview/*.vtm file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"If you are importing a lot of cross-sections at the same time in Paraview, you end up having a lot of open profiles. For that reason it is possible to save a \"multi-block\" *.vtm file, which combines several files into one. The general approach is simple: open a multiblock file, and pass the filename to Write_Paraview. Once you are done, save it. An example showing you how this works is:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> vtmfile = vtk_multiblock(\"Lippitsch_CrossSections\")\njulia> Write_Paraview(data_Fig12_90km, vtmfile) \njulia> Write_Paraview(data_Fig12_180km, vtmfile) \njulia> Write_Paraview(data_Fig12_300km, vtmfile) \njulia> Write_Paraview(data_Fig12_400km, vtmfile) \njulia> vtk_save(vtmfile)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Note that you have to create the cross-sections first (see the julia script below).","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Julia-script","page":"Import screenshots","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For convenience we collected a few screenshots and uploaded it from https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"The full julia script that interprets all the figures is given here.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> include(\"Lippitsch_Screenshots.jl\")","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/tutorial_GPS/#Plot-GPS-data","page":"Plot GPS vectors","title":"Plot GPS data","text":"","category":"section"},{"location":"man/tutorial_GPS/#Goal","page":"Plot GPS vectors","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The aim of this tutorial is to show you how you can download and plot GPS data, which are vector data.  The example is based on a paper by Sanchez et al. (2018) https://essd.copernicus.org/articles/10/1503/2018/#section7","category":"page"},{"location":"man/tutorial_GPS/#Steps","page":"Plot GPS vectors","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GPS/#.-Download-and-import-GPS-data:","page":"Plot GPS vectors","title":"1. Download and import GPS data:","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The data related to the paper can be downloaded from: https://doi.pangaea.de/10.1594/PANGAEA.886889 There you will find links to several data sets. Some are the data on the actual stations and some are interpolated data on a grid. Here, we will use the gridded data as an example (which interpolates the ), and will therefore download the following data sets:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"ALPS2017DEFHZ\tSurface deformation model of the Alpine Region\thttps://store.pangaea.de/Publications/Sanchez-etal2018/ALPS2017DEF_HZ.GRD\nALPS2017DEFVT\tVertical deformation model of the Alpine Region\thttps://store.pangaea.de/Publications/Sanchez-etal2018/ALPS2017DEF_VT.GRD","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we have a look at the data themselves. We will use the package CSV.jl to load the comma-separated data. Let's have a look at the file ALPS2017_DEF_VT.GRD. If we open it with a text editor, we see that the data starts at line 18, and has the following format:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Column 1: Longitude [degrees]\nColumn 2: Latitude [degrees]\nColumn 3: Velocity in the height direction [m/a]\nColumn 4: Uncertainty of the height component [m/a]\n\n\n 4.00    43.00    0.000067   0.000287\n 4.30    43.00   -0.001000   0.000616\n 4.60    43.00   -0.001067   0.000544","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So we have 4 columns with data values, and the data is separated by spaces. We can load that in julia as:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using CSV, GeophysicalModelGenerator\njulia> data_file =   CSV.File(\"ALPS2017_DEF_VT.GRD\",datarow=18,header=false,delim=' ');","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"We can read the numerical data from the file with:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> data                    =   ParseColumns_CSV_File(data_file, 4);     \njulia> lon_Vz, lat_Vz, Vz_vec  =   data[:,1], data[:,2], data[:,3];","category":"page"},{"location":"man/tutorial_GPS/#.-Check-and-reshape-vertical-velocity","page":"Plot GPS vectors","title":"2. Check & reshape vertical velocity","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Let's have a look at the data, by plotting it:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using Plots\njulia> Plots.scatter(lon_Vz,lat_Vz)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"(Image: Tutorial_GPS_1)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So clearly, this is a fully regular grid. We can determine the size of the grid with ","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> unique(lon_Vz)\n41-element Vector{Float64}:\n  4.0\n  4.3\n  4.6\n  4.9\n  5.2\n  5.5\n  5.8\n  ⋮\n 14.5\n 14.8\n 15.1\n 15.4\n 15.7\n 16.0\njulia> unique(lat_Vz)\n31-element Vector{Float64}:\n 43.0\n 43.2\n 43.4\n 43.6\n 43.8\n 44.0\n 44.2\n  ⋮\n 48.0\n 48.2\n 48.4\n 48.6\n 48.8\n 49.0","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So we have a 41 by 31 grid. GMG requires 3D matrixes for the data (as we want to plot the results in paraview in 3D). That is why we first initialize 3D matrixes for lon,lat,Vz:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> lon, lat, Vz            =   zeros(41,31,1),zeros(41,31,1),zeros(41,31,1)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"And we can reshape the vectors accordingly:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> lon[:,:,1]              =   reshape(lon_Vz,(41,31))\njulia> lat[:,:,1]              =   reshape(lat_Vz,(41,31))\njulia> Vz[:,:,1]               =   reshape(Vz_vec,(41,31))","category":"page"},{"location":"man/tutorial_GPS/#.-Load-horizontal-velocities","page":"Plot GPS vectors","title":"3. Load horizontal velocities","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we load the horizontal velocities from the file ALPS2017_DEF_HZ.GRD","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> data_file                       =   CSV.File(\"ALPS2017_DEF_HZ.GRD\",datarow=18,header=false,delim=' ');\njulia> data                            =   ParseColumns_CSV_File(data_file, 6);\njulia> lon_Hz, lat_Hz, Ve_Hz, Vn_Hz    =   data[:,1], data[:,2], data[:,3],  data[:,4];","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Let's plot the data as well:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Plots.scatter(lon_Hz,lat_Hz)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"(Image: Tutorial_GPS_2)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So it appears that the horizontal velocities are given on the same regular grid as well, but not in the water.  This thus requires a bit more work. The strategy we take is to first define 2D matrixes with horizontal velocities with the same size as Vz which are initialized with NaN (not a number), which is treated specially by Paraview.","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Ve = ones(size(Vz))*NaN;\njulia> Vn = ones(size(Vz))*NaN;","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next we loop over all points in lon_Hz,lat_Hz and place them into the 2D matrixes:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia>  for i in eachindex(lon_Hz)\n            ind = intersect(findall(x->x==lon_Hz[i], lon), findall(x->x==lat_Hz[i], lat))\n            Ve[ind] .= Ve_Hz[i];\n            Vn[ind] .= Vn_Hz[i];\n        end","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage, we have horizontal and vertical velocities in units of m/yr. Yet, given the small velocities in the Alps, it makes more sense to have them in units of mm/yr:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Vz = Vz*1000;\njulia> Ve = Ve*1000;\njulia> Vn = Vn*1000;","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"And the magnitude is:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Vmagnitude  =   sqrt.(Ve.^2 + Vn.^2 + Vz.^2);  ","category":"page"},{"location":"man/tutorial_GPS/#.-Interpolate-topography-on-grid","page":"Plot GPS vectors","title":"4. Interpolate topography on grid","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage we have the 3D velocity components on a grid. Yet, we don't have information yet about the elevation of the stations (as the provided data set did not give this).  We could ignore that and set the elevation to zero, which would allow saving the data directly to paraview.","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Yet, a better way is to load the topographic map of the area and interpolate the elevation to the velocity grid. We are using the GMT.jl to load the topographic data:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using GMT\njulia> Elevation =   gmtread(\"@earth_relief_01m.grd\", limits=[3,17,42,50]);","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we use the Interpolations.jl package to interpolate the topography:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using Interpolations\njulia> interpol = LinearInterpolation((Elevation.x[1:end-1], Elevation.y[1:end-1]), Elevation.z');    \njulia> height   = interpol.(lon,lat)/1e3;","category":"page"},{"location":"man/tutorial_GPS/#.-Saving-and-plotting-in-Paraview","page":"Plot GPS vectors","title":"5. Saving and plotting in Paraview","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage, we have all we need. As the velocity is a vector field, we need to save it as a data structure with 3 components. When saving to paraview, GMG internally does a vector transformation. As this transformation does not retain the east/north components of the velocity field, it is a good idea to save them as separate fields so we can color the vectors accordingly in Paraview. Also note that we do not attach units to the vector fields, but we do have them for the scalar fields:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> GPS_Sanchez_grid = GeoData(lon,lat,height,(Velocity_mm_year=(Ve,Vn,Vz),V_north=Vn*mm/yr, V_east=Ve*mm/yr, V_vertical=Vz*mm/yr, Vmagnitude = Vmagnitude*mm/yr, Topography = height*km))\nGeoData \n  size  : (41, 31, 1)\n  lon   ϵ [ 4.0 : 16.0]\n  lat   ϵ [ 43.0 : 49.0]\n  depth ϵ [ -2.6545 km : 3.426 km]\n  fields: (:Velocity_mm_year, :V_north, :V_east, :V_vertical, :Vmagnitude, :Topography)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Saving this to paraview is as always:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Write_Paraview(GPS_Sanchez_grid, \"GPSAlps_Sanchez_2017_grid\")","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Opening and plotting the vertical field gives: (Image: Tutorial_GPS_3)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"In order to plot the velocities as arrows, you need to select the Glyph tool (red circle). Also specify Velocity_mm_year () as both Orientation and Scale Array, and add 50 as scale factor. Once you push Apply it should look like: (Image: Tutorial_GPS_4)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The arrows can now be colored by the individual velocity components or its magnitude.","category":"page"},{"location":"man/gravity_code/#Gravity-code","page":"Gravity code","title":"Gravity code","text":"","category":"section"},{"location":"man/gravity_code/","page":"Gravity code","title":"Gravity code","text":"The voxGrav function allows for the voxel-based computation of Bouguer anomalies and gradients from a 3D density matrix.","category":"page"},{"location":"man/gravity_code/","page":"Gravity code","title":"Gravity code","text":"GeophysicalModelGenerator.voxGrav","category":"page"},{"location":"man/gravity_code/#GeophysicalModelGenerator.voxGrav","page":"Gravity code","title":"GeophysicalModelGenerator.voxGrav","text":"voxGrav(X::Array{Float64, 3}, Y::Array{Float64, 3}, Z::Array{Float64, 3}, RHO::Array{Float64, 3};\nrefMod=\"AVG\", lengthUnit=\"m\", rhoTol=1e-9, Topo=[], outName=\"Bouguer\", printing=true)\n\nComputes Bouguer anomalies and gradients  \n\nRequired arguments:  \nX,Y,Z:       3D matrices with the coordinates of the grid (X should vary in the first dimension, Y in the second, Z (vertical) in the thrid)  \nRHO:         3D matrix with the densitiy at each grid point [kg/m^3]  \n\nOptional arguments:  \nrefMod:      1D vector with the reference density for each depth  \n             Alternatively, the strings \"NE\", \"SE\", \"SW\", \"NW\", \"AVG\" can be used.  \n             In that case, one of the corners of `RHO` is used as reference model.  \n             In case of \"AVG\" the reference model is the average of each depth slice.  \nlengthUnit:  The unit of the coordinates and topography file. Either \"m\" or \"km\"  \nrhoTol:      density differences smaller than rhoTol will be ignored [kg/m^3]  \nTopo:        2D matrix with the topography of the surface (only relevant for the paraview output)  \noutName:     name of the paraview output (do not include file type)  \nprinting:    activate printing of additional information [true or false]\n\n\n\n\n\n","category":"function"},{"location":"man/installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"GeophysicalModelGenerator.jl is written in the julia programming language, which is an extremely powerful, modern, scientific computing language. Julia works on all major operating systems, is free, fast, and has a very active user basis (with many useful packages). In case you haven't heard about julia yet, you are not alone. Yet, perhaps a look at this or this article, which explains nicely why it has an enormous potential for computational geosciences as well.","category":"page"},{"location":"man/installation/#.-Install-julia","page":"Installation","title":"1. Install julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use then package you obviously need to install julia. We recommend downloading and installing binaries from the julia webpage.","category":"page"},{"location":"man/installation/#.-Install-Visual-Studio-Code","page":"Installation","title":"2. Install Visual Studio Code","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The julia files itself are text files (just like matlab scripts). You may want to edit or modify them at some stage, for which you can use any text editor for that. We prefer to use the freely available Visual Studio Code as it has a build-in terminal and is the comes with the (official) julia debugger (install the Julia extension for that).","category":"page"},{"location":"man/installation/#.-Getting-started-with-julia","page":"Installation","title":"3. Getting started with julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You start julia on the command line with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"kausb$ julia","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This will start the command-line interface of julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"From the julia prompt, you start the package manager by typing ]:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"(@v1.6) pkg> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"And you return to the command line with a backspace.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Also useful is that julia has a build-in terminal, which you can reach by typing ; on the command line:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia>;\nshell> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In the shell, you can use the normal commands like listing the content of a directory, or the current path:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"shell> ls\nLICENSE         Manifest.toml   Project.toml    README.md       docs            src             test            tutorial\nshell> pwd\n/Users/kausb/.julia/dev/GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"As before, return to the main command line (called REPL) with a backspace.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you want to see help information for any julia function, type ? followed by the command.  An example for tan is:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"help?> tan\nsearch: tan tanh tand atan atanh atand instances transpose transcode contains UnitRange ReentrantLock StepRange StepRangeLen trailing_ones trailing_zeros\n\n  tan(x)\n\n  Compute tangent of x, where x is in radians.\n\n  ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  tan(A::AbstractMatrix)\n\n  Compute the matrix tangent of a square matrix A.\n\n  If A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise, the tangent is determined by calling exp.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> tan(fill(1.0, (2,2)))\n  2×2 Matrix{Float64}:\n   -1.09252  -1.09252\n   -1.09252  -1.09252","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you are in a directory that has a julia file (which have the extension *.jl), you can open that file with Visual Studio Code:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"shell> code runtests.jl","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Execute the file with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> include(\"runtests\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Note that you do not include the *.jl extension.","category":"page"},{"location":"man/installation/#.-Install-GeophysicalModelGenerator.jl","page":"Installation","title":"4. Install GeophysicalModelGenerator.jl","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to install GeophysicalModelGenerator.jl, start julia and go to the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> add https://github.com/JuliaGeodynamics/GeoParams.jl\n(@v1.6) pkg> add https://github.com/JuliaGeodynamics/GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You first need to install a package called GeoParams.jl, after which you install GeophysicalModelGenerator.jl. It will automatically install various other packages it relies on (using the correct version).","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you want, you can test if it works on your machine by running the test suite in the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> test GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Note that we run these tests automatically on Windows, Linux and Mac every time we add a new feature to GeophysicalModelGenerator (using different julia versions). This Continuous Integration (CI) ensures that new features do not break others in the package. The results can be seen here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The installation of GMG only needs to be done once, and will precompile the package and all other dependencies.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you, at a later stage, want to upgrade to the latest version of GMG, you can type:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> update GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can load GeophysicalModelGenerator, for example to create cross-sections, with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> using GeophysicalModelGenerator","category":"page"},{"location":"man/installation/#.-Other-useful-packages","page":"Installation","title":"5. Other useful packages","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"As you will work your way through the tutorials you will see that we often use external packages, for example to load ascii data files into julia. You will find detailed instructions in the respective tutorials. ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you already want to install some of those, here our favorites. Install them through the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"CSV: Read comma-separated data files into julia.  \nPlots: Create all kinds of plots in julia (quite an extensive package, but very useful to have). \nJLD2: This allows saving julia objects (such as a tomographic model) to a binary file and load it again at a later stage.\nGeodesy: Convert UTM coordinates to latitude/longitude/altitude.\nNetCDF: Read NetCDF files.\nGMT: A julia interface to the Generic Mapping Tools (GMT), which is a highly popular package to create (geophysical) maps. Note that installing GMT.jl is more complicated than installing the other packages listed above, as you first need to have a working version of GMT on your machine (it is not yet installed automatically). Installation instructions for Windows/Linux are on their webpage. On a mac, we made the best experiences by downloading the binaries from their webpage and not using a package manager to install GMT.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#D-tomography-model-that-is-given-as-a-netCDF-file","page":"3D seismic tomography from netCDF","title":"3D tomography model that is given as a netCDF file","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#Goal","page":"3D seismic tomography from netCDF","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"This explains how to load a 3D seismic data set that is given in netCDF format, and plot it in paraview. The example is a shear-wave velocity model of the Alpine-Mediterranean region, described in:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"El-Sharkawy et al. (2020), The Slab Puzzle of the Alpine‐Mediterranean Region: Insights from a new, High‐Resolution, Shear‐Wave Velocity Model of the Upper Mantle, G^3 https://doi.org/10.1029/2020GC008993","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#Steps","page":"3D seismic tomography from netCDF","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Download-data","page":"3D seismic tomography from netCDF","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The data is can be downloaded from https://ds.iris.edu/files/products/emc/emc-files/El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Read-data-into-Julia","page":"3D seismic tomography from netCDF","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The main data-file, El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc, is given as netCDF file. To read in data of this type, it is necessary to load an appropriate package. Here, we will use the https://github.com/JuliaGeo/NetCDF.jl package. Download and install the package with:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using Pkg\njulia> Pkg.add(\"NetCDF\")","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"First, let us have a look at the contents of this file (assuming that you are in the same directory where the file is located):","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using NetCDF\njulia> ncinfo(\"El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc\")\n##### NetCDF File #####\n\n/Users/mthiel/PROJECTS/CURRENT/SPP2017/GeophysicalModelGenerator/InputData/El-Sharkawy/El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc\n\n##### Dimensions #####\n\nName                                                                            Length                                  \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                                                           301                                     \nlatitude                                                                        100                                     \nlongitude                                                                       100                                     \n\n##### Variables #####\n\nName                                            Type                    Dimensions                                      \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                           FLOAT                   depth                                           \nlatitude                                        FLOAT                   latitude                                        \nlongitude                                       FLOAT                   longitude                                       \nVs                                              FLOAT                   longitude latitude depth                        \n\n##### Attributes #####\n\nVariable                      Name                          Value                                                       \n--------------------------------------------------------------------------------------------------------------------------\nglobal                        author_email                  amr.elsharkawy@ifg.uni-kiel.de                              \nglobal                        data_revision                 r.0.0                                                       \nglobal                        author_institution            Institute of Geosciences, University of Kiel, Otto-Hahn Pl..\nglobal                        keywords                      seismic tomography, shear wave, Mediterranean, phase veloc..\nglobal                        acknowledgment                Model was provided by Dr. El-Sharkawy, Institute of Geosci..\nglobal                        history                       2020-09-29 14:37:43 UTC Converted to netCDF by GeoCSV_2_ne..\nglobal                        repository_pid                doi:10.17611/dp/emc.2020.meresvelsh.1                       \nglobal                        id                            MeRE2020                                                    \nglobal                        author_name                   Amr EL-Sharkawy                                             \nglobal                        comment                       model converted to netCDF by IRIS EMC                       \nglobal                        NCO                           netCDF Operators version 4.7.5 (Homepage = http://nco.sf.n..\nglobal                        summary                       MeRE2020 is a high-resolution Shearâwave velocity mod..\nglobal                        repository_institution        IRIS DMC                                                    \nglobal                        netCDF_file                   El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-1.0.nc      \nglobal                        author_url                    https://www.seismologie.ifg.uni-kiel.de                     \nglobal                        reference                     El-Sharkawy, et al. (2020)                                  \nglobal                        repository_name               EMC                                                         \nglobal                        Conventions                   CF-1.0                                                      \nglobal                        Metadata_Conventions          Unidata Dataset Discovery v1.0                              \nglobal                        title                         The Slab Puzzle of the AlpineâMediterranean Region: I..\ndepth                         units                         km                                                          \ndepth                         long_name                     depth in km                                                 \ndepth                         display_name                  depth in km                                                 \ndepth                         positive                      down                                                        \nlatitude                      units                         degrees_north                                               \nlatitude                      long_name                     Latitude; positive north                                    \nlatitude                      standard_name                 latitude                                                    \nlongitude                     units                         degrees_east                                                \nlongitude                     long_name                     Longitude; positive east                                    \nlongitude                     standard_name                 longitude                                                   \nVs                            units                         km.s-1                                                      \nVs                            long_name                     Shear wave velocity                                         \nVs                            display_name                  S Velocity (km/s) ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"As you can see, there is quite some information present in this file. The most important information here are the different variables stored in this file:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"##### Variables #####\n\nName                                            Type                    Dimensions                                      \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                           FLOAT                   depth                                           \nlatitude                                        FLOAT                   latitude                                        \nlongitude                                       FLOAT                   longitude                                       \nVs                                              FLOAT                   longitude latitude depth                        ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Here we can see that there are four variables in this file, three of them (depth,latitude, longitude) having a single dimension and the fourth one (Vs) having dimensions of the three previous variables. The three one-dimensional vectors therefore denote a regualr grid of coordinates defining the locations where Vs is stored.   To load this data, we can now simply use the commmand ncread:  ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> lat = ncread(filename,\"latitude\")\njulia> lon = ncread(filename,\"longitude\")\njulia> depth = ncread(filename,\"depth\")\njulia> Vs_3D = ncread(filename,\"Vs\")\njulia> depth = -1 .* depth ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Note that we multiplied depth with -1. This is necessary to make depth to be negative, as that is what GeophysicalModelGenerator.jl expects.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Reformat-the-coordinate-data","page":"3D seismic tomography from netCDF","title":"3. Reformat the coordinate data","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"In the netCDF file, coordinates are given as 1D vectors denoting the location of nodes in a regular grid. However, GeophysicalModelGenerator.jl expects true 3D data, where each data point is assigned a latitude,longitude, depth and the respective property (here: Vs). To generate this full regular 3D grid, do the following:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Lon3D,Lat3D,Depth3D = LonLatDepthGrid(lon, lat, depth);","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Generate-Paraview-file","page":"3D seismic tomography from netCDF","title":"4. Generate Paraview file","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Once the 3D coordinate matrix has been generated, producing a Paraview file is done with the following command ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(Vs_km_s=Vs_3D,))   \nGeoData \n  size  : (100, 100, 301)\n  lon   ϵ [ 29.0 - 51.0]\n  lat   ϵ [ -11.0 - 45.9900016784668]\n  depth ϵ [ -350.0 km - -50.0 km]\n  fields: (:Vs_km_s,) \njulia> Write_Paraview(Data_set, \"MeRe_ElSharkawy\")\n1-element Vector{String}:\n \"MeRe_ElSharkawy.vts\"","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Plotting-data-in-Paraview","page":"3D seismic tomography from netCDF","title":"5. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"In paraview you can open the file and visualize it:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"(Image: DataPoints_Paraview)","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Note that we employ the perceptually uniform color map Barlow, which you can download here.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"If you want to clip the data set @ 200 km depth, you need to select the Clip tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"(Image: Tutorial_ElSharkawy_MeRe_DataPoints_Paraview_2)","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Julia-script","page":"3D seismic tomography from netCDF","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> include(\"MeRe_ElSharkawy.jl\")","category":"page"},{"location":"man/paraview_output/#Paraview-output","page":"Paraview output","title":"Paraview output","text":"","category":"section"},{"location":"man/paraview_output/","page":"Paraview output","title":"Paraview output","text":"We have one main routine to generate Paraview output for data that is either stored in a GeoData structure (that has lat/lon info), or CartData (Cartesian). If GeoData is supplied it is internally automatically converted to the right format. Vectors, such as velocity, are also converted accordingly.","category":"page"},{"location":"man/paraview_output/","page":"Paraview output","title":"Paraview output","text":"GeophysicalModelGenerator.Write_Paraview","category":"page"},{"location":"man/paraview_output/#GeophysicalModelGenerator.Write_Paraview","page":"Paraview output","title":"GeophysicalModelGenerator.Write_Paraview","text":"Write_Paraview(DataSet::CartData, filename=\"test\"; PointsData=false)\n\nWrites a structure with Geodata to a paraview (or VTK) file\n\nExample 1: Write a 3D volume\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data_set        =   GeoData(Lat,Lon,Depth,(Depthdata=Depth,LonData=Lon))  \njulia> Write_Paraview(Data_set, \"test_depth3D\")\n\nExample 2: Horizontal slice @ given depth\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  \njulia> Write_Paraview(Data_set, \"test\")\n\nExample 3: Case with topography\n\njulia> Lon,Lat,Depth    =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Depth[2:4,2:4,1] .=  25km     \njulia> Data_set         =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  \njulia> Write_Paraview(Data_set, \"test2\")\n\nExample 4: Profile\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,35,(-300:25:0)km);\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth,Depth=Depth))  \njulia> Write_Paraview(Data_set, \"test\")\n\nExample 5: Velocity vectors\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Ve, Vn, Vz     =   ones(size(Depth)), ones(size(Depth))*0.5, zeros(size(Depth));\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth, Velocity=(Ve,Vn,Vz)))\nGeoData \n  size  : (11, 11, 1)\n  lon   ϵ [ 30.0 - 40.0]\n  lat   ϵ [ 10.0 - 20.0]\n  depth ϵ [ 10.0 km - 10.0 km]\n  fields: (:DataSet, :Velocity)  \njulia> Write_Paraview(Data_set, \"test_Velocity\")\n\nExample 6: Unconnected points (e.g., earthquake locations)\n\nNote that these points should be 1D vectors.\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:5:20,35:2:40,(-300:50:0)km);\njulia> Lon=Lon[:]; Lat=Lat[:]; Depth=Depth[:];\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth[:],Depth=Depth*10));  \njulia> Write_Paraview(Data_set, \"test_Points\", PointsData=true)\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#LaMEM-I/O","page":"LaMEM I/O","title":"LaMEM I/O","text":"","category":"section"},{"location":"man/lamem/","page":"LaMEM I/O","title":"LaMEM I/O","text":"In order to generate geodynamic simulations from setups created with GeophysicalModelGenerator.jl, we provide a few routines that directly create marker input files for the 3D geodynamic modelling software LaMEM, which is an open-source cartesian code that is well-suited to perform crustal and lithospheric-scale simulations.  If you want to learn how to run LaMEM simulations, please have a look at the wiki page. ","category":"page"},{"location":"man/lamem/","page":"LaMEM I/O","title":"LaMEM I/O","text":"GeophysicalModelGenerator.ReadLaMEM_InputFile\nGeophysicalModelGenerator.Save_LaMEMMarkersParallel\nGeophysicalModelGenerator.GetProcessorPartitioning\nGeophysicalModelGenerator.LaMEM_grid\nGeophysicalModelGenerator.ReadData_PVTR","category":"page"},{"location":"man/lamem/#GeophysicalModelGenerator.ReadLaMEM_InputFile","page":"LaMEM I/O","title":"GeophysicalModelGenerator.ReadLaMEM_InputFile","text":"Grid::LaMEM_grid = ReadLaMEM_InputFile(file)\n\nParses a LaMEM input file and stores grid information in the Grid structure.\n\nExample\n\njulia> Grid = ReadLaMEM_InputFile(\"SaltModels.dat\") \nLaMEM Grid: \nnel         : (32, 32, 32)\nmarker/cell : (3, 3, 3)\nmarkers     : (96, 96, 96)\nx           ϵ [-3.0 : 3.0]\ny           ϵ [-2.0 : 2.0]\nz           ϵ [-2.0 : 0.0]\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.Save_LaMEMMarkersParallel","page":"LaMEM I/O","title":"GeophysicalModelGenerator.Save_LaMEMMarkersParallel","text":"Save_LaMEMMarkersParallel(Grid::CartData; PartitioningFile=empty, directory=\"./markers\", verbose=true)\n\nSaves a LaMEM marker file from the CartData structure Grid. It must have a field called Phases, holding phase information (as integers) and optionally a field Temp with temperature info.  It is possible to provide a LaMEM partitioning file PartitioningFile. If not, output is assumed to be for one processor.\n\nThe size of Grid should be consistent with what is provided in the LaMEM input file. In practice, the size of the mesh can be retrieved from a LaMEM input file using ReadLaMEM_InputFile.\n\nExample\n\njulia> Grid    = ReadLaMEM_InputFile(\"LaMEM_input_file.dat\")\njulia> Phases  = zeros(Int32,size(Grid.X));\njulia> Temp    = ones(Float64,size(Grid.X));\njulia> Model3D = CartData(Grid, (Phases=Phases,Temp=Temp))\njulia> Save_LaMEMMarkersParallel(Model3D)\nWriting LaMEM marker file -> ./markers/mdb.00000000.dat\n\nIf you want to create a LaMEM input file for multiple processors:\n\njulia> Save_LaMEMMarkersParallel(Model3D, PartitioningFile=\"ProcessorPartitioning_4cpu_1.2.2.bin\")\nWriting LaMEM marker file -> ./markers/mdb.00000000.dat\nWriting LaMEM marker file -> ./markers/mdb.00000001.dat\nWriting LaMEM marker file -> ./markers/mdb.00000002.dat\nWriting LaMEM marker file -> ./markers/mdb.00000003.dat\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.GetProcessorPartitioning","page":"LaMEM I/O","title":"GeophysicalModelGenerator.GetProcessorPartitioning","text":"nProcX,nProcY,nProcZ, xc,yc,zc, nNodeX,nNodeY,nNodeZ = GetProcessorPartitioning(filename)\n\nReads a LaMEM processor partitioning file, used to create marker files, and returns the parallel layout \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.LaMEM_grid","page":"LaMEM I/O","title":"GeophysicalModelGenerator.LaMEM_grid","text":"Structure that holds information about the LaMEM grid (usually read from an input file).\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.ReadData_PVTR","page":"LaMEM I/O","title":"GeophysicalModelGenerator.ReadData_PVTR","text":"Data::CartData = ReadData_PVTR(fname, dir)\n\nReads a parallel, rectilinear, *.vts file with the name fname and located in dir and create a 3D Data struct from it.\n\nExample\n\njulia> Data = ReadData_PVTR(\"Haaksbergen.pvtr\", \"./Timestep_00000005_3.35780500e-01/\")\nCartData \n  size  : (33, 33, 33)\n  x     ϵ [ -3.0 : 3.0]\n  y     ϵ [ -2.0 : 2.0]\n  z     ϵ [ -2.0 : 0.0]\n  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_GMT_Topography/#Extract-topographic-data-from-GMT.jl","page":"Create GMT-based topography","title":"Extract topographic data from GMT.jl","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/#Goal","page":"Create GMT-based topography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"In many cases, we want to add topographic data as well to our visualization. This tutorial shows how to use GMT.jl to download data from a certain region, and transfer that.","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"note: Note\nIt may be tricky to get GMT.jl installed and working correctly on your system (at least until someone prevides a BinaryBuilder package for julia, that is). You first need to have a working version of GMT on your system and only after that, you can install GMT.jl. See the installation instructions on their webpage for details.   On a MacBook Pro, a tested procedure to install GMT and to make it work with julia is to directly install the binaries for Julia, GMT (and possibly Ghostscript) and not use any package manager (such as spack or homebrew). ","category":"page"},{"location":"man/tutorial_GMT_Topography/#Steps","page":"Create GMT-based topography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/#.-Download-topographic-data-of-the-Alpine-region","page":"Create GMT-based topography","title":"1. Download topographic data of the Alpine region","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The nice thing about GMT is that it automatically downloads data for you, from a certain region:","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"julia> using GMT\njulia> G = gmtread(\"@earth_relief_01m.grd\", limits=[4,20,37,49]);","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The data is available in different resolutions; see here for an overview. Generally, it is advisable to not use the largest ","category":"page"},{"location":"man/tutorial_GMT_Topography/#.-Save","page":"Create GMT-based topography","title":"2. Save","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"Transforming this to Paraview is piece of cake:","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"julia> Lon,Lat,Depth    =   LonLatDepthGrid(G.x[1:end-1],G.y[1:end-1],0);\njulia> Depth[:,:,1]     =   1e-3*G.z';\njulia> data_Topo        =   GeoData(Lon, Lat, Depth, (Topography=Depth*km,))\njulia> Write_Paraview(data_Topo, \"Topography_Alps\") ","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The result is shown here, together with Moho data","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"(Image: Tutorial_GMT_topography)","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"In case you are interested: we are employing the oleron scientific colormap here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeophysicalModelGenerator","category":"page"},{"location":"#GeophysicalModelGenerator","page":"Home","title":"GeophysicalModelGenerator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeophysicalModelGenerator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main purpose of this package is to simplify the process of going from 1D/2D/3D geophysical data to a 3D consistent model of the region. By simplifying the process of plotting the data, it becomes easier to compare different data sets, and generate a 3D models that can be used for other computations such as geodynamic simulations, or forward modelling of gravity anomalies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this, GeophysicalModelGenerator provides the following functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A consistent GeoData structure, that holds the data along with lon/lat/depth information. \nRoutines to generate VTK files from the GeoData structure in order to visualize results in Paraview.\nThe ability to deal with points, 2D profiles and 3D volumes, for both scalar and vector values.\nRapidly import screenshots of published papers compare them with other data sets in 3D using paraview. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started is to look at the tutorials.","category":"page"},{"location":"man/tutorial_ISC_data/#Plot-ISC-earthquake-data","page":"ISC earthquake data","title":"Plot ISC earthquake data","text":"","category":"section"},{"location":"man/tutorial_ISC_data/#Goal","page":"ISC earthquake data","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"This explains how to load earthquake data obtained from the ISC catalogue.","category":"page"},{"location":"man/tutorial_ISC_data/#Steps","page":"ISC earthquake data","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_ISC_data/#.-Download-data","page":"ISC earthquake data","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"You can get data from the ISC catalogue here:   http://www.isc.ac.uk/iscbulletin/search/catalogue/ The catalogue will give you an on screen CSV output that will then have to be copied to a file of your choice (here we will call it ISC1.dat). Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_ISC_data/#.-Read-data-into-Julia","page":"ISC earthquake data","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"The main data-file, ISC1.dat, has 23 lines of comments (indicated with #), after which the data starts. We can use the julia package https://github.com/JuliaData/CSV.jl to read in the data, and tell it that the data is seperated by ,.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> using CSV, GeophysicalModelGenerator\njulia> data_file        =   CSV.File(\"ISC1.dat\",datarow=24,header=false,delim=',')","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"As this data contains a lot of information that we are not interested in at the moment and which is given in non-numeric fomats (e.g. date, time etc.), we will use our helper function ParseColumnsCSVFile to only extract columns with numeric data.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> data        =   ParseColumns_CSV_File(data_file, 14)\njulia> lon         = data[:,2];\njulia> lat         = data[:,1];\njulia> depth       = -1* data[:,3];\njulia> magnitude   = data[:,4];","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"Converting this data to a GeoStruct data and to export is to Paraview is then straightforward.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> EQ_Data = GeoData(lon,lat,depth,(Magnitude=magnitude,Depth=depth));\njulia> Write_Paraview(EQ_Data, \"EQ_ISC\", PointsData=true)","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"The result the looks like this (plotted here together with the topography):","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"(Image: Tutorial_ISC)","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"In case you are interested: we are employing the oleron scientific colormap from Fabio Crameri's scientific colormap package here.","category":"page"},{"location":"man/tutorial_Coastlines/#Add-coastlines","page":"Coastlines","title":"Add coastlines","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#Goal","page":"Coastlines","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"For orientation, it is often nice to add country borders and coastlines to your paraview plots. ","category":"page"},{"location":"man/tutorial_Coastlines/#Steps","page":"Coastlines","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#.-Coast-lines","page":"Coastlines","title":"1. Coast lines","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#.1-Download-land/sea-data","page":"Coastlines","title":"1.1 Download land/sea data","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The package GeoDatasets.jl has a simple interface to get a grid that explains whether the Earth surface is land, sea or a lake.","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"julia> using GeoDatasets\njulia> lon,lat,data = GeoDatasets.landseamask(;resolution='l',grid=1.25);\njulia> ind_lon = findall( (lon .> 0) .& (lon .< 30 ) );\njulia> ind_lat = findall( (lat .> 35) .& (lat .< 50 ) );","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The parameter resolution should be either c,l,i,h or f (standing for crude, low, intermediate, high and full resolution)","category":"page"},{"location":"man/tutorial_Coastlines/#.2-Save-in-Paraview","page":"Coastlines","title":"1.2 Save in Paraview","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"julia> Lon,Lat,Depth    =   LonLatDepthGrid(lon[ind_lon],lat[ind_lat],0km);\njulia> data_surf        =   zeros(size(Lon));\njulia> data_surf[:,:,1] =   data[ind_lon,ind_lat]\njulia> data_surface     =   GeoData(Lon, Lat, Depth, (SurfaceType=data_surf,))\njulia> Write_Paraview(data_surface, \"ContinentOcean\") ","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The result is shown here, together with Moho data","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"(Image: Tutorial_Coastlines)","category":"page"}]
}
