<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of functions · GeophysicalModelGenerator.jl</title><meta name="title" content="List of functions · GeophysicalModelGenerator.jl"/><meta property="og:title" content="List of functions · GeophysicalModelGenerator.jl"/><meta property="twitter:title" content="List of functions · GeophysicalModelGenerator.jl"/><meta name="description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="og:description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="twitter:description" content="Documentation for GeophysicalModelGenerator.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="GeophysicalModelGenerator.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeophysicalModelGenerator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../Tutorial_Basic/">1 - Getting started</a></li><li><a class="tocitem" href="../tutorial_load3DSeismicData/">2 - 3D seismic tomography from ASCII</a></li><li><a class="tocitem" href="../tutorial_loadregular3DSeismicData_netCDF/">3 - 3D seismic tomography from netCDF</a></li><li><a class="tocitem" href="../Tutorial_MohoTopo_Spada/">4 - Visualize Moho topography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography/">5 - Create GMT-based topography</a></li><li><a class="tocitem" href="../tutorial_Coastlines/">6 - Coastlines</a></li><li><a class="tocitem" href="../tutorial_Screenshot_To_Paraview/">7 - Import screenshots</a></li><li><a class="tocitem" href="../tutorial_loadirregular3DSeismicData/">8 - Interpolate irregular 3D seismic tomography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography_GeologicalMap/">9 - ETOPO1 Topography and geological maps</a></li><li><a class="tocitem" href="../tutorial_ISC_data/">10 - ISC earthquake data</a></li><li><a class="tocitem" href="../tutorial_GPS/">11 - Plot GPS vectors</a></li><li><a class="tocitem" href="../tutorial_UTM/">12 - Read UTM data</a></li><li><a class="tocitem" href="../Tutorial_Votemaps/">13 - VoteMaps</a></li><li><a class="tocitem" href="../tutorial_local_Flegrei/">14 - Campi Flegrei</a></li><li><a class="tocitem" href="../Tutorial_LaPalma/">15 - La Palma volcano Model</a></li><li><a class="tocitem" href="../tutorial_time_Seismicity/">16 - Create movies</a></li><li><a class="tocitem" href="../Tutorial_FaultDensity/">17 - Fault Density Map</a></li><li><a class="tocitem" href="../Tutorial_AlpineData/">18 - Alpine data integration</a></li><li><a class="tocitem" href="../Tutorial_Jura/">19 - Jura tutorial</a></li><li><a class="tocitem" href="../Tutorial_NumericalModel_2D/">20 - 2D model setups</a></li><li><a class="tocitem" href="../Tutorial_NumericalModel_3D/">21 - 3D model setups</a></li><li><a class="tocitem" href="../Tutorial_VolcanoModel_3D/">22 - 3D model setups</a></li><li><a class="tocitem" href="../tutorial_Polygon_structures/">23 - Build geometry from polygons</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../dataimport/">Data Import</a></li><li><a class="tocitem" href="../projection/">Projection</a></li><li><a class="tocitem" href="../asagi_io/">ASAGI</a></li><li><a class="tocitem" href="../paraview_output/">Paraview output</a></li><li><a class="tocitem" href="../paraview_collection/">Paraview collection</a></li><li><a class="tocitem" href="../surfaces/">Surfaces</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../visualise/">Visualisation</a></li><li><a class="tocitem" href="../gravity_code/">Gravity code</a></li><li><a class="tocitem" href="../geodynamic_setups/">Numerical model setups</a></li><li><a class="tocitem" href="../lamem/">LaMEM</a></li><li><a class="tocitem" href="../ptatin/">pTatin</a></li><li><a class="tocitem" href="../Tutorial_Chmy_MPI/">Chmy</a></li><li><a class="tocitem" href="../profile_processing/">Profile Processing</a></li><li><a class="tocitem" href="../gmsh/">Gmsh</a></li><li><a class="tocitem" href="../movies/">Movies</a></li></ul></li><li class="is-active"><a class="tocitem" href>List of functions</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>List of functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/main/docs/src/man/listfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-all-functions"><a class="docs-heading-anchor" href="#List-of-all-functions">List of all functions</a><a id="List-of-all-functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-all-functions" title="Permalink"></a></h1><p>Here an overview of all functions:</p><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.CartData-Tuple{CartGrid, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.CartData-Tuple{CartGrid, NamedTuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data = CartData(Grid::CartGrid, fields::NamedTuple; y_val=0.0)</code></pre><p>Returns a CartData set given a cartesian grid <code>Grid</code> and <code>fields</code> defined on that grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1281-L1285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.CartData-Tuple{LaMEM_grid, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.CartData-Tuple{LaMEM_grid, NamedTuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CartData(Grid::LaMEM_grid, fields::NamedTuple)</code></pre><p>Creates a <code>CartData</code> struct from a LaMEM grid and from fields stored on that grid. Note that one needs to have a field <code>Phases</code> and optionally a field <code>Temp</code> to create LaMEM marker files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.CartData-Tuple{Tuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.CartData-Tuple{Tuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CartData(xyz::Tuple{Array,Array,Array})</code></pre><p>This creates a <code>CartData</code> struct if you have a Tuple with 3D coordinates as input.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; data = CartData(xyz_grid(-10:10,-5:5,0))
CartData
    size    : (21, 11, 1)
    x       ϵ [ -10.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ 0.0 km : 0.0 km]
    fields  : (:Z,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L805-L820">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.CartGrid"><a class="docstring-binding" href="#GeophysicalModelGenerator.CartGrid"><code>GeophysicalModelGenerator.CartGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure that holds data for an orthogonal cartesian grid, which can be described with 1D vectors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1093-L1095">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.GMG_Dataset"><a class="docstring-binding" href="#GeophysicalModelGenerator.GMG_Dataset"><code>GeophysicalModelGenerator.GMG_Dataset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure that stores info about a GMG Dataset, which is useful to collect a wide variety of datasets.</p><ul><li>Name    :: String          # Name of the dataset</li><li>Type    :: String          # Volumetric, Surface, Point, Screenshot</li><li>DirName :: String          # Directory name or url of dataset</li><li>active  :: Bool            # should this data be loaded or not?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L79-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.GeoData-Tuple{Tuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.GeoData-Tuple{Tuple}"><code>GeophysicalModelGenerator.GeoData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GeoData(lld::Tuple{Array,Array,Array})</code></pre><p>This creates a <code>GeoData</code> struct if you have a Tuple with 3D coordinates as input.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; data = GeoData(lonlatdepth_grid(-10:10,-5:5,0))
GeoData 
  size      : (21, 11, 1)
  lon       ϵ [ -10.0 : 10.0]
  lat       ϵ [ -5.0 : 5.0]
  depth     ϵ [ 0.0 : 0.0]
  fields    : (:Z,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L252-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ParaviewData-Tuple{LaMEM_grid, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.ParaviewData-Tuple{LaMEM_grid, NamedTuple}"><code>GeophysicalModelGenerator.ParaviewData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ParaviewData(Grid::LaMEM_grid, fields::NamedTuple)</code></pre><p>Creates a <code>ParaviewData</code> struct from a LaMEM grid and from fields stored on that grid. Note that one needs to have a field <code>Phases</code> and optionally a field <code>Temp</code> to create LaMEM marker files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ProfileData"><a class="docstring-binding" href="#GeophysicalModelGenerator.ProfileData"><code>GeophysicalModelGenerator.ProfileData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure that holds profile data (interpolated/projected on the profile)</p><pre><code class="nohighlight hljs">struct ProfileData
    vertical        ::  Bool # vertical:true, horizontal:false
    start_lonlat    ::  Union{Nothing,Tuple{Float64,Float64}}
    end_lonlat      ::  Union{Nothing,Tuple{Float64,Float64}}
    depth           ::  Union{Nothing,Float64}
    VolData         ::  GeophysicalModelGenerator.GeoData
    SurfData        ::  Union{Nothing, NamedTuple}
    PointData       ::  Union{Nothing, NamedTuple}
    ScreenshotData  ::  Union{Nothing, NamedTuple}
end

Structure to store cross section data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L9-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ProjectionPoint-Tuple{Float64, Float64, Int64, Bool}"><a class="docstring-binding" href="#GeophysicalModelGenerator.ProjectionPoint-Tuple{Float64, Float64, Int64, Bool}"><code>GeophysicalModelGenerator.ProjectionPoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ProjectionPoint(EW::Float64, NS::Float64, Zone::Int64, isnorth::Bool)</code></pre><p>Defines a projection point used for map projections, by specifying UTM coordinates (EW/NS), UTM Zone and whether you are on the northern hemisphere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L46-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ProjectionPoint-Tuple{}"><a class="docstring-binding" href="#GeophysicalModelGenerator.ProjectionPoint-Tuple{}"><code>GeophysicalModelGenerator.ProjectionPoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ProjectionPoint(; Lat=49.9929, Lon=8.2473)</code></pre><p>Defines a projection point used for map projections, by specifying latitude and longitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.Q1Data-Tuple{Tuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.Q1Data-Tuple{Tuple}"><code>GeophysicalModelGenerator.Q1Data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Q1Data(xyz::Tuple{Array,Array,Array})</code></pre><p>This creates a <code>Q1Data</code> struct if you have a Tuple with 3D coordinates as input.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; data = Q1Data(xyz_grid(-10:10,-5:5,0))
CartData
    size    : (21, 11, 1)
    x       ϵ [ -10.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ 0.0 km : 0.0 km]
    fields  : (:Z,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1408-L1423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.Trench"><a class="docstring-binding" href="#GeophysicalModelGenerator.Trench"><code>GeophysicalModelGenerator.Trench</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Trench structure</code></pre><p>Structure that defines the geometry of the trench and the slab.</p><p><strong>Parameters</strong></p><ul><li><p><code>Start</code>     - Start of the trench (<code>x</code>,<code>y</code>) coordinates</p></li><li><p><code>End</code>       - End of the trench (<code>x</code>,<code>y</code>) coordinates</p></li><li><p><code>n_seg</code>     - The number of segment through which the slab is discretize along the dip</p></li><li><p><code>Length</code>    - The length of the slab</p></li><li><p><code>Thickness</code> - The thickness of the slab</p></li><li><p><code>Lb</code>        - Critical distance through which apply the bending angle functions Lb ∈ [0,Length];</p></li><li><p><code>θ_max</code>     - maximum angle of bending ∈ [0°,90°].</p></li><li><p><code>direction</code> - the direction of the dip              The rotation of the coordinate system is done as such that the new X is parallel to the segment. Since the              rotation is anticlockwise the coordinate y has specific values: direction tells if the subduction is directed along              the positive or negative direction of the new y coordinate system. In practice, it apply an additional transformation              to y by multiplying it with -1 or +1;</p></li><li><p><code>d_decoupling</code> - depth at which the slab is fully submerged into the mantle.</p></li><li><p><code>type_bending</code> - is the type of bending angle of the slab [<code>:Linear</code>, <code>:Ribe</code>].   The angle of slab changes as a function of <code>l</code> (∈ [0,Length]). <code>l</code> is the actual distance along the slab length from   the trench.   In case:       - <code>:Linear</code>           <code>math θ(l) = ((θ_max - 0.0)/(Lb-0))*l</code>;       - <code>:Ribe</code>           <code>math θ(l) =  θ_max*l^2*((3*Lb-2*l))/(Lb^3)</code>;           which is taken from Ribe 2010 [Bending mechanics and mode selection in free subduction: a thin-sheet analysis]</p><p>For l&gt;Lb, θ(l) = θ_max;</p></li><li><p><code>WeakzoneThickness</code> - Thickness of the weakzone [km]</p></li><li><p><code>WeakzonePhase</code> - Phase of the weakzone</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1844-L1879">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.convert-Tuple{Type{GeoData}, UTMData}"><a class="docstring-binding" href="#Base.convert-Tuple{Type{GeoData}, UTMData}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Converts a <code>UTMData</code> structure to a <code>GeoData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L524-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.convert-Tuple{Type{UTMData}, GeoData}"><a class="docstring-binding" href="#Base.convert-Tuple{Type{UTMData}, GeoData}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Converts a <code>GeoData</code> structure to a <code>UTMData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L559-L561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.Create1D_grid_vector-Tuple{Vector{Float64}, Int64, Int64, Union{Nothing, Int64}, Union{Nothing, Float64}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.Create1D_grid_vector-Tuple{Vector{Float64}, Int64, Int64, Union{Nothing, Int64}, Union{Nothing, Float64}}"><code>GeophysicalModelGenerator.Create1D_grid_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns 1D coordinate vectors of grid points and of marker locations for a regular spacing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L263-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.Create1D_grid_vector-Union{Tuple{I}, Tuple{T}, Tuple{Vector{T}, Vector{I}, I, I, Union{Nothing, Vector{T}, T}}} where {T&lt;:Float64, I&lt;:Int64}"><a class="docstring-binding" href="#GeophysicalModelGenerator.Create1D_grid_vector-Union{Tuple{I}, Tuple{T}, Tuple{Vector{T}, Vector{I}, I, I, Union{Nothing, Vector{T}, T}}} where {T&lt;:Float64, I&lt;:Int64}"><code>GeophysicalModelGenerator.Create1D_grid_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns 1D coordinate vectors of grid points and of marker locations for a regular spacing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L277-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.InterpolateDataFields2D_vecs-NTuple{6, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.InterpolateDataFields2D_vecs-NTuple{6, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields2D_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D_vecs(x_vec, y_vec, depth, fields_new, X, Y)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>UTM</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1311-L1315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ParseValue_CommandLineArgs-NTuple{4, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.ParseValue_CommandLineArgs-NTuple{4, Any}"><code>GeophysicalModelGenerator.ParseValue_CommandLineArgs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">This parses a LaMEM command line argument string and checks if the keyword exists there</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L147-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.ParseValue_LaMEM_InputFile-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.ParseValue_LaMEM_InputFile-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.ParseValue_LaMEM_InputFile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">value = ParseValue_LaMEM_InputFile(file,keyword,type; args::String=nothing)</code></pre><p>Extracts a certain <code>keyword</code> from a LaMEM input <code>file</code> and convert it to a certain type. Optionally, you can also pass command-line arguments which will override the value read from the input file.</p><p><strong>Example 1:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nmark_z = ParseValue_LaMEM_InputFile(&quot;SaltModels.dat&quot;,&quot;nmark_z&quot;,Int64)</code></pre><p><strong>Example 2:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nmark_z = ParseValue_LaMEM_InputFile(&quot;SaltModels.dat&quot;,&quot;nmark_z&quot;,Int64, args=&quot;-nel_x 128 -coord_x -4,4&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L93-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.PetscBinaryWrite_Vec-Tuple{Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.PetscBinaryWrite_Vec-Tuple{Any, Any}"><code>GeophysicalModelGenerator.PetscBinaryWrite_Vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PetscBinaryWrite_Vec(filename, A)</code></pre><p>Writes a vector <code>A</code> to disk, such that it can be read with <code>PetscBinaryRead</code> (which assumes a Big Endian type)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L542-L547">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.Rot3D-Union{Tuple{_T}, NTuple{7, _T}} where _T&lt;:Number"><a class="docstring-binding" href="#GeophysicalModelGenerator.Rot3D-Union{Tuple{_T}, NTuple{7, _T}} where _T&lt;:Number"><code>GeophysicalModelGenerator.Rot3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">xrot, yrot, zrot = Rot3D(X::Number,Y::Number,Z::Number, cosStrikeAngle, sindStrikeAngle, cosDipAngle, sinDipAngle)</code></pre><p>Perform rotation for a point in 3D space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L860-L864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.above_surface-Tuple{CartGrid, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.above_surface-Tuple{CartGrid, CartData}"><code>GeophysicalModelGenerator.above_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Above = above_surface(Grid::CartGrid, DataSurface_Cart::CartData; above=true, cell=false)</code></pre><p>Determines if points described by the <code>Grid</code> CartGrid structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L290-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.above_surface-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.above_surface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.above_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">above_surface(Data::GeoData, DataSurface::GeoData; above=true)</code></pre><p>Returns a boolean array of size(Data.Lon), which is true for points that are above the surface DataSurface (or for points below if above=false).</p><p>This can be used, for example, to mask points above/below the Moho in a volumetric dataset or in a profile.</p><p><strong>Example</strong></p><p>First we create a 3D data set and a 2D surface:</p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData)
julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,-40km);
julia&gt; Data_Moho       =   GeoData(Lon,Lat,Depth+Lon*km, (MohoDepth=Depth,))
  GeoData
    size  : (11, 11, 1)
    lon   ϵ [ 10.0 : 20.0]
    lat   ϵ [ 30.0 : 40.0]
    depth ϵ [ -30.0 km : -20.0 km]
    fields: (:MohoDepth,)</code></pre><p>Next, we intersect the surface with the data set:</p><pre><code class="language-julia-repl hljs">julia&gt; Above       =   above_surface(Data_set3D, Data_Moho);</code></pre><p>Now, <code>Above</code> is a boolean array that is true for points above the surface and false for points below and at the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L192-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.above_surface-Tuple{LaMEM_grid, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.above_surface-Tuple{LaMEM_grid, CartData}"><code>GeophysicalModelGenerator.above_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Above = above_surface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are above the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L83-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.above_surface-Tuple{ParaviewData, ParaviewData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.above_surface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.above_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Above = above_surface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L259-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.above_surface-Tuple{Union{CartData, Q1Data}, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.above_surface-Tuple{Union{CartData, Q1Data}, CartData}"><code>GeophysicalModelGenerator.above_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Above = above_surface(Data_Cart::Union{Q1Data,CartData}, DataSurface_Cart::CartData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L272-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_box!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_box!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_box!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_box!(Phase, Temp, Grid::AbstractGeneralGrid; xlim::Tuple = (20,100), [ylim::Tuple = (1,10)], zlim::Tuple = (10,80),
        Origin=nothing, StrikeAngle=0, DipAngle=0,
        phase = ConstantPhase(1),
        T=nothing,
        segments=nothing,
        cell=false )</code></pre><p>Adds a box with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code> -  grid structure (can be any of the grid types in <code>GMG</code>)</li><li><code>xlim</code> -  left/right coordinates of box</li><li><code>ylim</code> -  front/back coordinates of box [optional; if not specified we use the whole box]</li><li><code>zlim</code> -  bottom/top coordinates of box</li><li><code>Origin</code> - the origin, used to rotate the box around. Default is the left-front-top corner</li><li><code>StrikeAngle</code> - strike angle of slab</li><li><code>DipAngle</code> - dip angle of slab</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code> - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code>,<code>LithosphericTemp()</code></li><li><code>segments</code> - optional parameter to define multiple ridge segments within the box</li><li><code>cell</code> - if true, <code>Phase</code> and <code>Temp</code> are defined on centers</li></ul><p><strong>Examples</strong></p><p>Example 1) Box with constant phase and temperature &amp; a dip angle of 10 degrees:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_box!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre><p>Example 2) Box with halfspace cooling profile</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = CartData(xyz_grid(-1000:10:1000,0,-660:10:0))
julia&gt; Phases = zeros(Int32,   size(Grid));
julia&gt; Temp   = zeros(Float64, size(Grid));
julia&gt; add_box!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=HalfspaceCoolingTemp(Age=30))
julia&gt; Grid = addfield(Grid, (;Phases,Temp));       # Add to Cartesian model
julia&gt; write_paraview(Grid,&quot;LaMEM_ModelSetup&quot;)  # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre><p>Example 3) Box with ridge thermal structure ```julia-repl julia&gt; Grid = CartData(xyz<em>grid(-1000:10:1000, -1000:10:1000, -660:5:0)) julia&gt; Phases = fill(2, size(Grid)); julia&gt; Temp   = fill(1350.0, size(Grid)); julia&gt; segments = [((-500.0, -1000.0), (-500.0, 0.0)),                     ((-250.0, 0.0), (-250.0, 200.0)),                     ((-750.0, 200.0), (-750.0, 1000.0))]; julia&gt; lith = LithosphericPhases(Layers=[15 55], Phases=[1 2], Tlab=1250); julia&gt; add</em>box!(Phases, Temp, Grid; xlim=(-1000.0, 0.0), ylim=(-500.0, 500.0),                 zlim=(-80.0, 0.0), phase=lith,                 T=SpreadingRateTemp(SpreadingVel=3), segments=segments) julia&gt; Grid = addfield(Grid, (; Phases, Temp));       # Add to Cartesian model julia&gt; write<em>paraview(Grid, &quot;Ridge</em>Thermal<em>Structure&quot;)  # Save model to Paraview 1-element Vector{String}:  &quot;Ridge</em>Thermal_Structure.vts&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L168-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_cylinder!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_cylinder!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_cylinder!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_cylinder!(Phase, Temp, Grid::AbstractGeneralGrid; base::Tuple = (-1,-1,-1.5), cap::Tuple = (-1,-1,-0.5), radius::Number,
        phase = ConstantPhase(1),
        T=nothing, cell=false )</code></pre><p>Adds a cylinder with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code> - Grid structure (usually obtained with <code>read_LaMEM_inputfile</code>)</li><li><code>base</code> - center coordinate of bottom of cylinder</li><li><code>cap</code> - center coordinate of top of cylinder</li><li><code>radius</code> - radius of the cylinder</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code> - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li><li><code>cell</code> - if true, <code>Phase</code> and <code>Temp</code> are defined on cell centers</li></ul><p><strong>Example</strong></p><p>Cylinder with constant phase and temperature:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_cylinder!(Phases,Temp,Grid, base=(-1,-1,-1.5), cap=(1,1,-0.5), radius=0.25, phase=ConstantPhase(4), T=ConstantTemp(400))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L586-L629">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_ellipsoid!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_ellipsoid!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_ellipsoid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_ellipsoid!(Phase, Temp, Grid::AbstractGeneralGrid; cen::Tuple = (-1,-1,-1), axes::Tuple = (0.2,0.1,0.5),
        Origin=nothing, StrikeAngle=0, DipAngle=0,
        phase = ConstantPhase(1).
        T=nothing, cell=false )</code></pre><p>Adds an Ellipsoid with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code> - LaMEM grid structure (usually obtained with read<em>LaMEM</em>inputfile)</li><li><code>cen</code> - center coordinates of sphere</li><li><code>axes</code> - semi-axes of ellipsoid in X,Y,Z</li><li><code>Origin</code> - the origin, used to rotate the box around. Default is the left-front-top corner</li><li><code>StrikeAngle</code> - strike angle of slab</li><li><code>DipAngle</code> - dip angle of slab</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code> - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li><li><code>cell</code> - if true, <code>Phase</code> and <code>Temp</code> are defined on cell centers</li></ul><p><strong>Example</strong></p><p>Ellipsoid with constant phase and temperature, rotated 90 degrees and tilted by 45 degrees:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_ellipsoid!(Phases,Temp,Grid, cen=(-1,-1,-1), axes=(0.2,0.1,0.5), StrikeAngle=90, DipAngle=45, phase=ConstantPhase(3), T=ConstantTemp(600))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L492-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_fault!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_fault!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_fault!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_fault!(Phase, Temp, Grid::AbstractGeneralGrid;
    Start=(20,100), End=(10,80),
    Fault_thickness=10.0,
    Depth_extent=nothing,
    DipAngle=0e0,
    phase=ConstantPhase(1),
    T=nothing,
    cell=false)</code></pre><p>Adds a fault to the given 3D grid by modifying the <code>Phase</code> and <code>Temp</code> arrays. For a 2D grid, use <code>add_box</code> instead.</p><p><strong>Arguments</strong></p><ul><li><code>Phase</code>: Phase array</li><li><code>Temp</code>: Temp array</li><li><code>Grid</code>: The grid on which the fault is to be added.</li><li><code>Start</code>: Tuple representing the starting coordinates of the fault (X, Y).</li><li><code>End</code>: Tuple representing the ending coordinates of the fault (X, Y).</li><li><code>Fault_thickness</code>: Thickness of the fault.</li><li><code>Depth_extent</code>: Depth extent of the fault. If <code>nothing</code>, the fault extends through the entire domain.</li><li><code>DipAngle</code>: Dip angle of the fault.</li><li><code>phase</code>: Phase to be assigned to the fault.</li><li><code>T</code>: Temperature to be assigned to the fault. If <code>nothing</code>, the temperature is not modified.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">add_fault!(Phase, Temp, Grid;
        Start=(20,100), End=(10,80),
        Fault_thickness=10.0,
        Depth_extent=(-25.0, 0.0),
        DipAngle=-10.0,
        phase=ConstantPhase(1)
        )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L2203-L2239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_layer!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_layer!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_layer!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_layer!(Phase, Temp, Grid::AbstractGeneralGrid; xlim::Tuple = (1,100), [ylim::Tuple = (0,20)], zlim::Tuple = (0,-100),
        phase = ConstantPhase(1),
        T=nothing, cell=false )</code></pre><p>Adds a layer with phase &amp; temperature structure to a 3D model setup. The most common use would be to add a lithospheric layer to a model setup. This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code> -  grid structure (usually obtained with read<em>LaMEM</em>inputfile, but can also be other grid types)</li><li><code>xlim</code> -  left/right coordinates of box</li><li><code>ylim</code> -  front/back coordinates of box</li><li><code>zlim</code> -  bottom/top coordinates of box</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code> - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li></ul><p><strong>Examples</strong></p><p>Example 1) Layer with constant phase and temperature</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_layer!(Phases,Temp,Grid, zlim=(-50,0), phase=ConstantPhase(3), T=ConstantTemp(1000))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre><p>Example 2) Box with halfspace cooling profile</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_layer!(Phases,Temp,Grid, zlim=(-50,0), phase=ConstantPhase(3), T=HalfspaceCoolingTemp())
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L316-L371">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_polygon!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_polygon!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_polygon!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    add_polygon!(Phase, Temp, Grid::AbstractGeneralGrid; xlim=(), ylim::Tuple = (0.0,0.8), zlim=(), phase = ConstantPhase(1), T=nothing, cell=false )</code></pre><p>Adds a polygon with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code>  - Grid structure (usually obtained with read<em>LaMEM</em>inputfile)</li><li><code>xlim</code>  - <code>x</code>-coordinate of the polygon points, same ordering as zlim, number of points unlimited</li><li><code>ylim</code>  - <code>y</code>-coordinate, limitation in length possible (two values (start and stop))</li><li><code>zlim</code>  - <code>z</code>-coordinate of the polygon points, same ordering as xlim, number of points unlimited</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code></li><li><code>T</code>     - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li><li><code>cell</code>  - if true, <code>Phase</code> and <code>Temp</code> are defined on cell centers</li></ul><p><strong>Example</strong></p><p>Polygon with constant phase and temperature:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_polygon!(Phase, Temp, Cart; xlim=(0,0, 1.6, 2.0),ylim=(0,0.8), zlim=(0,-1,-2,0), phase = ConstantPhase(8), T=ConstantTemp(30))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L689-L730">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_slab!-Tuple{Any, Any, AbstractGeneralGrid, Trench}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_slab!-Tuple{Any, Any, AbstractGeneralGrid, Trench}"><code>GeophysicalModelGenerator.add_slab!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_slab!(Phase, Temp, Grid::AbstractGeneralGrid,  trench::Trench; phase = ConstantPhase(1), T = nothing, cell=false)</code></pre><p>Adds a curved slab with phase &amp; temperature structure to a 3D model setup.</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code>   - Phase array (consistent with Grid)</li><li><code>Temp</code>    - Temperature array (consistent with Grid)</li><li><code>Grid</code>    - grid structure (can be any of the grid types in <code>GMG</code>)</li><li><code>trench</code>  - Trench structure</li><li><code>phase</code>   - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code>       - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code>,<code>LithosphericTemp()</code></li><li><code>cell</code>    - if true, <code>Phase</code> and <code>Temp</code> are defined on cells</li></ul><p><strong>Examples</strong></p><p>Example 1) Slab</p><pre><code class="language-julia-repl hljs">julia&gt; x     = LinRange(0.0,1200.0,128);
julia&gt; y     = LinRange(0.0,1200.0,128);
julia&gt; z     = LinRange(-660,50,128);
julia&gt; Cart  = CartData(xyz_grid(x, y, z));
julia&gt; Phase = ones(Int64,size(Cart));
julia&gt; Temp  = fill(1350.0,size(Cart));
# Define the trench:
julia&gt; trench= Trench(Start = (400.0,400.0), End = (800.0,800.0), θ_max = 45.0, direction = 1.0, n_seg = 50, Length = 600.0, Thickness = 80.0, Lb = 500.0, d_decoupling = 100.0, type_bending =:Ribe)
julia&gt; phase = LithosphericPhases(Layers=[5 7 88], Phases = [2 3 4], Tlab=nothing)
julia&gt; TsHC  = HalfspaceCoolingTemp(Tsurface=20.0, Tmantle=1350, Age=30, Adiabat=0.4)
julia&gt; add_slab!(Phase, Temp, Cart, trench, phase = phase, T = TsHC)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L2118-L2151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_sphere!-Tuple{Any, Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_sphere!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_sphere!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_sphere!(Phase, Temp, Grid::AbstractGeneralGrid; cen::Tuple = (0,0,-1), radius::Number,
        phase = ConstantPhase(1).
        T=nothing, cell=false )</code></pre><p>Adds a sphere with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Temp</code>  - Temperature array (consistent with Grid)</li><li><code>Grid</code> - LaMEM grid structure (usually obtained with read<em>LaMEM</em>inputfile)</li><li><code>cen</code> - center coordinates of sphere</li><li><code>radius</code> - radius of sphere</li><li><code>phase</code> - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li><code>T</code> - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li><li><code>cell</code> - if true, <code>Phase</code> and <code>Temp</code> are defined on cell centers</li></ul><p><strong>Example</strong></p><p>Sphere with constant phase and temperature:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_sphere!(Phases,Temp,Grid, cen=(0,0,-1), radius=0.5, phase=ConstantPhase(2), T=ConstantTemp(800))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L421-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_stripes!-Tuple{Any, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_stripes!-Tuple{Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.add_stripes!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_stripes!(Phase, Grid::AbstractGeneralGrid;
    stripAxes       = (1,1,0),
    stripeWidth     =  0.2,
    stripeSpacing   =  1,
    Origin          =  nothing,
    StrikeAngle     =  0,
    DipAngle        =  10,
    phase           =  ConstantPhase(3),
    stripePhase     =  ConstantPhase(4),
    cell            = false)</code></pre><p>Adds stripes to a pre-defined phase (e.g. added using add_box!)</p><p><strong>Parameters</strong></p><ul><li><code>Phase</code> - Phase array (consistent with Grid)</li><li><code>Grid</code> -  grid structure (usually obtained with read<em>LaMEM</em>inputfile, but can also be other grid types)</li><li><code>stripAxes</code> - sets the axis for which we want the stripes. Default is (1,1,0) i.e. X, Y and not Z</li><li><code>stripeWidth</code> - width of the stripe</li><li><code>stripeSpacing</code> - space between two stripes</li><li><code>Origin</code> - the origin, used to rotate the box around. Default is the left-front-top corner</li><li><code>StrikeAngle</code> - strike angle</li><li><code>DipAngle</code> - dip angle</li><li><code>phase</code> - specifies the phase we want to apply stripes to</li><li><code>stripePhase</code> - specifies the stripe phase</li><li><code>cell</code> - if true, <code>Phase</code> and <code>Temp</code> are defined on centers</li></ul><p><strong>Example</strong></p><p>Example: Box with striped phase and constant temperature &amp; a dip angle of 10 degrees:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; add_box!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))
julia&gt; add_stripes!(Phases, Grid, stripAxes=(1,1,1), stripeWidth=0.2, stripeSpacing=1, Origin=nothing, StrikeAngle=0, DipAngle=10, phase=ConstantPhase(3), stripePhase=ConstantPhase(4))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; write_paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L58-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.add_volcano!-Tuple{Any, Any, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.add_volcano!-Tuple{Any, Any, CartData}"><code>GeophysicalModelGenerator.add_volcano!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>add<em>volcano!(     Phases, Temp, Grid::CartData;     volcanic</em>phase,     center,     height,     radius,     crater,     base,     background,     T, )</p><p>Adds a volcano topography (cones and truncated cones)</p><p><strong>Parameters</strong></p><ul><li>Phases - Phase array (consistent with Grid)</li><li>Temp - Temperature array (consistent with Grid)</li><li>Grid - CartData</li></ul><p><strong>Optional Parameters</strong></p><ul><li>volcanic_phase - phase number of the volcano,</li><li>center - x- and -coordinates of center of volcano</li><li>height - height of volcano</li><li>radius - radius of volcano</li><li>T - temperature structure of the volcano</li><li>crater - this will create a truncated cone and the option defines the radius of the flat top</li><li>base - this sets the flat topography around the volcano</li><li>background - this allows loading in a topography and only adding the volcano on top (also allows stacking of several cones to get a volcano with different slopes)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L879-L910">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.addfield-Tuple{AbstractGeneralGrid, String, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.addfield-Tuple{AbstractGeneralGrid, String, Any}"><code>GeophysicalModelGenerator.addfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = addfield(V::AbstractGeneralGrid,field_name::String,data::Any)</code></pre><p>Add Fields Data to GeoData or CartData</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.addfield-Tuple{CartData, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.addfield-Tuple{CartData, NamedTuple}"><code>GeophysicalModelGenerator.addfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = addfield(V::CartData,new_fields::NamedTuple)</code></pre><p>Add <code>new_fields</code> fields to a <code>CartData</code> dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.addfield-Tuple{FEData, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.addfield-Tuple{FEData, NamedTuple}"><code>GeophysicalModelGenerator.addfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = addfield(V::FEData,new_fields::NamedTuple; cellfield=false)</code></pre><p>Add <code>new_fields</code> fields to a <code>FEData</code> dataset; set <code>cellfield</code> to <code>true</code> if the field is a cell field; otherwise it is a vertex field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.addfield-Tuple{GeoData, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.addfield-Tuple{GeoData, NamedTuple}"><code>GeophysicalModelGenerator.addfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = addfield(V::GeoData,new_fields::NamedTuple)</code></pre><p>Add <code>new_fields</code> fields to a <code>GeoData</code> dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.addfield-Tuple{Q1Data, NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.addfield-Tuple{Q1Data, NamedTuple}"><code>GeophysicalModelGenerator.addfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = addfield(V::Q1Data,new_fields::NamedTuple; cellfield=false)</code></pre><p>Add <code>new_fields</code> fields to a <code>Q1Data</code> dataset; set <code>cellfield</code> to <code>true</code> if the field is a cell field; otherwise it is a vertex field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.average_q1-Tuple{Array}"><a class="docstring-binding" href="#GeophysicalModelGenerator.average_q1-Tuple{Array}"><code>GeophysicalModelGenerator.average_q1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">out = average_q1(d::Array)</code></pre><p>3D linear averaging of a 3D array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1009-L1013">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.below_surface"><a class="docstring-binding" href="#GeophysicalModelGenerator.below_surface"><code>GeophysicalModelGenerator.below_surface</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Below = below_surface(Data_Cart::Union{CartData,Q1Data}, DataSurface_Cart::CartData, cell=false)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are below the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L327-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.below_surface-Tuple{CartGrid, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.below_surface-Tuple{CartGrid, CartData}"><code>GeophysicalModelGenerator.below_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Below = below_surface(Grid::CartGrid, DataSurface_Cart::CartData)

Determines if points described by the `Grid` CartGrid structure are above the Cartesian surface `DataSurface_Cart`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L308-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.below_surface-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.below_surface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.below_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Below = below_surface(Data::GeoData, DataSurface::GeoData)</code></pre><p>Determines if points within the 3D <code>Data</code> structure are below the GeoData surface <code>DataSurface</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L250-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.below_surface-Tuple{LaMEM_grid, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.below_surface-Tuple{LaMEM_grid, CartData}"><code>GeophysicalModelGenerator.below_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Below = below_surface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are below the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L74-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.below_surface-Tuple{ParaviewData, ParaviewData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.below_surface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.below_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Below = below_surface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData)</code></pre><p>Determines if points within the 3D Data<em>Cart structure are below the Cartesian surface DataSurface</em>Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L318-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cell_area-Tuple{GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cell_area-Tuple{GeoData}"><code>GeophysicalModelGenerator.cell_area</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">area_m2 = cell_area(Topo::GeoData)</code></pre><p>Returns the cell area for a Topographic dataset in m² (required for upstream area calculation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/WaterFlow.jl#L26-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cell_tags_from_gmsh-Tuple{Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cell_tags_from_gmsh-Tuple{Any}"><code>GeophysicalModelGenerator.cell_tags_from_gmsh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tags = cell_tags_from_gmsh(mesh::GmshDiscreteModel)</code></pre><p>Returns a list with integers that are the tags for each of the cells</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L9-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.combine_vol_data-Tuple{NamedTuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.combine_vol_data-Tuple{NamedTuple}"><code>GeophysicalModelGenerator.combine_vol_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VolData_combined = combine_vol_data(VolData::NamedTuple; lat=nothing, lon=nothing, depth=nothing, dims=(100,100,100), dataset_preferred = 1)</code></pre><p>This takes different volumetric datasets (specified in <code>VolData</code>) &amp; merges them into a single one. You need to either provide the &quot;reference&quot; dataset within the NamedTuple (<code>dataset_preferred</code>), or the lat/lon/depth and dimensions of the new dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L213-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.compute_bending_angle-Tuple{Float64, Float64, Float64, Symbol}"><a class="docstring-binding" href="#GeophysicalModelGenerator.compute_bending_angle-Tuple{Float64, Float64, Float64, Symbol}"><code>GeophysicalModelGenerator.compute_bending_angle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">θ = compute_bending_angle(θ_max,Lb,l,type)</code></pre><p>function that computes the bending angle <code>θ</code> as a function of length along the slab <code>l</code>.</p><p><strong>Parameters</strong></p><p><code>θ_max</code> = maximum bending angle <code>Lb</code>    = length at which the function of bending is applied (Lb&lt;=Length) <code>l</code>     = current position within the slab <code>type</code>  = type of bending [<code>:Ribe</code>,<code>:Linear</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1989-L2001">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.compute_phase-Tuple{Any, Any, Any, Any, Any, LithosphericPhases}"><a class="docstring-binding" href="#GeophysicalModelGenerator.compute_phase-Tuple{Any, Any, Any, Any, Any, LithosphericPhases}"><code>GeophysicalModelGenerator.compute_phase</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Phase = compute_phase(Phase, Temp, X, Y, Z, s::LithosphericPhases, Ztop)</code></pre><p>or</p><pre><code class="nohighlight hljs">Phase = compute_phase(Phase, Temp, Grid::AbstractGeneralGrid, s::LithosphericPhases)</code></pre><p>This copies the layered lithosphere onto the Phase matrix.</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array</li><li>Temp  - Temperature array</li><li>X     - x-coordinate array (consistent with Phase and Temp)</li><li>Y     - y-coordinate array (consistent with Phase and Temp)</li><li>Z     - Vertical coordinate array (consistent with Phase and Temp)</li><li>s     - LithosphericPhases</li><li>Ztop  - Vertical coordinate of top of model box</li><li>Grid  - Grid structure (usually obtained with read<em>LaMEM</em>inputfile)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1646-L1665">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.compute_slab_surface-Tuple{Trench}"><a class="docstring-binding" href="#GeophysicalModelGenerator.compute_slab_surface-Tuple{Trench}"><code>GeophysicalModelGenerator.compute_slab_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Top, Bot = compute_slab_surface(trench::Trench)</code></pre><p>Computes the (<code>x</code>,<code>z</code>) coordinates of the slab top, bottom surface using the mid surface of the slab as reference.</p><p><strong>Parameters</strong></p><ul><li><code>trench</code>          - <code>Trench</code> structure that contains the relevant parameters</li></ul><p><strong>Method</strong></p><p>It computes it by discretizing the slab surface in <code>n_seg</code> segments, and computing the average bending angle (which is a function of the current length of the slab). Next, it compute the coordinates assuming that the trench is at 0.0, and assuming a positive <code>θ_max</code> angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1917-L1931">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.compute_thermal_structure-Tuple{Any, Any, Any, Any, Any, LinearWeightedTemperature}"><a class="docstring-binding" href="#GeophysicalModelGenerator.compute_thermal_structure-Tuple{Any, Any, Any, Any, Any, LinearWeightedTemperature}"><code>GeophysicalModelGenerator.compute_thermal_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_thermal_structure(Temp, X, Y, Z, Phase, s::LinearWeightedTemperature)</code></pre><p>Weight average along distance</p><p>Do a weight average between two field along a specified direction</p><p>Given a distance (could be any array, from X,Y) -&gt; the weight of F1 increase from the origin, while F2 decreases.</p><p>This function has been conceived for averaging the solution of McKenzie and half space cooling models, but it can be used to smooth the temperature field from continent ocean:</p><ul><li>Select the boundary to apply;</li><li>transform the coordinate such that dist represent the perpendicular direction along which you want to apply this smoothening and in a such way that 0.0 is the point in which the weight of F1 is equal to 0.0;</li><li>Select the points that belongs to this area</li><li>compute the thermal fields {F1} {F2}</li><li>then modify F.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1789-L1806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.compute_thermal_structure-Tuple{Any, Any, Any, Any, Any, McKenzie_subducting_slab}"><a class="docstring-binding" href="#GeophysicalModelGenerator.compute_thermal_structure-Tuple{Any, Any, Any, Any, Any, McKenzie_subducting_slab}"><code>GeophysicalModelGenerator.compute_thermal_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_thermal_structure(Temp, X, Y, Z, Phase, s::McKenzie_subducting_slab)</code></pre><p>Compute the temperature field of a <code>McKenzie_subducting_slab</code>. Uses the analytical solution of McKenzie (1969) [&quot;Speculations on the consequences and causes of plate motions&quot;]. The functions assumes that the bottom of the slab is the coordinate Z=0. Internally the function shifts the coordinate.</p><p>Parameters</p><p>=============================</p><ul><li><code>Temp</code>:  Temperature array</li><li><code>X</code>:    X Array</li><li><code>Y</code>:    Y Array</li><li><code>Z</code>:    Z Array</li><li><code>Phase</code>: Phase array</li><li><code>s</code>:    <code>McKenzie_subducting_slab</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L1716-L1732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.convert2CartData-Tuple{GeoData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.convert2CartData-Tuple{GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.convert2CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert2CartData(d::GeoData, proj::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L858-L861">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.convert2CartData-Tuple{UTMData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.convert2CartData-Tuple{UTMData, ProjectionPoint}"><code>GeophysicalModelGenerator.convert2CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert2CartData(d::UTMData, proj::ProjectionPoint)</code></pre><p>Converts a <code>UTMData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L838-L841">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.convert2FEData-Tuple{Q1Data}"><a class="docstring-binding" href="#GeophysicalModelGenerator.convert2FEData-Tuple{Q1Data}"><code>GeophysicalModelGenerator.convert2FEData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fe_data::FEData = convert2FEData(d::Q1Data)</code></pre><p>Creates a Q1 FEM mesh from the <code>Q1Data</code> data which holds the vertex coordinates and cell/vertex fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1499-L1503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.convert2UTMzone-Tuple{CartData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.convert2UTMzone-Tuple{CartData, ProjectionPoint}"><code>GeophysicalModelGenerator.convert2UTMzone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert2UTMzone(d::CartData, proj::ProjectionPoint)</code></pre><p>This transfers a <code>CartData</code> dataset to a <code>UTMData</code> dataset, that has a single UTM zone. The point around which we project is <code>ProjectionPoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L824-L828">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.convert2UTMzone-Tuple{GeoData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.convert2UTMzone-Tuple{GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.convert2UTMzone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert2UTMzone(d::GeoData, p::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to fixed UTM zone, around a given <code>ProjectionPoint</code>     This useful to use real data as input for a cartesian geodynamic model setup (such as in LaMEM). In that case, we need to project map coordinates to cartesian coordinates.     One way to do this is by using UTM coordinates. Close to the <code>ProjectionPoint</code> the resulting coordinates will be rectilinear and distance in meters. The map distortion becomes larger the further you are away from the center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L617-L624">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{CartData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::CartData; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1032-L1036">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{CartGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{CartGrid}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::CartGrid; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1257-L1261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{GeoData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LON,LAT,Z = coordinate_grids(Data::GeoData; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1047-L1051">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{LaMEM_grid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{LaMEM_grid}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::LaMEM_grid; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L1027-L1031">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{ParaviewData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{ParaviewData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::ParaviewData; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1078-L1082">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{Q1Data}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{Q1Data}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::Q1Data; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1485-L1489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.coordinate_grids-Tuple{UTMData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{UTMData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EW,NS,Z = coordinate_grids(Data::UTMData; cell=false)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1062-L1066">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.countmap-Tuple{GeoData, String, Int64, Int64}"><a class="docstring-binding" href="#GeophysicalModelGenerator.countmap-Tuple{GeoData, String, Int64, Int64}"><code>GeophysicalModelGenerator.countmap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DatasetcountMap = countmap(DataSet::GeoData,field::String,stepslon::Int64,stepslat::Int64)</code></pre><p>Takes a 2D GeoData struct and counts entries of <code>field</code> per predefined control area. <code>field</code> should only consist of 1.0s and 0.0s. The control area is defined by <code>steplon</code> and <code>steplat</code>. <code>steplon</code> is the number of control areas in longitude direction and <code>steplat</code> the number of control areas in latitude direction. The counts per control area are normalized by the highest count.</p><pre><code class="language-julia hljs">julia&gt; Data_Faults         = GeoData(Lon3D,Lat3D,Faults,(Faults=Faults,))
GeoData 
    size      : (375, 208, 1)
    lon       ϵ [ -9.932408319802885 : 34.93985125012068]
    lat       ϵ [ 35.086096468211394 : 59.919210145128545]
    depth     ϵ [ 0.0 : 1.0]
    fields    : (:Faults,)

julia&gt; steplon  = 125
julia&gt; steplat  = 70
julia&gt; countmap = countmap(Data_Faults,&quot;Faults&quot;,steplon,steplat)

GeoData 
    size      : (124, 69, 1)
    lon       ϵ [ -9.751471789279 : 34.75891471959677]
    lat       ϵ [ 35.26604656731949 : 59.73926004602028]
    depth     ϵ [ 0.0 : 1.0]
    fields    : (:countmap,)</code></pre><p>julia</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L117-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.create_CartGrid-Tuple{}"><a class="docstring-binding" href="#GeophysicalModelGenerator.create_CartGrid-Tuple{}"><code>GeophysicalModelGenerator.create_CartGrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid = create_CartGrid(; size=(), x = nothing, z = nothing, y = nothing, extent = nothing, CharDim = nothing)</code></pre><p>Creates a 1D, 2D or 3D cartesian grid of given size. Grid can be created by defining the size and either the <code>extent</code> (length) of the grid in all directions, or by defining start &amp; end points (<code>x</code>,<code>y</code>,<code>z</code>). If you specify <code>CharDim</code> (a structure with characteristic dimensions created with <code>GeoParams.jl</code>), we will nondimensionalize the grd before creating the struct.</p><p>Spacing is assumed to be constant in a given direction</p><p>This can also be used for staggered grids, as we also create 1D vectors for the central points. The points you indicate in <code>size</code> are the corner points.</p><p>Note: since this is mostly for solid Earth geoscience applications, the second dimension is called z (vertical)</p><p><strong>Examples</strong></p><p>====</p><p>A basic case with non-dimensional units:</p><pre><code class="language-julia hljs">julia&gt; Grid = create_CartGrid(size=(10,20),x=(0.,10), z=(2.,10))
Grid{Float64, 2}
           size: (10, 20)
         length: (10.0, 8.0)
         domain: x ∈ [0.0, 10.0], z ∈ [2.0, 10.0]
 grid spacing Δ: (1.1111111111111112, 0.42105263157894735)</code></pre><p>An example with dimensional units:</p><pre><code class="language-julia hljs">julia&gt; CharDim = GEO_units()
julia&gt; Grid    = create_CartGrid(size=(10,20),x=(0.0km, 10km), z=(-20km, 10km), CharDim=CharDim)
CartGrid{Float64, 2}
           size: (10, 20)
         length: (0.01, 0.03)
         domain: x ∈ [0.0, 0.01], z ∈ [-0.02, 0.01]
 grid spacing Δ: (0.0011111111111111111, 0.0015789473684210528)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L1109-L1149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.create_partitioning_file-Tuple{String, Int64}"><a class="docstring-binding" href="#GeophysicalModelGenerator.create_partitioning_file-Tuple{String, Int64}"><code>GeophysicalModelGenerator.create_partitioning_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_partitioning_file(LaMEM_input::String, NumProc::Int64; LaMEM_dir::String=pwd(), LaMEM_options::String=&quot;&quot;, MPI_dir=&quot;&quot;, verbose=true)</code></pre><p>This executes LaMEM for the input file <code>LaMEM_input</code> &amp; creates a parallel partitioning file for <code>NumProc</code> processors. The directory where the LaMEM binary is can be specified; if not it is assumed to be in the current directory. Likewise for the <code>mpiexec</code> directory (if not specified it is assumed to be available on the command line).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L986-L993">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.create_profile_volume!-Tuple{ProfileData, AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.create_profile_volume!-Tuple{ProfileData, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.create_profile_volume!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_profile_volume!(Profile::ProfileData, VolData::AbstractGeneralGrid; DimsVolCross::NTuple=(100,100), Depth_extent=nothing)</code></pre><p>Creates a cross-section through a volumetric 3D dataset <code>VolData</code> with the data supplied in <code>Profile</code>. <code>Depth_extent</code> can be the minimum &amp; maximum depth for vertical profiles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L264-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cross_section-Tuple{AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cross_section-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.cross_section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cross_section(DataSet::AbstractGeneralGrid; dims=(100,100), Interpolate=false, Depth_level=nothing, Lat_level=nothing, Lon_level=nothing, Start=nothing, End=nothing, Depth_extent=nothing, section_width=50km)</code></pre><p>Creates a cross-section through a <code>GeoData</code> object.</p><ul><li>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</li><li>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</li><li>Depending on the type of input data (volume, surface or point data), cross sections will be created in a different manner:</li></ul><ol><li>Volume data: data will be interpolated or directly extracted from the data set.</li><li>Surface data: surface data will be interpolated or directly extracted from the data set</li><li>Point data: data will be projected to the chosen profile. Only data within a chosen distance (default is 50 km) will be used</li></ol><ul><li><code>Interpolate</code> indicates whether we want to simply extract the data from the data set (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in <code>dims</code> NOTE: THIS ONLY APPLIES TO VOLUMETRIC AND SURFACE DATA SETS</li><li>&#39;section_width&#39; indicates the maximal distance within which point data will be projected to the profile</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)));
julia&gt; Data_cross      =   cross_section(Data_set3D, Depth_level=-100km)
GeoData
  size  : (11, 11, 1)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -100.0 km : -100.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L568-L598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cross_section_points-Tuple{GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cross_section_points-Tuple{GeoData}"><code>GeophysicalModelGenerator.cross_section_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function cross_section_points(P::GeoData; Depth_level=nothing, Lat_level=nothing, Lon_level=nothing, Start=nothing, End=nothing, section_width=50 )</code></pre><p>Creates a projection of separate points (saved as a GeoData object) onto a chosen plane. Only points with a maximum distance of section_width are taken into account</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L402-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cross_section_surface-Tuple{AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cross_section_surface-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.cross_section_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>cross<em>section</em>surface(Surface::GeoData; dims=(100,), Interpolate=false, Depth<em>level=nothing; Lat</em>level=nothing; Lon_level=nothing; Start=nothing, End=nothing )</p><p>Creates a cross-section through a surface (2D) <code>GeoData</code> object.</p><ul><li><p>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</p></li><li><p>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points. Start and End points will be in km!</p></li><li><p>IMPORTANT: The surface to be extracted has to be given as a gridded GeoData object. It may also contain NaNs where it is not defined. Any points lying outside of the defined surface will be considered NaN.</p></li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,-50km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set2D      =   GeoData(Lon,Lat,Depth,(Depth=Depth,));
julia&gt; Data_cross      =   cross_section_surface(Data_set2D, Lat_level =15)
GeoData
  size      : (100,)
  lon       ϵ [ 10.0 : 20.0]
  lat       ϵ [ 15.0 : 15.0]
  depth     ϵ [ NaN : NaN]
  fields    : (:Depth,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L292-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.cross_section_volume-Tuple{AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.cross_section_volume-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.cross_section_volume</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>cross<em>section</em>volume(Volume::AbstractGeneralGrid; dims=(100,100), Interpolate=false, Depth<em>level=nothing; Lat</em>level=nothing; Lon<em>level=nothing; Start=nothing, End=nothing, Depth</em>extent=nothing )</p><p>Creates a cross-section through a volumetric (3D) <code>GeoData</code> object.</p><ul><li>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</li><li>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</li><li>When both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> are given, one can also provide a the depth extent of the profile by providing Depth<em>extent=(depth</em>min,depth_max)</li><li><code>Interpolate</code> indicates whether we want to simply extract the data from the 3D volume (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in <code>dims</code></li><li><code>Depth_extent</code> is an optional parameter that can indicate the depth extent over which you want to interpolate the vertical cross-section. Default is the full vertical extent of the 3D dataset</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)));
julia&gt; Data_cross      =   cross_section_volume(Data_set3D, Depth_level=-100km)
GeoData
  size  : (11, 11, 1)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -100.0 km : -100.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L151-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.distance_to_linesegment-Union{Tuple{_T}, Tuple{Tuple{_T, _T}, Tuple{_T, _T}, Tuple{_T, _T}}} where _T&lt;:Number"><a class="docstring-binding" href="#GeophysicalModelGenerator.distance_to_linesegment-Union{Tuple{_T}, Tuple{Tuple{_T, _T}, Tuple{_T, _T}, Tuple{_T, _T}}} where _T&lt;:Number"><code>GeophysicalModelGenerator.distance_to_linesegment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance_to_linesegment(p::NTuple{2,_T}, v::NTuple{2,_T}, w::NTuple{2,_T})</code></pre><p>Computes the distance normal distance from a point <code>p</code> to a line segment defined by the points <code>v</code> and <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L2084-L2088">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.download_data"><a class="docstring-binding" href="#GeophysicalModelGenerator.download_data"><code>GeophysicalModelGenerator.download_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">download_data(url::String, local_filename=&quot;temp.dat&quot;; dir=pwd(), maxattempts=5 )</code></pre><p>Downloads a remote dataset with name <code>url</code> from a remote location and saves it to the current directory. If download fails, we make <code>maxattempts</code> attempts before giving up.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; url  = &quot;https://seafile.rlp.net/f/10f867e410bb4d95b3fe/?dl=1&quot;;
julia&gt; download_data(url)
&quot;/Users/kausb/.julia/dev/GeophysicalModelGenerator/temp.dat&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/IO.jl#L82-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.drape_on_topo-Tuple{CartData, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.drape_on_topo-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.drape_on_topo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drape_on_topo(Topo::CartData, Data::CartData)</code></pre><p>Drapes Cartesian Data on topography</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.drape_on_topo-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.drape_on_topo-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.drape_on_topo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Topo = drape_on_topo(Topo::GeoData, Data::GeoData)</code></pre><p>This drapes fields of a data set <code>Data</code> on the topography <code>Topo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L65-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.extract_ProfileData!"><a class="docstring-binding" href="#GeophysicalModelGenerator.extract_ProfileData!"><code>GeophysicalModelGenerator.extract_ProfileData!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_ProfileData!(Profile::ProfileData,VolData::GeoData, SurfData::NamedTuple, PointData::NamedTuple; DimsVolCross=(100,100),Depth_extent=nothing,DimsSurfCross=(100,),section_width=50, ScreenshotData=nothing)</code></pre><p>Extracts data along a vertical or horizontal profile</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L392-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.extract_ProfileData-Tuple{String, Int64, String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.extract_ProfileData-Tuple{String, Int64, String}"><code>GeophysicalModelGenerator.extract_ProfileData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_ProfileData(ProfileCoordFile::String,ProfileNumber::Int64,DataSetFile::String; DimsVolCross=(100,100),DepthVol=nothing,DimsSurfCross=(100,),WidthPointProfile=50km)</code></pre><p>This is a convenience function (mostly for backwards compatibility with the MATLAB GUI) that loads the data from file &amp; projects it onto a profile</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L438-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.extract_subvolume-Tuple{CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.extract_subvolume-Tuple{CartData}"><code>GeophysicalModelGenerator.extract_subvolume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_subvolume(V::CartData; Interpolate=false, X_level=nothing, Y_level=nothing, Z_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = extract_subvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>2D Example along a cross-section through 3D data:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X,Y,Z = xyz_grid(10:20,30:40,-300:25:0);
julia&gt; Data = Z.*2
julia&gt; Data_Int = Int64.(Data)
julia&gt; DataSet_Cart = CartData(X,Y,Z,(Data=Data,Data_Int=Data_Int, Velocity=(X,Y,Z)))

julia&gt; Data_cross = cross_section(DataSet_Cart, Start=(11.0,35), End=(19, 39.0))
CartData
    size    : (100, 100, 1)
    x       ϵ [ 11.0 : 19.0]
    y       ϵ [ 35.0 : 39.0]
    z       ϵ [ -300.0 : 0.0]
    fields  : (:Data, :Data_Int, :Velocity, :FlatCrossSection)
  attributes: [&quot;note&quot;]

julia&gt; Data_extracted = extract_subvolume(Data_cross, X_level=(1,7), Z_level=(-200,-100))
  CartData
      size    : (50, 50, 1)
      x       ϵ [ 11.894427190999917 : 17.260990336999413]
      y       ϵ [ 35.44721359549995 : 38.130495168499706]
      z       ϵ [ -200.0 : -100.0]
      fields  : (:FlatCrossSection, :Data, :Data_Int, :Velocity)
    attributes: [&quot;note&quot;]
julia&gt; typeof(Data_extracted.fields.Data_Int)
    Array{Int64, 3}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L770-L832">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.extract_subvolume-Tuple{GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.extract_subvolume-Tuple{GeoData}"><code>GeophysicalModelGenerator.extract_subvolume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_subvolume(V::GeoData; Interpolate=false, Lon_level=nothing, Lat_level=nothing, Depth_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = extract_subvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>3D Example with interpolation:</strong></p><p>Alternatively, you can also interpolate the data onto a new grid:</p><pre><code class="language-julia hljs">julia&gt; Data_extracted = extract_subvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40), Interpolate=true, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L684-L729">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.find_slab_distance!-Tuple{Any, Any, Any, Any, Any, Any, Any, Trench}"><a class="docstring-binding" href="#GeophysicalModelGenerator.find_slab_distance!-Tuple{Any, Any, Any, Any, Any, Any, Any, Trench}"><code>GeophysicalModelGenerator.find_slab_distance!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_slab_distance!(ls, d, X,Y,Z, trench::Trench)</code></pre><p>Function that finds the perpendicular distance to the top and bottom of the slab <code>d</code>, and the current length of the slab <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L2016-L2021">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.fit_surface_to_points-Tuple{CartData, Vector, Vector, Vector}"><a class="docstring-binding" href="#GeophysicalModelGenerator.fit_surface_to_points-Tuple{CartData, Vector, Vector, Vector}"><code>GeophysicalModelGenerator.fit_surface_to_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">surf_new = fit_surface_to_points(surf::CartData, lon_pt::Vector, lat_pt::Vector, depth_pt::Vector)</code></pre><p>This fits the <code>depth</code> values of the surface <code>surf</code> to the <code>depth</code> value of the closest-by-points in (<code>lon_pt</code>,<code>lat_pt</code>, <code>depth_pt</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L173-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.fit_surface_to_points-Tuple{GeoData, Vector, Vector, Vector}"><a class="docstring-binding" href="#GeophysicalModelGenerator.fit_surface_to_points-Tuple{GeoData, Vector, Vector, Vector}"><code>GeophysicalModelGenerator.fit_surface_to_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">surf_new = fit_surface_to_points(surf::GeoData, lon_pt::Vector, lat_pt::Vector, depth_pt::Vector)</code></pre><p>This fits the <code>depth</code> values of the surface <code>surf</code> to the <code>depth</code> value of the closest-by-points in (<code>lon_pt</code>,<code>lat_pt</code>, <code>depth_pt</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L154-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.flatten_cross_section-Tuple{CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.flatten_cross_section-Tuple{CartData}"><code>GeophysicalModelGenerator.flatten_cross_section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flatten_cross_section(V::CartData)</code></pre><p>Takes a diagonal 3D cross<em>section and flattens it to be converted to a 2D Grid by create</em>CartGrid</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Grid                    = create_CartGrid(size=(100,100,100), x=(0.0km, 99.9km), y=(-10.0km, 20.0km), z=(-40km,4km));
X,Y,Z                   = xyz_grid(Grid.coord1D...);
DataSet                 = CartData(X,Y,Z,(Depthdata=Z,));

Data_Cross              = cross_section(DataSet, dims=(100,100), Interpolate=true, Start=(ustrip(Grid.min[1]),ustrip(Grid.max[2])), End=(ustrip(Grid.max[1]), ustrip(Grid.min[2])))

x_new = flatten_cross_section(Data_Cross)

# This flattened cross_section can be added to original Data_Cross by addfield()

Data_Cross = addfield(Data_Cross,&quot;FlatCrossSection&quot;, x_new)
CartData
    size    : (100, 100, 1)
    x       ϵ [ 0.0 : 99.9]
    y       ϵ [ -10.0 : 20.0]
    z       ϵ [ -40.0 : 4.0]
    fields  : (:Depthdata, :FlatCrossSection)
  attributes: [&quot;note&quot;]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L617-L642">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.flatten_cross_section-Tuple{GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.flatten_cross_section-Tuple{GeoData}"><code>GeophysicalModelGenerator.flatten_cross_section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flatten_cross_section(V::GeoData)
This function takes a 3D cross section through a GeoData structure and computes the distance along the cross section for later 2D processing/plotting
```julia-repl
julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)));
julia&gt; Data_cross      =   cross_section(Data_set3D, Start=(10,30),End=(20,40))
julia&gt; x_profile        =   flatten_cross_section(Data_cross)
julia&gt; Data_cross      =   addfield(Data_cross,&quot;x_profile&quot;,x_profile)

```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L654-L667">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.flatten_index_dimensions-Tuple{Any, Vector{CartesianIndex{3}}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.flatten_index_dimensions-Tuple{Any, Vector{CartesianIndex{3}}}"><code>GeophysicalModelGenerator.flatten_index_dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ind2D = flatten_index_dimensions(Phase, ind_vec::Vector{CartesianIndex{3}})</code></pre><p>This converts the indices to purely 2D indices if the array <code>phase</code> is 2D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.flatten_index_dimensions-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Array{Bool, 3}}} where {T, N}"><a class="docstring-binding" href="#GeophysicalModelGenerator.flatten_index_dimensions-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Array{Bool, 3}}} where {T, N}"><code>GeophysicalModelGenerator.flatten_index_dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ind2D = flatten_index_dimensions(Phase, ind_vec::Vector{CartesianIndex{3}})</code></pre><p>This converts the indices to purely 2D indices if the array <code>phase</code> is 2D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.flip"><a class="docstring-binding" href="#GeophysicalModelGenerator.flip"><code>GeophysicalModelGenerator.flip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Data = flip(Data::GeoData, dimension=3)</code></pre><p>This flips the data in the structure in a certain dimension (default is z [3])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L594-L598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.get_processor_partitioning-Tuple{Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.get_processor_partitioning-Tuple{Any}"><code>GeophysicalModelGenerator.get_processor_partitioning</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nProcX,nProcY,nProcZ, xc,yc,zc, nNodeX,nNodeY,nNodeZ = get_processor_partitioning(filename; is64bit=false)</code></pre><p>Reads a LaMEM processor partitioning file, used to create marker files, and returns the parallel layout. By default this is done for a 32bit PETSc installation, which will fail if you actually use a 64bit version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L567-L573">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.getlonlatdepthmag_QuakeML-Tuple{String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.getlonlatdepthmag_QuakeML-Tuple{String}"><code>GeophysicalModelGenerator.getlonlatdepthmag_QuakeML</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data = getlonlatdepthmag_QuakeML(filename::String)</code></pre><p>Extracts longitude, latitude, depth and magnitude from a QuakeML file that has been e.g. downloaded from ISC. The data is then returned in GeoData format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_import.jl#L316-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.inpoly-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, T}} where T&lt;:Real"><a class="docstring-binding" href="#GeophysicalModelGenerator.inpoly-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, T}} where T&lt;:Real"><code>GeophysicalModelGenerator.inpoly</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inpoly(PolyX::Vector, PolyY::Vector, x::Number, y::Number, iSteps::Vector, jSteps::)</code></pre><p>Checks if a point given by x and y is in or on (both cases return true) a polygon given by PolyX and PolyY, iSteps and jSteps provide the connectivity between the polygon edges. This function should be used through inpolygon!().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1804-L1809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.inpoly_fast-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, T}} where T&lt;:Real"><a class="docstring-binding" href="#GeophysicalModelGenerator.inpoly_fast-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, T}} where T&lt;:Real"><code>GeophysicalModelGenerator.inpoly_fast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inpoly_fast(PolyX::Vector, PolyY::Vector, x::Number, y::Number, iSteps::Vector, jSteps::)</code></pre><p>Faster version of inpoly() but will miss some points that are on the edge of the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1843-L1848">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.inpolygon!-Union{Tuple{T}, Tuple{Matrix{Bool}, Vector{T}, Vector{T}, Matrix{T}, Matrix{T}}} where T&lt;:Real"><a class="docstring-binding" href="#GeophysicalModelGenerator.inpolygon!-Union{Tuple{T}, Tuple{Matrix{Bool}, Vector{T}, Vector{T}, Matrix{T}, Matrix{T}}} where T&lt;:Real"><code>GeophysicalModelGenerator.inpolygon!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inpolygon!(INSIDE::Matrix, PolyX::Vector, PolyY::Vector, X::Matrix, Y::Matrix; fast=false)</code></pre><p>Checks if points given by matrices <code>X</code> and <code>Y</code> are in or on (both cases return true) a polygon given by <code>PolyX</code> and <code>PolyY</code>. Boolean <code>fast</code> will trigger faster version that may miss points that are exactly on the edge of the polygon. Speedup is a factor of 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1764-L1769">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.inpolygon!-Union{Tuple{T}, Tuple{Vector{Bool}, AbstractVector{T}, AbstractVector{T}, Vector{T}, Vector{T}}} where T&lt;:Real"><a class="docstring-binding" href="#GeophysicalModelGenerator.inpolygon!-Union{Tuple{T}, Tuple{Vector{Bool}, AbstractVector{T}, AbstractVector{T}, Vector{T}, Vector{T}}} where T&lt;:Real"><code>GeophysicalModelGenerator.inpolygon!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inpolygon!(inside::Vector, PolyX::Vector, PolyY::Vector, x::Vector, y::Vector; fast=false)</code></pre><p>Same as above but <code>inside</code>, <code>X</code> and <code>Y</code> and are vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1786-L1791">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_data_fields_cross_section-Tuple{CartData, Vararg{Any, 4}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_data_fields_cross_section-Tuple{CartData, Vararg{Any, 4}}"><code>GeophysicalModelGenerator.interpolate_data_fields_cross_section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_data_fields_cross_section(V::CartData, X,Y,Z,Xcross)</code></pre><p>Interpolates data fields along a cross-section defined by <code>Xcross</code> and <code>Z</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L915-L919">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_data_surface-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_data_surface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.interpolate_data_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Surf_interp = interpolate_data_surface(V::GeoData, Surf::GeoData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L397-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_data_surface-Tuple{ParaviewData, ParaviewData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_data_surface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.interpolate_data_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Surf_interp = interpolate_data_surface(V::ParaviewData, Surf::ParaviewData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Data
ParaviewData
  size  : (33, 33, 33)
  x     ϵ [ -3.0 : 3.0]
  y     ϵ [ -2.0 : 2.0]
  z     ϵ [ -2.0 : 0.0]
  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)
julia&gt; surf
ParaviewData
  size  : (96, 96, 1)
  x     ϵ [ -2.9671875 : 3.2671875]
  y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
  z     ϵ [ -1.5353766679763794 : -0.69925457239151]
  fields: (:Depth,)
julia&gt; Surf_interp = interpolate_data_surface(Data, surf)
  ParaviewData
    size  : (96, 96, 1)
    x     ϵ [ -2.9671875 : 3.2671875]
    y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
    z     ϵ [ -1.5353766679763794 : -0.69925457239151]
    fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L336-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields-Tuple{AbstractGeneralGrid, Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields-Tuple{AbstractGeneralGrid, Any, Any, Any}"><code>GeophysicalModelGenerator.interpolate_datafields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data_interp = interpolate_datafields(V::AbstractGeneralGrid, Lon, Lat, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>Lon,Lat,Depth</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x        =   0:2:10
julia&gt; y        =   -5:5
julia&gt; z        =   -10:2:2
julia&gt; X,Y,Z    =   xyz_grid(x, y, z);
julia&gt; Data     =   Z
julia&gt; Data_set1=   CartData(X,Y,Z, (FakeData=Data,Data2=Data.+1.))
CartData
    size    : (6, 11, 7)
    x       ϵ [ 0.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ -10.0 km : 2.0 km]
    fields  : (:FakeData, :Data2)
  attributes: [&quot;note&quot;]

julia&gt; X,Y,Z    =   xyz_grid(0:4:10, -1:.1:1, -5:.1:1 );
julia&gt; Data_set2= interpolate_datafields(Data_set1, X,Y,Z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L998-L1023">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields-Tuple{UTMData, Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields-Tuple{UTMData, Any, Any, Any}"><code>GeophysicalModelGenerator.interpolate_datafields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields(V::UTMData, EW, NS, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>UTM,Depth</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1090-L1094">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{CartData, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{CartData, Any, Any}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields_2D(V::CartData, X, Y)</code></pre><p>Interpolates a data field <code>V</code> on a 2D CartData grid defined by <code>X</code>,<code>Y</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1226-L1230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{CartData, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields_2D(Original::CartData, New::CartData; Rotate=0.0, Translate=(0,0,0), Scale=(1.0,1.0,1.0))</code></pre><p>Interpolates a data field <code>Original</code> on a 2D CartData grid <code>New</code>. Typically used for horizontal surfaces.</p><p>Note: <code>Original</code> should have orthogonal coordinates. If it has not, e.g., because it was rotated, you&#39;ll have to specify the angle <code>Rotate</code> that it was rotated by</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1237-L1245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, AbstractRange, AbstractRange}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, AbstractRange, AbstractRange}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Surf_interp = interpolate_datafields_2D(V::GeoData, x::AbstractRange, y::AbstractRange;  Lat::Number, Lon::Number)</code></pre><p>Interpolates a 3D data set <code>V</code> with a projection point <code>proj=(Lat, Lon)</code> on a plane defined by <code>x</code> and <code>y</code>, where <code>x</code> and <code>y</code> are uniformly spaced. Returns the 2D array <code>Surf_interp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1293-L1298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, Any, Any}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields_2D(V::GeoData, Lon, Lat)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>Lon,Lat</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1150-L1154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields_2D(Original::GeoData, New::GeoData; Rotate=0.0, Translate=(0,0,0), Scale=(1.0,1.0,1.0))</code></pre><p>Interpolates a data field <code>Original</code> on a 2D GeoData grid <code>New</code>. Typically used for horizontal surfaces.</p><p>Note: <code>Original</code> should have orthogonal coordinates. If it has not, e.g., because it was rotated, you&#39;ll have to specify the angle <code>Rotate</code> that it was rotated by</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1265-L1273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{UTMData, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.interpolate_datafields_2D-Tuple{UTMData, Any, Any}"><code>GeophysicalModelGenerator.interpolate_datafields_2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_datafields_2D(V::UTMData, EW, NS)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>UTM</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1215-L1219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.is_surface-Tuple{AbstractGeneralGrid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.is_surface-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.is_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">issurf = is_surface(surf::AbstractGeneralGrid)</code></pre><p>Returns true if <code>surf</code> is a horizontal 3D surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.isinside_closed_STL"><a class="docstring-binding" href="#GeophysicalModelGenerator.isinside_closed_STL"><code>GeophysicalModelGenerator.isinside_closed_STL</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inside = isinside_closed_STL(mesh::Mesh, Pt, eps=1e-3)</code></pre><p>Determine whether a point <code>Pt</code> is inside a 3D closed triangular <code>*.stl</code> surface or not.</p><p>This implements the winding number method, following the python code: https://github.com/marmakoide/inside-3d-mesh</p><p>This again is described in the following <a href="https://igl.ethz.ch/projects/winding-number/">paper</a> by Alec Jacobson, Ladislav Kavan and Olga Sorkine-Hornung.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/stl.jl#L168-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.lithostatic_pressure!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}, Number}} where {T, N}"><a class="docstring-binding" href="#GeophysicalModelGenerator.lithostatic_pressure!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}, Number}} where {T, N}"><code>GeophysicalModelGenerator.lithostatic_pressure!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lithostatic_pressure!(Plithos::Array, Density::Array, dz::Number; g=9.81)</code></pre><p>Computes lithostatic pressure from a 3D density array, assuming constant soacing <code>dz</code> in vertical direction. Optionally, the gravitational acceleration <code>g</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1747-L1752">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.load_GMG"><a class="docstring-binding" href="#GeophysicalModelGenerator.load_GMG"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_GMG(filename::String, dir=pwd(); maxattempts=5)</code></pre><p>Loads a <code>GeoData</code>/<code>CartData</code>/<code>UTMData</code> data set from jld2 file <code>filename</code> Note: the <code>filename</code> can also be a remote <code>url</code>, in which case we first download that file to a temporary directory before opening it. We make <code>maxattempts</code> attempts to download it before giving up.</p><p><strong>Example 1 - Load local file</strong></p><pre><code class="language-julia hljs">julia&gt; data = load_GMG(&quot;test&quot;)
GeoData 
  size      : (4, 3, 3)
  lon       ϵ [ 1.0 : 10.0]
  lat       ϵ [ 11.0 : 19.0]
  depth     ϵ [ -20.0 : -10.0]
  fields    : (:DataFieldName,)
  attributes: [&quot;note&quot;]</code></pre><p><strong>Example 2 - remote download</strong></p><pre><code class="language-julia hljs">julia&gt; url  = &quot;https://seafile.rlp.net/f/10f867e410bb4d95b3fe/?dl=1&quot;
julia&gt; load_GMG(url)
GeoData 
  size      : (149, 242, 1)
  lon       ϵ [ -24.875 : 35.375]
  lat       ϵ [ 34.375 : 71.375]
  depth     ϵ [ -11.76 : -34.7]
  fields    : (:MohoDepth,)
  attributes: [&quot;author&quot;, &quot;year&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/IO.jl#L25-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.load_GMG-Tuple{GMG_Dataset}"><a class="docstring-binding" href="#GeophysicalModelGenerator.load_GMG-Tuple{GMG_Dataset}"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data::NamedTuple = load_GMG(data::GMG_Dataset)</code></pre><p>Loads a dataset specified in GMG_Dataset <code>data</code> and returns it as a named tuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L126-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.load_GMG-Tuple{Vector{GMG_Dataset}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.load_GMG-Tuple{Vector{GMG_Dataset}}"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data = load_GMG(Datasets::Vector{GMG_Dataset})</code></pre><p>This loads all the active datasets in <code>Datasets</code>, and returns a NamedTuple with Volume, Surface, Point, Screenshot and Topography data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L176-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.load_dataset_file-Tuple{String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.load_dataset_file-Tuple{String}"><code>GeophysicalModelGenerator.load_dataset_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Datasets = load_dataset_file(file_datasets::String)</code></pre><p>This loads a CSV textfile that lists datasets, which is expected to have the following format:</p><ul><li><code>Name</code>,<code>Location</code>,<code>Type</code>, <code>[Active]</code></li><li>AlpArray,./Seismicity/ALPARRAY/AlpArraySeis.jld2,Point, true</li><li>Plomerova2022,https://seafile.rlp.net/f/abccb8d3302b4ef5af17/?dl=1,Volume</li></ul><p>Note that the first line of the file is skipped.</p><p>Here, the meaning of the variables is:</p><ul><li><code>Name</code>: The name of the dataset to be loaded</li><li><code>Location</code>: the location of the file (directory and filename) on your local machine, or an url where we can download the file from the web. The url is expected to start with &quot;http&quot;.</li><li><code>Type</code>: type of the dataset (Volume, Surface, Point, Screenshot)</li><li><code>Active</code>: Do we want this file to be loaded or not? Optional parameter that defaults to <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L137-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.lonlatdepth_grid-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.lonlatdepth_grid-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.lonlatdepth_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Lon, Lat, Depth = lonlatdepth_grid(Lon::Any, Lat::Any, Depth:Any)</code></pre><p>Creates 3D arrays of <code>Lon</code>, <code>Lat</code>, <code>Depth</code> from 1D vectors or numbers</p><p><strong>Example 1: Create 3D grid</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  lonlatdepth_grid(10:20,30:40,(-10:-1)km);
julia&gt; size(Lon)
(11, 11, 10)</code></pre><p><strong>Example 2: Create 2D lon/lat grid @ a given depth</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  lonlatdepth_grid(10:20,30:40,-50km);
julia&gt; size(Lon)
(11, 11)</code></pre><p><strong>Example 3: Create 2D lon/depth grid @ a given lat</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  lonlatdepth_grid(10:20,30,(-10:-1)km);
julia&gt; size(Lon)
(11, 11)</code></pre><p><strong>Example 4: Create 1D vertical line @ a given lon/lat point</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  lonlatdepth_grid(10,30,(-10:-1)km);
julia&gt; size(Lon)
(10, )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L871-L903">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.make_paraview_collection-Tuple{}"><a class="docstring-binding" href="#GeophysicalModelGenerator.make_paraview_collection-Tuple{}"><code>GeophysicalModelGenerator.make_paraview_collection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_paraview_collection(; dir=pwd(), pvd_name=nothing, files=nothing, file_extension = &quot;.vts&quot;, time = nothing)</code></pre><p>In case one has a list of <code>*.vtk</code> files, this routine creates a <code>*.pvd</code> file that can be opened in Paraview. This is useful if you previously saved vtk files but didnt save it as a collection in the code itself.</p><p><strong>Optional options</strong></p><ul><li><code>dir</code>:    directory where the <code>*.vtk</code> are stored.</li><li><code>pvd_name</code>:  filename of the resulting <code>*.pvd</code> file without extension; if not specified, <code>full_simulation</code> is used.</li><li><code>files</code>:  Vector of the <code>*.vtk</code> files without extension; if not specified, all <code>*.vtk</code> files in the directory are used.</li><li><code>file_extension</code>:  file extension of the vtk files. Default is <code>.vts</code> but all <code>vt*</code> work.</li><li><code>time</code>:  Vector of the timesteps; if not specified, pseudo time steps are assigned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_collection.jl#L6-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.make_volc_topo-Tuple{LaMEM_grid}"><a class="docstring-binding" href="#GeophysicalModelGenerator.make_volc_topo-Tuple{LaMEM_grid}"><code>GeophysicalModelGenerator.make_volc_topo</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>make<em>volc</em>topo(Grid::LaMEM_grid; center::Array{Float64, 1}, height::Float64, radius::Float64, crater::Float64,             base=0.0m, background=nothing)</p><p>Creates a generic volcano topography (cones and truncated cones)</p><p><strong>Parameters</strong></p><ul><li>Grid - LaMEM grid (created by read<em>LaMEM</em>inputfile)</li><li>center - x- and -coordinates of center of volcano</li><li>height - height of volcano</li><li>radius - radius of volcano</li></ul><p><strong>Optional Parameters</strong></p><ul><li>crater - this will create a truncated cone and the option defines the radius of the flat top</li><li>base - this sets the flat topography around the volcano</li><li>background - this allows loading in a topography and only adding the volcano on top (also allows stacking of several cones to get a volcano with different slopes)</li></ul><p><strong>Example</strong></p><p>Cylinder with constant phase and temperature:</p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Topo = make_volc_topo(Grid, center=[0.0,0.0], height=0.4, radius=1.5, crater=0.5, base=0.1)
CartData
    size    : (33, 33, 1)
    x       ϵ [ -3.0 : 3.0]
    y       ϵ [ -2.0 : 2.0]
    z       ϵ [ 0.1 : 0.4]
    fields  : (:Topography,)
  attributes: [&quot;note&quot;]
julia&gt; Topo = make_volc_topo(Grid, center=[0.0,0.0], height=0.8, radius=0.5, crater=0.0, base=0.4, background=Topo.fields.Topography)
CartData
    size    : (33, 33, 1)
    x       ϵ [ -3.0 : 3.0]
    y       ϵ [ -2.0 : 2.0]
    z       ϵ [ 0.1 : 0.8]
    fields  : (:Topography,)
  attributes: [&quot;note&quot;]
julia&gt; write_paraview(Topo,&quot;VolcanoTopo&quot;)           # Save topography to paraview
Saved file: VolcanoTopo.vts</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Setup_geometry.jl#L963-L1016">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.meshgrid-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeophysicalModelGenerator.meshgrid-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeophysicalModelGenerator.meshgrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">meshgrid(vx,vy,vz)</code></pre><p>Computes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.movie_from_images-Tuple{}"><a class="docstring-binding" href="#GeophysicalModelGenerator.movie_from_images-Tuple{}"><code>GeophysicalModelGenerator.movie_from_images</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">movie_from_images(; dir=pwd(), file=nothing, outfile=nothing, framerate=10, copy_to_current_dir=true, type=:mp4_default, collect=true)</code></pre><p>The typical way to create animations with <code>Paraview</code> is to use the <code>Save Animation</code> option to save a series of <code>*.png</code> images.</p><p>This function combines these images to an <code>*.mp4</code> movie.</p><p><strong>Optional options</strong></p><ul><li><code>dir</code>:    directory where the images are stored.</li><li><code>file</code>:   filename of the image series without extension and numbers. Required if &gt;1 image series is stored in the same directory. By default we reconstruct this name from the available files.</li><li><code>outfile</code>:  filename of the resulting movie without extension; if not specified, <code>file</code> is used.</li><li><code>framerate</code>: number of frames/second.</li><li><code>copy_to_current_dir</code>: copies the final movie to the current directory if <code>true</code> (default); otherwise it will be stored in <code>dir</code>.</li><li><code>type</code>: type of movie that is created; possible options are:<ul><li><code>:mp4_default</code>: Default option that saves a well-compressed <code>mp4</code> movie that works well for us on ipad and embedded in a powerpoint presentation.</li><li><code>:mov_hires</code>: Higher-resolution quicktime movie (larger filesize &amp; not compatible with windows)</li></ul></li><li><code>collect</code>: suppresses output of <code>FFMPEG</code> if <code>true</code> (default).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/movies_from_pics.jl#L11-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.movie_paraview-Tuple{}"><a class="docstring-binding" href="#GeophysicalModelGenerator.movie_paraview-Tuple{}"><code>GeophysicalModelGenerator.movie_paraview</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pvd = movie_paraview(; name=&quot;Movie&quot;, pvd=pvd, Finalize::Bool=false, Initialize::Bool=true)</code></pre><p>If you want to make a movie of your data set, you can use this routine to initialize and to finalize the movie-file. It will create a <code>*.pvd</code> file, which you can open in Paraview </p><p>Individual timesteps are added to the movie by passing <code>pvd</code> and the time of the timestep to the <code>write_paraview</code> routine.</p><p><strong>Example</strong></p><p>Usually this is used inside a <code>*.jl</code> script, as in this pseudo-example:</p><pre><code class="language-julia hljs">movie = movie_paraview(name=&quot;Movie&quot;, Initialize=true)
for itime=1:10
    name = &quot;test&quot;*string(itime)
    movie = write_paraview(Data, name, pvd=movie, time=itime)
end
movie_paraview(pvd=movie, Finalize=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L161-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Array, Array, Vector, Vector, Vector}"><a class="docstring-binding" href="#GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Array, Array, Vector, Vector, Vector}"><code>GeophysicalModelGenerator.nearest_point_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ind = nearest_point_indices(X::Array,Y::Array,Z::Array, X_pt::Vector,Y_pt::Vector,Z_pt::Vector)</code></pre><p>Returns the index of the nearest point in (<code>X_pt</code>,<code>Y_pt</code>,<code>Z_pt</code>) to (<code>X</code>,<code>Y</code>,<code>Z</code>) and returns the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/nearest_points.jl#L50-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Array, Vector, Vector}"><a class="docstring-binding" href="#GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Array, Vector, Vector}"><code>GeophysicalModelGenerator.nearest_point_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ind = nearest_point_indices(X::Array,Y::Array, X_pt::Vector, Y_pt::Vector)</code></pre><p>Returns the index of the nearest point in (<code>X_pt</code>,<code>Y_pt</code>) to (<code>X</code>,<code>Y</code>) and returns the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/nearest_points.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Vector}"><a class="docstring-binding" href="#GeophysicalModelGenerator.nearest_point_indices-Tuple{Array, Vector}"><code>GeophysicalModelGenerator.nearest_point_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ind = nearest_point_indices(X::Array, X_pt::Vector)</code></pre><p>Returns the index of the nearest point in (<code>X_pt</code>) to (<code>X</code>) and returns the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/nearest_points.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.parse_columns_CSV-Tuple{Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.parse_columns_CSV-Tuple{Any, Any}"><code>GeophysicalModelGenerator.parse_columns_CSV</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_columns_CSV(data_file, num_columns)</code></pre><p>This parses numbers from CSV file that is read in with <code>CSV.File</code>. That is useful in case the CSV files has tables that contain both strings (e.g., station names) and numbers (lat/lon/height) and you are only interested in the numbers</p><p><strong>Example</strong></p><p>This example assumes that the data starts at line 18, that the columns are separated by spaces, and that it contains at most 4 columns with data:</p><pre><code class="language-julia-repl hljs">julia&gt; using CSV
julia&gt; data_file        =   CSV.File(&quot;FileName.txt&quot;,datarow=18,header=false,delim=&#39; &#39;)
julia&gt; data = parse_columns_CSV(data_file, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1513-L1528">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_in_tetrahedron-Union{Tuple{_T}, NTuple{5, _T}, Tuple{_T, _T, _T, _T, _T, Any}} where _T&lt;:Vector{Float64}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_in_tetrahedron-Union{Tuple{_T}, NTuple{5, _T}, Tuple{_T, _T, _T, _T, _T, Any}} where _T&lt;:Vector{Float64}"><code>GeophysicalModelGenerator.point_in_tetrahedron</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inside = point_in_tetrahedron(p::_T, a::_T, b::_T, c::_T, d::_T, tol=1e-10)</code></pre><p>Determines if a point <code>p</code> is inside a tetrahedron specified by <code>a</code>,<code>b</code>,<code>c</code>,<code>d</code> or not    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/transformation.jl#L106-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_to_nearest_grid-NTuple{6, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_to_nearest_grid-NTuple{6, Any}"><code>GeophysicalModelGenerator.point_to_nearest_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">count = point_to_nearest_grid(pt_x,pt_y,pt_z, X,Y,Z; radius_factor=1)</code></pre><p>This uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D grid point specified by <code>X</code>,<code>Y</code>,<code>Z</code> 3D coordinate arrays, with regular spacing <code>(Δx,Δy,Δz)</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L85-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_to_nearest_grid-Tuple{Any, Any, Any, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_to_nearest_grid-Tuple{Any, Any, Any, CartData}"><code>GeophysicalModelGenerator.point_to_nearest_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid_counts = point_to_nearest_grid(pt_x,pt_y,pt_z, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>CartGrid</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L28-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_to_nearest_grid-Tuple{Any, Any, Any, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_to_nearest_grid-Tuple{Any, Any, Any, GeoData}"><code>GeophysicalModelGenerator.point_to_nearest_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid_counts = point_to_nearest_grid(pt_x,pt_y,pt_z, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>GeoData</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L68-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_to_nearest_grid-Tuple{CartData, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_to_nearest_grid-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.point_to_nearest_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid_counts = point_to_nearest_grid(Point::CartData, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L6-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.point_to_nearest_grid-Tuple{GeoData, GeoData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.point_to_nearest_grid-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.point_to_nearest_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid_counts = point_to_nearest_grid(Point::GeoData, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/event_counts.jl#L46-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.project_CartData-Tuple{CartData, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.project_CartData-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.project_CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_cart = project_CartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/transformation.jl#L48-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.project_CartData-Tuple{CartData, GeoData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.project_CartData-Tuple{CartData, GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.project_CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_cart = project_CartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/transformation.jl#L8-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.project_CartData-Tuple{CartData, UTMData, ProjectionPoint}"><a class="docstring-binding" href="#GeophysicalModelGenerator.project_CartData-Tuple{CartData, UTMData, ProjectionPoint}"><code>GeophysicalModelGenerator.project_CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_cart = project_CartData(d_cart::CartData, d::UTMData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the UTMData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>.     <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><pre><code class="nohighlight hljs"># Note:    
- If `d_cart` and `d` are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/transformation.jl#L76-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.project_FEData_CartData-Tuple{CartData, FEData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.project_FEData_CartData-Tuple{CartData, FEData}"><code>GeophysicalModelGenerator.project_FEData_CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data_cart = project_FEData_CartData(data_cart::CartData, data_fe::FEData)</code></pre><p>Projects a FEData object with tetrahedrons (e.g., from Gmsh) to a Cartesian grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/transformation.jl#L149-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.read_ASAGI-Tuple{String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.read_ASAGI-Tuple{String}"><code>GeophysicalModelGenerator.read_ASAGI</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data::CartData = read_ASAGI(fname_asagi::String)</code></pre><p>This reads a 3D ASAGI NetCDF file, which is used as input for a number of codes such as SeisSol. It returns a CartData dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/IO_ASAGI.jl#L119-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.read_LaMEM_inputfile-Tuple{Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.read_LaMEM_inputfile-Tuple{Any}"><code>GeophysicalModelGenerator.read_LaMEM_inputfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Grid::LaMEM_grid = read_LaMEM_inputfile(file, args::Union{String,Nothing}=nothing)</code></pre><p>Parses a LaMEM input file and stores grid information in the <code>Grid</code> structure. Optionally, you can pass LaMEM command-line arguments as well.</p><p><strong>Example 1</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;SaltModels.dat&quot;)
LaMEM Grid:
nel         : (32, 32, 32)
marker/cell : (3, 3, 3)
markers     : (96, 96, 96)
x           ϵ [-3.0 : 3.0]
y           ϵ [-2.0 : 2.0]
z           ϵ [-2.0 : 0.0]</code></pre><p><strong>Example 2 (with command-line arguments)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Grid = read_LaMEM_inputfile(&quot;SaltModels.dat&quot;, args=&quot;-nel_x 64 -coord_x -4,4&quot;)
LaMEM Grid:
  nel         : (64, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (192, 96, 96)
  x           ϵ [-4.0 : 4.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L169-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.read_data_PVTR-Tuple{Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.read_data_PVTR-Tuple{Any, Any}"><code>GeophysicalModelGenerator.read_data_PVTR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data::ParaviewData = read_data_PVTR(fname, dir)</code></pre><p>Reads a parallel, rectilinear, <code>*.vts</code> file with the name <code>fname</code> and located in <code>dir</code> and create a 3D <code>Data</code> struct from it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Data = read_data_PVTR(&quot;Haaksbergen.pvtr&quot;, &quot;./Timestep_00000005_3.35780500e-01/&quot;)
ParaviewData
  size  : (33, 33, 33)
  x     ϵ [ -3.0 : 3.0]
  y     ϵ [ -2.0 : 2.0]
  z     ϵ [ -2.0 : 0.0]
  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L829-L844">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.read_data_VTR-Tuple{Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.read_data_VTR-Tuple{Any, Any}"><code>GeophysicalModelGenerator.read_data_VTR</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coord, Data_3D_Arrays, Name_Vec = read_data_VTR(fname)</code></pre><p>Reads a VTR (structured grid) VTK file <code>fname</code> and extracts the coordinates, data arrays and names of the data. In general, this only contains a piece of the data, and one should open a <code>*.pvtr</code> file to retrieve the full data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L614-L619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.read_picked_profiles-Tuple{String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.read_picked_profiles-Tuple{String}"><code>GeophysicalModelGenerator.read_picked_profiles</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>This reads the picked profiles from disk and returns a vector of ProfileData</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/ProfileProcessing.jl#L419-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.remove_NaN_surface!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.remove_NaN_surface!-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.remove_NaN_surface!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_NaN_surface!(Z::Array,X::Array,Y::Array)</code></pre><p>Removes NaN&#39;s from a grid <code>Z</code> by taking the closest points as specified by <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/surface_functions.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.removefield-Tuple{AbstractGeneralGrid, String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.removefield-Tuple{AbstractGeneralGrid, String}"><code>GeophysicalModelGenerator.removefield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = removefield(V::AbstractGeneralGrid,field_name::String)</code></pre><p>Removes the field with name <code>field_name</code> from the GeoData or CartData dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L125-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.removefield-Tuple{AbstractGeneralGrid, Symbol}"><a class="docstring-binding" href="#GeophysicalModelGenerator.removefield-Tuple{AbstractGeneralGrid, Symbol}"><code>GeophysicalModelGenerator.removefield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = removefield(V::AbstractGeneralGrid,field_name::Symbol)</code></pre><p>Removes the field with name <code>field_name</code> from the GeoData or CartData dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L104-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.removefield-Union{Tuple{N}, Tuple{AbstractGeneralGrid, Tuple{Vararg{Symbol, N}}}} where N"><a class="docstring-binding" href="#GeophysicalModelGenerator.removefield-Union{Tuple{N}, Tuple{AbstractGeneralGrid, Tuple{Vararg{Symbol, N}}}} where N"><code>GeophysicalModelGenerator.removefield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V = removefield(V::AbstractGeneralGrid,field_name::NTuple{N,Symbol})</code></pre><p>Removes the fields in the tuple <code>field_name</code> from the GeoData or CartData dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L135-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.rotate_translate_scale-Tuple{Union{CartData, ParaviewData}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.rotate_translate_scale-Tuple{Union{CartData, ParaviewData}}"><code>GeophysicalModelGenerator.rotate_translate_scale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data_R = rotate_translate_scale(Data::Union{ParaviewData, CartData}; Rotate=0, Translate=(0,0,0), Scale=(1.0,1.0,1.0), Xc=(0.0,0.0))</code></pre><p>Does an in-place rotation, translation and scaling of the Cartesian dataset <code>Data</code>.</p><p><strong>Parameters</strong></p><p>Note that we apply the transformations in exactly this order:</p><ul><li><code>Scale</code>:        scaling applied to the <code>x,y,z</code> coordinates of the data set</li><li><code>Rotate</code>:       rotation around the <code>x/y</code> axis (around the center of the box)</li><li><code>Translate</code>:    translation</li><li><code>Xc</code>:           center of rotation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; X,Y,Z   =   xyz_grid(10:20,30:40,-50:-10);
julia&gt; Data_C  =   ParaviewData(X,Y,Z,(Depth=Z,))
ParaviewData
  size  : (11, 11, 41)
  x     ϵ [ 10.0 : 20.0]
  y     ϵ [ 30.0 : 40.0]
  z     ϵ [ -50.0 : -10.0]
  fields: (:Depth,)
julia&gt; Data_R = rotate_translate_scale(Data_C, Rotate=30);
julia&gt; Data_R
ParaviewData
  size  : (11, 11, 41)
  x     ϵ [ 8.169872981077807 : 21.83012701892219]
  y     ϵ [ 28.16987298107781 : 41.83012701892219]
  z     ϵ [ -50.0 : -10.0]
  fields: (:Depth,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1675-L1706">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.save_GMG-Tuple{String, Union{CartData, GeoData, UTMData}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.save_GMG-Tuple{String, Union{CartData, GeoData, UTMData}}"><code>GeophysicalModelGenerator.save_GMG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_GMG(filename::String, data::Union{GeoData, CartDat, UTMData}; dir=pwd())</code></pre><p>Saves the dataset <code>data</code> to a JLD2 <code>file</code> (name without extension) in the directory <code>dir</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Lon3D,Lat3D,Depth3D = lonlatdepth_grid(1.0:3:10.0, 11.0:4:20.0, (-20:5:-10)*km);
julia&gt; Data_set    =   GeophysicalModelGenerator.GeoData(Lon3D,Lat3D,Depth3D,(DataFieldName=Depth3D,))   
julia&gt; save_GMG(&quot;test&quot;,Data_set)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/IO.jl#L6-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.save_LaMEM_markers_parallel-Tuple{CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.save_LaMEM_markers_parallel-Tuple{CartData}"><code>GeophysicalModelGenerator.save_LaMEM_markers_parallel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_LaMEM_markers_parallel(Grid::CartData; PartitioningFile=empty, directory=&quot;./markers&quot;, verbose=true, is64bit=false)</code></pre><p>Saves a LaMEM marker file from the <code>CartData</code> structure <code>Grid</code>. It must have a field called <code>Phases</code>, holding phase information (as integers) and optionally a field <code>Temp</code> with temperature info. It is possible to provide a LaMEM partitioning file <code>PartitioningFile</code>. If not, output is assumed to be for one processor. By default it is assumed that the partitioning file was generated on a 32bit PETSc installation. If <code>Int64</code> was used instead, set the flag.</p><p>The size of <code>Grid</code> should be consistent with what is provided in the LaMEM input file. In practice, the size of the mesh can be retrieved from a LaMEM input file using <code>read_LaMEM_inputfile</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; Grid    = read_LaMEM_inputfile(&quot;LaMEM_input_file.dat&quot;)
julia&gt; Phases  = zeros(Int32,size(Grid.X));
julia&gt; Temp    = ones(Float64,size(Grid.X));
julia&gt; Model3D = CartData(Grid, (Phases=Phases,Temp=Temp))
julia&gt; save_LaMEM_markers_parallel(Model3D)
Writing LaMEM marker file -&gt; ./markers/mdb.00000000.dat</code></pre><p>If you want to create a LaMEM input file for multiple processors:</p><pre><code class="nohighlight hljs">julia&gt; save_LaMEM_markers_parallel(Model3D, PartitioningFile=&quot;ProcessorPartitioning_4cpu_1.2.2.bin&quot;)
Writing LaMEM marker file -&gt; ./markers/mdb.00000000.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000001.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000002.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000003.dat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L375-L402">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.save_LaMEM_topography-Tuple{CartData, String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.save_LaMEM_topography-Tuple{CartData, String}"><code>GeophysicalModelGenerator.save_LaMEM_topography</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_LaMEM_topography(Topo::CartData, filename::String)</code></pre><p>This writes a topography file <code>Topo</code> for use in LaMEM, which should have size <code>(nx,ny,1)</code> and contain the field <code>:Topography</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/LaMEM_io.jl#L939-L943">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.screenshot_to_CartData-Tuple{String, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.screenshot_to_CartData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.screenshot_to_CartData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data = screenshot_to_CartData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing)</code></pre><p>Does the same as <code>screenshot_to_GeoData</code>, but returns a <code>CartData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_import.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.screenshot_to_GeoData-Tuple{String, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.screenshot_to_GeoData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.screenshot_to_GeoData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">screenshot_to_GeoData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, Cartesian=false, UTM=false, UTMzone, isnorth=true, fieldname::Symbol=:colors)</code></pre><p>Take a screenshot of Georeferenced image either a <code>lat/lon</code>, <code>x,y</code> (if <code>Cartesian=true</code>) or in UTM coordinates (if <code>UTM=true</code>) at a given depth or along profile and converts it to a <code>GeoData</code>, <code>CartData</code> or <code>UTMData</code> struct, which can be saved to Paraview</p><p>The lower left and upper right coordinates of the image need to be specified in tuples of <code>(lon,lat,depth)</code> or <code>(UTM_ew, UTM_ns, depth)</code>, where <code>depth</code> is negative inside the Earth (and in km).</p><p>The lower right and upper left corners can be specified optionally (to take non-orthogonal images into account). If they are not specified, the image is considered orthogonal and the corners are computed from the other two.</p><p><em>Note</em>: if your data is in <code>UTM</code> coordinates you also need to provide the <code>UTMzone</code> and whether we are on the northern hemisphere or not (<code>isnorth</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_import.jl#L161-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.screenshot_to_UTMData-Tuple{String, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.screenshot_to_UTMData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.screenshot_to_UTMData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Data = screenshot_to_UTMData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, UTMzone::Int64=nothing, isnorth::Bool=true, fieldname=:colors)</code></pre><p>Does the same as <code>screenshot_to_GeoData</code>, but returns for UTM data Note that you have to specify the <code>UTMzone</code> and <code>isnorth</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_import.jl#L303-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.spacing-Tuple{Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.spacing-Tuple{Any, Any}"><code>GeophysicalModelGenerator.spacing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dlon, dlat = spacing(lon,lat)</code></pre><p>Computes the spacing with central differences</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/WaterFlow.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.subtract_horizontalmean-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T"><a class="docstring-binding" href="#GeophysicalModelGenerator.subtract_horizontalmean-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T"><code>GeophysicalModelGenerator.subtract_horizontalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V_sub = subtract_horizontalmean(V::AbstractArray{T, 3}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 3D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1446-L1453">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.subtract_horizontalmean-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#GeophysicalModelGenerator.subtract_horizontalmean-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeophysicalModelGenerator.subtract_horizontalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V_sub = subtract_horizontalmean(V::AbstractArray{T, 2}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 2D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1480-L1487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.swap_yz_dims-Tuple{FEData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.swap_yz_dims-Tuple{FEData}"><code>GeophysicalModelGenerator.swap_yz_dims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fe_swap = swap_yz_dims(fe_data::FEData)</code></pre><p>This swaps the <code>y</code> and <code>z</code> dimensions of the FEData object, which is useful for pTatin as it uses <code>y</code> for what is <code>z</code> in GMG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L157-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.tomo_2_GeoData-Tuple{String}"><a class="docstring-binding" href="#GeophysicalModelGenerator.tomo_2_GeoData-Tuple{String}"><code>GeophysicalModelGenerator.tomo_2_GeoData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Read_TomoData(filename::String)</code></pre><p>Reads a seismic tomography dataset from a NetCDF file as a GeoData object. The keyword argument <code>vel_type::String</code> allows you to specify the type of velocity data to extract (default is &quot;vs&quot; for shear wave velocity). The function assumes that the NetCDF file contains variables for depth, longitude, latitude, and the specified velocity type.</p><p>tomodata = tomo<em>2</em>GeoData(&quot;path/to/tomo_data.nc&quot;)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_import.jl#L354-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.velocity_spherical_to_cartesian!-Tuple{GeoData, Tuple}"><a class="docstring-binding" href="#GeophysicalModelGenerator.velocity_spherical_to_cartesian!-Tuple{GeoData, Tuple}"><code>GeophysicalModelGenerator.velocity_spherical_to_cartesian!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">velocity_spherical_to_cartesian!(Data::GeoData, Velocity::Tuple)</code></pre><p>In-place conversion of velocities in spherical velocities <code>[Veast, Vnorth, Vup]</code> to cartesian coordinates (for use in paraview).</p><p>NOTE: the magnitude of the vector will be the same, but the individual <code>[Veast, Vnorth, Vup]</code> components will not be retained correctly (as a different <code>[x,y,z]</code> coordinate system is used in paraview). Therefore, if you want to display or color that correctly in Paraview, you need to store these magnitudes as separate fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L958-L967">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.votemap-Tuple{Vector{GeoData}, Vector{String}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.votemap-Tuple{Vector{GeoData}, Vector{String}}"><code>GeophysicalModelGenerator.votemap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">votemap(DataSets::Vector{GeoData}, criteria::Vector{String}, dims=(50,50,50))</code></pre><p>Creates a Vote map which shows consistent features in different 2D/3D tomographic datasets.</p><p>The way it works is:</p><ul><li>Find a common region between the different GeoData sets (overlapping lon/lat/depth regions)</li><li>Interpolate the fields of all DataSets to common coordinates</li><li>Filter data points in one model (e.g., areas with a velocity anomaly &gt; 2 percent). Set everything that satisfies this criteria to 1 and everything else to 0.</li><li>Sum the results of the different datasets</li></ul><p>If a feature is consistent between different datasets, it will have larger values.</p><p><strong>Example</strong></p><p>We assume that we have 2 seismic velocity datasets <code>Data_Zhao_Pwave</code> and <code>DataKoulakov_Alps</code>:</p><pre><code class="language-julia hljs">julia&gt; Data_Zhao_Pwave
GeoData
  size  : (121, 94, 101)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:dVp_Percentage,)
julia&gt; DataKoulakov_Alps
  GeoData
    size  : (108, 81, 35)
    lon   ϵ [ 4.0 : 20.049999999999997]
    lat   ϵ [ 37.035928143712574 : 49.01197604790419]
    depth ϵ [ -700.0 km : -10.0 km]
    fields: (:dVp_percentage, :dVs_percentage)</code></pre><p>You can create a votemap which combines the two data sets with:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = votemap([Data_Zhao_Pwave,DataKoulakov_Alps],[&quot;dVp_Percentage&gt;2.5&quot;,&quot;dVp_percentage&gt;3.0&quot;])
GeoData
  size  : (50, 50, 50)
  lon   ϵ [ 4.0 : 18.0]
  lat   ϵ [ 38.0 : 49.01197604790419]
  depth ϵ [ -700.0 km : -10.0 km]
  fields: (:votemap,)</code></pre><p>You can also create a votemap of a single dataset:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = votemap(Data_Zhao_Pwave,&quot;dVp_Percentage&gt;2.5&quot;, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:votemap,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/utils.jl#L1552-L1605">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.voxel_grav-NTuple{4, Array{Float64, 3}}"><a class="docstring-binding" href="#GeophysicalModelGenerator.voxel_grav-NTuple{4, Array{Float64, 3}}"><code>GeophysicalModelGenerator.voxel_grav</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">voxel_grav(X::Array{Float64, 3}, Y::Array{Float64, 3}, Z::Array{Float64, 3}, RHO::Array{Float64, 3};
refMod=&quot;AVG&quot;, lengthUnit=&quot;m&quot;, rhoTol=1e-9, Topo=[], outName=&quot;Bouguer&quot;, printing=true)</code></pre><p>Computes Bouguer anomalies and gradients</p><p><strong>Required arguments:</strong></p><ul><li><code>X</code>,<code>Y</code>,<code>Z</code>:       3D matrices with the coordinates of the grid (X should vary in the first dimension, Y in the second, Z (vertical) in the third)</li><li><code>RHO</code>:         3D matrix with the density at each grid point [kg/m^3]</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>refMod</code>:      1D vector with the reference density for each depth. Alternatively, the strings &quot;NE&quot;, &quot;SE&quot;, &quot;SW&quot;, &quot;NW&quot;, &quot;AVG&quot; can be used. In that case, one of the corners of <code>RHO</code> is used as reference model.In case of &quot;AVG&quot; the reference model is the average of each depth slice.</li><li><code>lengthUnit</code>:  The unit of the coordinates and topography file. Either &quot;m&quot; or &quot;km&quot;</li><li><code>rhoTol</code>:      density differences smaller than <code>rhoTol</code> will be ignored [kg/m^3]</li><li><code>Topo</code>:        2D matrix with the topography of the surface (only relevant for the paraview output)</li><li><code>outName</code>:     name of the paraview output (do not include file type)</li><li><code>printing</code>:    activate printing of additional information [<code>true</code> or <code>false</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/voxel_gravity.jl#L12-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_ASAGI-Tuple{String, CartData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_ASAGI-Tuple{String, CartData}"><code>GeophysicalModelGenerator.write_ASAGI</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_ASAGI(fname::String, Data::CartData; 
                    fields::Union{Nothing, Tuple}=nothing, 
                    km_to_m::Bool=false)</code></pre><p>Writes a CartData structure <code>Data</code> to an ASAGI file, which can be read by SeisSol or ExaHype. You can optionally pass a tuple with fields to be written. Note that we can only write individual (scalar) fields to disk, so vector or tensor fields needs to be split first</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/IO_ASAGI.jl#L13-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_FEmesh_fields-Tuple{FEData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_FEmesh_fields-Tuple{FEData}"><code>GeophysicalModelGenerator.write_FEmesh_fields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_FEmesh_fields(data::FEData)</code></pre><p>Writes cell and vertex fields to disk to be read by pTatin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L106-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_FEmesh_mesh-Tuple{FEData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_FEmesh_mesh-Tuple{FEData}"><code>GeophysicalModelGenerator.write_FEmesh_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_FEmesh_mesh(vdata::FEData; out_file=&quot;md.bin&quot;, connectivity_zero_based=true)</code></pre><p>Writes a binary file with the mesh information for pTatin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L61-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_pTatin_mesh-Tuple{FEData}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_pTatin_mesh-Tuple{FEData}"><code>GeophysicalModelGenerator.write_pTatin_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_pTatin_mesh(fe_mesh::FEData; out_file=&quot;md.bin&quot;, connectivity_zero_based=true)</code></pre><p>Write a binary file with the mesh information for pTatin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L37-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_pTatin_mesh-Tuple{Q1Data}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_pTatin_mesh-Tuple{Q1Data}"><code>GeophysicalModelGenerator.write_pTatin_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_pTatin_mesh(q1_mesh::Q1Data; out_file=&quot;md.bin&quot;, connectivity_zero_based=true)</code></pre><p>Write a binary file with the mesh information for pTatin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/pTatin_IO.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_paraview"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_paraview"><code>GeophysicalModelGenerator.write_paraview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvd = write_paraview(DataSet::ParaviewData, filename=&quot;test&quot;; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a structure with <code>Geodata</code> to a paraview (or VTK) file. If you have unstructured points (e.g., earthquake data), set <code>PointsData=true</code>. In case you want to create a movie in Paraview, and this is a timestep of that movie you also have to pass <code>time</code> and <code>pvd</code></p><p><strong>Example 1: Write a 3D volume</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   lonlatdepth_grid(10:20,30:40,(-300:25:0)km);
julia&gt; Data_set        =   GeoData(Lat,Lon,Depth,(Depthdata=Depth,LonData=Lon))  
julia&gt; write_paraview(Data_set, &quot;test_depth3D&quot;)</code></pre><p><strong>Example 2: Horizontal slice @ given depth</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   lonlatdepth_grid(10:20,30:40,10km);
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  
julia&gt; write_paraview(Data_set, &quot;test&quot;)</code></pre><p><strong>Example 3: Case with topography</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth    =   lonlatdepth_grid(10:20,30:40,10km);
julia&gt; Depth[2:4,2:4,1] .=  25km     
julia&gt; Data_set         =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  
julia&gt; write_paraview(Data_set, &quot;test2&quot;)</code></pre><p><strong>Example 4: Profile</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   lonlatdepth_grid(10:20,35,(-300:25:0)km);
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth,Depth=Depth))  
julia&gt; write_paraview(Data_set, &quot;test&quot;)</code></pre><p><strong>Example 5: Velocity vectors</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   lonlatdepth_grid(10:20,30:40,10km);
julia&gt; Ve, Vn, Vz     =   ones(size(Depth)), ones(size(Depth))*0.5, zeros(size(Depth));
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth, Velocity=(Ve,Vn,Vz)))
GeoData 
  size  : (11, 11, 1)
  lon   ϵ [ 30.0 - 40.0]
  lat   ϵ [ 10.0 - 20.0]
  depth ϵ [ 10.0 km - 10.0 km]
  fields: (:DataSet, :Velocity)  
julia&gt; write_paraview(Data_set, &quot;test_Velocity&quot;)</code></pre><p><strong>Example 6: Unconnected points (e.g., earthquake locations)</strong></p><p>Note that these points should be 1D vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   lonlatdepth_grid(10:5:20,35:2:40,(-300:50:0)km);
julia&gt; Lon=Lon[:]; Lat=Lat[:]; Depth=Depth[:];
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth[:],Depth=Depth*10));  
julia&gt; write_paraview(Data_set, &quot;test_Points&quot;, PointsData=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L7-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_paraview"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_paraview"><code>GeophysicalModelGenerator.write_paraview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_paraview(DataSet::Q1Data, filename=&quot;test&quot;; directory=nothing, pvd=nothing, time=nothing, verbose=true)</code></pre><p>Writes a <code>Q1Data</code> dataset to disk, which has cell and vertex field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L196-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_paraview"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_paraview"><code>GeophysicalModelGenerator.write_paraview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_paraview(DataSet::FEData, filename=&quot;test&quot;; directory=nothing, pvd=nothing, time=nothing, verbose=true)</code></pre><p>Writes a <code>FEData</code> dataset (general finite element) to disk, which has cell and vertex field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L277-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_paraview-Tuple{CartData, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_paraview-Tuple{CartData, Any}"><code>GeophysicalModelGenerator.write_paraview</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_paraview(DataSet::CartData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a <code>CartData</code> structure to paraview. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L147-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.write_paraview-Tuple{UTMData, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.write_paraview-Tuple{UTMData, Any}"><code>GeophysicalModelGenerator.write_paraview</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_paraview(DataSet::UTMData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a <code>UTMData</code> structure to paraview. Note that this data is <em>not</em> transformed into an Earth-like framework, but remains cartesian instead. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/Paraview_output.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeophysicalModelGenerator.xyz_grid-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#GeophysicalModelGenerator.xyz_grid-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.xyz_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">X,Y,Z = xyz_grid(X_vec::Any, Y_vec::Any, Z_vec::Any)</code></pre><p>Creates a <code>X,Y,Z</code> grid. It works just as <code>lonlatdepth_grid</code> apart from the better suited name.</p><p><strong>Example 1: Create 3D grid</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X,Y,Z =  xyz_grid(10:20,30:40,(-10:-1)km);
julia&gt; size(X)
(11, 11, 10)</code></pre><p>See <code>lonlatdepth_grid</code> for more examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/data_types.jl#L939-L952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WhereTheWaterFlows.waterflows"><a class="docstring-binding" href="#WhereTheWaterFlows.waterflows"><code>WhereTheWaterFlows.waterflows</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Topo_water, sinks, pits, bnds  = waterflows(Topo::GeoData;
    flowdir_fn=WhereTheWaterFlows.d8dir_feature, feedback_fn=nothing, drain_pits=true, bnd_as_sink=true,
    rainfall = nothing,
    minsize=300)</code></pre><p>Takes a GMG GeoData object of a topographic map and routes water through the grid. Optionally, you can specify <code>rainfall</code> in which case we accumulate the rain as specified in this 2D array instead of the cellarea. This allows you to, for example, sum, up water if you have variable rainfall in the area. The other options are as in the <code>waterflows</code> function of the package <code>WhereTheWaterFlows</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs"># Download some topographic data
julia&gt; Topo = import_topo([6.5,7.3,50.2,50.6], file=&quot;@earth_relief_03s&quot;);

# Flow the water through the area:
julia&gt; Topo_water, sinks, pits, bnds  = waterflows(Topo)
julia&gt; Topo_water
GeoData
  size      : (961, 481, 1)
  lon       ϵ [ 6.5 : 7.3]
  lat       ϵ [ 50.2 : 50.59999999999999]
  depth     ϵ [ 0.045 : 0.724]
  fields    : (:Topography, :area, :slen, :dir, :nout, :nin, :c)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/eaa648a0a38364edf4b583ffd0d9d3920bffc2ef/src/WaterFlow.jl#L41-L70">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../movies/">« Movies</a><a class="docs-footer-nextpage" href="../authors/">Authors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 10:12">Friday 30 January 2026</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
