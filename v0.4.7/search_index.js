var documenterSearchIndex = {"docs":
[{"location":"man/dataimport/#Data-importing","page":"Data Import","title":"Data importing","text":"","category":"section"},{"location":"man/dataimport/","page":"Data Import","title":"Data Import","text":"We have a number of ways to import data, besides using any of the additional packages in julia to read files.","category":"page"},{"location":"man/dataimport/","page":"Data Import","title":"Data Import","text":"GeophysicalModelGenerator.Screenshot_To_GeoData\nGeophysicalModelGenerator.Screenshot_To_CartData\nGeophysicalModelGenerator.Screenshot_To_UTMData","category":"page"},{"location":"man/dataimport/#GeophysicalModelGenerator.Screenshot_To_GeoData","page":"Data Import","title":"GeophysicalModelGenerator.Screenshot_To_GeoData","text":"Screenshot_To_GeoData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, Cartesian=false, UTM=false, UTMzone, isnorth=true)\n\nTake a screenshot of Georeferenced image either a lat/lon, x,y (if Cartesian=true) or in UTM coordinates (if UTM=true) at a given depth or along profile and converts it to a GeoData, CartData or UTMData struct, which can be saved to Paraview\n\nThe lower left and upper right coordinates of the image need to be specified in tuples of (lon,lat,depth) or (UTM_ew, UTM_ns, depth), where depth is negative in the Earth (and in km).\n\nThe lower right and upper left corners can be specified optionally (to take non-orthogonal images into account). If they are not specified, the image is considered orthogonal and the corners are computed from the other two.\n\nNote: if your data is in UTM coordinates you also need to provide the UTMzone and whether we are on the northern hemisphere or not (isnorth).\n\n\n\n\n\n","category":"function"},{"location":"man/dataimport/#GeophysicalModelGenerator.Screenshot_To_CartData","page":"Data Import","title":"GeophysicalModelGenerator.Screenshot_To_CartData","text":"Data = Screenshot_To_CartData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing)\n\nDoes the same as Screenshot_To_GeoData, but returns a CartData structure\n\n\n\n\n\n","category":"function"},{"location":"man/dataimport/#GeophysicalModelGenerator.Screenshot_To_UTMData","page":"Data Import","title":"GeophysicalModelGenerator.Screenshot_To_UTMData","text":"Data = Screenshot_To_UTMData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, UTMzone::Int64=nothing, isnorth::Bool=true)\n\nDoes the same as Screenshot_To_GeoData, but returns for UTM data  Note that you have to specify the UTMzone and isnorth\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_loadirregular3DSeismicData/#D-tomography-model-that-is-re-interpolated-on-a-regular-grid","page":"Interpolate irregular 3D seismic tomography","title":"3D tomography model that is re-interpolated on a regular grid","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#Goal","page":"Interpolate irregular 3D seismic tomography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"This explains how to load a 3D seismic data set that is given in CSV format (comma separated ASCII), and plot it in paraview. The example is a shear-wave velocity model of the Alpine-Mediterranean region, described in:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"El-Sharkawy et al. (2020), The Slab Puzzle of the Alpine‐Mediterranean Region: Insights from a new, High‐Resolution, Shear‐Wave Velocity Model of the Upper Mantle, G^3 https://doi.org/10.1029/2020GC008993","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"As the data is not given in a regular lon/lat grid, we first interpolate it to a different mesh.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#Steps","page":"Interpolate irregular 3D seismic tomography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Download-data","page":"Interpolate irregular 3D seismic tomography","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The data is can be downloaded from https://www.seismologie.ifg.uni-kiel.de/en/research/research-data/mere2020model. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Read-data-into-Julia","page":"Interpolate irregular 3D seismic tomography","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The main data-file, El-Sharkawy-etal-G3.2020_MeRE2020_Mediterranean.csv, has 23 lines of comments (indicated with #), after which the data starts. We can use the build-in package DelimitedFiles to read in the data, and tell it that the data is seperated by |. We also want the resulting data to be stored as double precision values (Float64), and the end of every line is a linebreak (\\n).","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using DelimitedFiles\njulia> data=readdlm(\"El-Sharkawy-etal-G3.2020_MeRE2020_Mediterranean.csv\",'|',Float64,'\\n', skipstart=23,header=false)\n3695678×4 Matrix{Float64}:\n 32.12  -11.0    50.0  4.57\n 36.36  -11.0    50.0  4.47\n 38.32  -10.99   50.0  4.4\n 49.77  -10.99   50.0  4.52\n 29.82  -10.98   50.0  4.44\n 34.1   -10.98   50.0  4.56\n 40.26  -10.98   50.0  4.36\n 42.19  -10.97   50.0  4.38\n 44.1   -10.97   50.0  4.38\n  ⋮ ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Next, extract vectors from it:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> lat  = data[:,1];\njulia> lon  = data[:,2];\njulia> depth=-data[:,3];\njulia> Vs   = data[:,4];","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Note that we put a minus sign in front of depth, as that is what GeophysicalModelGenerator.jl expects.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Reformat-the-data","page":"Interpolate irregular 3D seismic tomography","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/#.1-Load-and-plot-the-data-layout","page":"Interpolate irregular 3D seismic tomography","title":"3.1 Load and plot the data layout","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The data is now available as a bunch of data points. In principle we can plot that in Paraview, but it is better to reformat it into a 3D grid.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Let's first have a look at how the data is distributed at a given depth level. For that, extract all points at 50 km depth and plot it (make sure you have the Plots.l package installed)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> ind=findall(x -> x==-50.0, depth)\njulia> using Plots\njulia> scatter(lon[ind],lat[ind],marker_z=Vs[ind], ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, clims=(3.9, 4.8))","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The result looks like this:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"So this is somewhat regular but not entirely and in some areas data points are missing. It is possible to create a VTK mesh that exactly respects this data, but for that we need knowledge on how the points are connected in 3D. The comments in the file do not provide this information, which is why we interpolate it on a regular lon/lat grid here which uses the same depth levels as in the data.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We extract the available depth levels with ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> Depth_vec = unique(depth)\n301-element Vector{Float64}:\n  -50.0\n  -51.0\n  -52.0\n  -53.0\n  -54.0\n  -55.0\n  -56.0\n    ⋮\n -345.0\n -346.0\n -347.0\n -348.0\n -349.0\n -350.0","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"which shows that the data set goes from [-350:1:-50]. Let's create a regular grid, which describes a somewhat smaller area than the data-points to ensure that we can do an interpolation without having to extrapolate","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeophysicalModelGenerator \njulia> Lon,Lat,Depth     =   LonLatDepthGrid(-10:0.5:40,32:0.25:50,Depth_vec);\njulia> size(Lon)\n(101, 73, 301)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The last command shows the size of our new grid.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We can plot our new Lon/Lat grid on top of the previous data:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> scatter!(Lon[:,:,1],Lat[:,:,1],color=:white, markersize=1.5, markertype=\"+\",legend=:none)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_2)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.2-Interpolate-to-a-regular-grid","page":"Interpolate irregular 3D seismic tomography","title":"3.2 Interpolate to a regular grid","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Next, we need a method to interpolate the irregular datapoints @ a certain depth level to the white data points. ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"There are a number of ways to do this, for example by employing GMT.jl, or by using GeoStats.jl.  In this example, we will employ GeoStats. If you haven't installed it yet, do that with","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> ]\n(@v1.6) pkg> add GeoStats","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"We will first show how to interpolate data @ 50 km depth.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeoStats\njulia> Cgrid = CartesianGrid((size(Lon,1),size(Lon,2)),(minimum(Lon),minimum(Lat)),(Lon[2,2,2]-Lon[1,1,1],Lat[2,2,2]-Lat[1,1,1]))\n101×73 CartesianGrid{2,Float64}\n  minimum: Point(-10.0, 32.0)\n  maximum: Point(40.5, 50.25)\n  spacing: (0.5, 0.25)\njulia> coord = PointSet([lon[ind]'; lat[ind]'])\n12278 PointSet{2,Float64}\n  └─Point(-11.0, 32.12)\n  └─Point(-11.0, 36.36)\n  └─Point(-10.99, 38.32)\n  └─Point(-10.99, 49.77)\n  └─Point(-10.98, 29.82)\n  ⋮\n  └─Point(45.97, 42.91)\n  └─Point(45.98, 37.22)\n  └─Point(45.99, 42.07)\n  └─Point(45.99, 46.76)\n  └─Point(45.99, 50.52)\njulia> Geo   = georef((Vs=Vs[ind],), coord)\n12278 MeshData{2,Float64}\n  variables (rank 0)\n    └─Vs (Float64)\n  domain: 12278 PointSet{2,Float64}\njulia> P = EstimationProblem(Geo, Cgrid, :Vs)\n2D EstimationProblem\n  data:      12278 MeshData{2,Float64}\n  domain:    101×73 CartesianGrid{2,Float64}\n  variables: Vs (Float64)\njulia> S   = IDW(:Vs => (distance=Euclidean(),neighbors=2)); \njulia> sol = solve(P, S)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Here, we interpolated the data based on the Euclidean distance. Other methods, such as Kriging, can be used as well.  Next, we can extract the data","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia>  sol_Vs = values(sol).Vs\njulia>  Vs_2D  = reshape(sol_Vs, size(domain(sol)))\njulia>  heatmap(Lon[:,1,1],Lat[1,:,1],Vs_2D', clims=(3.9, 4.8))","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_interpolated)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The final step is to repeat this procedure for all depth levels:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> Vs_3D = zeros(size(Depth));\njulia> for iz=1:size(Depth,3)\n          println(\"Depth = $(Depth[1,1,iz])\")\n          ind   = findall(x -> x==Depth[1,1,iz], depth)\n          coord = PointSet([lon[ind]'; lat[ind]'])\n          Geo   = georef((Vs=Vs[ind],), coord)\n          P     = EstimationProblem(Geo, Cgrid, :Vs)\n          S     = IDW(:Vs => (distance=Euclidean(),neighbors=2)); \n          sol   = solve(P, S)\n          sol_Vs= values(sol).Vs\n          Vs_2D = reshape(sol_Vs, size(domain(sol)))\n          Vs_3D[:,:,iz] = Vs_2D;\n        end","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Generate-Paraview-file","page":"Interpolate irregular 3D seismic tomography","title":"4. Generate Paraview file","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Once the 3D velocity matrix has been generated, producing a Paraview file is done with the following command ","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(Vs_km_s=Vs_3D,))   \nGeoData \n  size  : (101, 73, 301)\n  lon   ϵ [ -10.0 - 40.0]\n  lat   ϵ [ 32.0 - 50.0]\n  depth ϵ [ -350.0 km - -50.0 km]\n  fields: (:Vs_km_s,) \njulia> Write_Paraview(Data_set, \"MeRe_ElSharkawy\")\n1-element Vector{String}:\n \"MeRe_ElSharkawy.vts\"","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Plotting-data-in-Paraview","page":"Interpolate irregular 3D seismic tomography","title":"5. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"In paraview you can open the file and visualize it:","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: DataPoints_Paraview)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"Note that we employ the perceptually uniform color map Barlow, which you can download here.","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"If you want to clip the data set @ 200 km depth, you need to select the Clip tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"(Image: Tutorial_ElSharkawy_MeRe_DataPoints_Paraview_2)","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/#.-Julia-script","page":"Interpolate irregular 3D seismic tomography","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_loadirregular3DSeismicData/","page":"Interpolate irregular 3D seismic tomography","title":"Interpolate irregular 3D seismic tomography","text":"julia> include(\"MeRe_ElSharkawy.jl\")","category":"page"},{"location":"man/tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"","category":"section"},{"location":"man/tutorials/","page":"Overview","title":"Overview","text":"The best way to learn how to use julia and GeophysicalModelGenerator to visualize your data is to look at the tutorials.","category":"page"},{"location":"man/tutorials/","page":"Overview","title":"Overview","text":"3D seismic tomography data on regular grid. Demonstrates how to load 3D data that are defined on a regular longitude/latitude/depth grid.\nMoho topography data. Shows how to plot Moho data as 3D points in paraview, and how to fit a surface through it.\nTopography. Shows how to quickly obtain the topography of any part of the world using GMT & transfer that to paraview.\nCoastlines. Shows how to generate land/sea surfaces.\nImport screenshots. Gives examples how you can easily import screenshots from published papers and visualize them in 3D \n3D seismic tomography data on irregular grid. Shows how to interpolate 3D seismic data, given on an irregular lon/lat grid, to a regular grid and create Paraview input from it.\nTopography and geological maps. Shows how to import ETOPO1 topography, how to drape a geological map over it & transfer that to Paraview.\nISC earthquake data. Shows how to import earthquake data from the ISC catalogue.\nPlot GPS data. Shows how to load and plot GPS data as vectors.","category":"page"},{"location":"man/tutorial_local_Flegrei/#Km-scale-volcano-tutorial-using-cartesian-coordinates","page":"Kilometer-scale volcano","title":"Km-scale volcano tutorial using cartesian coordinates","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/#Goal","page":"Kilometer-scale volcano","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"This tutorial visualizes available 3D data at a local volcano (Campi Flegrei caldera, Italy) using cartesian coordinates. This is done, e.g., when we only have geomorphological data in cartesian coordinates. It includes geological and geophysical data in UTM format from the following papers:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Two shape files containing coastline and faults:\nVilardo, G., Ventura, G., Bellucci Sessa, E. and Terranova, C., 2013. Morphometry of the Campi Flegrei caldera (southern Italy). Journal of maps, 9(4), pp.635-640. doi:10.1080/17445647.2013.842508\nEarthquake data for two volcanic unrests, in 1983-84 and 2005-2016:\nDe Siena, L., Chiodini, G., Vilardo, G., Del Pezzo, E., Castellano, M., Colombelli, S., Tisato, N. and Ventura, G., 2017. Source and dynamics of a volcanic caldera unrest: Campi Flegrei, 1983–84. Scientific reports, 7(1), pp.1-13. doi:10.1038/s41598-017-08192-7\nDe Siena, L., Sammarco, C., Cornwell, D.G., La Rocca, M., Bianco, F., Zaccarelli, L. and Nakahara, H., 2018. Ambient seismic noise image of the structurally controlled heat and fluid feeder pathway at Campi Flegrei caldera. Geophysical Research Letters, 45(13), pp.6428-6436. doi:10.1029/2018GL078817\nTravel time tomography model:\nBattaglia, Jean, Aldo Zollo, Jean Virieux, and Dario Dello Iacono, 2008. Merging active and passive data sets in traveltime tomography: the case study of Campi Flegrei caldera (Southern Italy). Geophysical Prospecting 56, no. 4: 555-573.  doi:10.1111/j.1365-2478.2007.00687.x\nAmbient noise tomography model:\nBattaglia, Jean, Aldo Zollo, Jean Virieux, and Dario Dello Iacono, 2008. Merging active and passive data sets in traveltime tomography: the case study of Campi Flegrei caldera (Southern Italy). Geophysical Prospecting 56, no. 4: 555-573.  doi:10.1111/j.1365-2478.2007.00687.x","category":"page"},{"location":"man/tutorial_local_Flegrei/#Steps","page":"Kilometer-scale volcano","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/#.-Download-all-data-for-region","page":"Kilometer-scale volcano","title":"1. Download all data for region","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"You will need to download the zipped folder containing all files from here.","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Make sure that you are in the unzipped directory.","category":"page"},{"location":"man/tutorial_local_Flegrei/#.-Geomorphology","page":"Kilometer-scale volcano","title":"2. Geomorphology","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Load both the the shape (.shp) files contained in \"./Geomorphology/*.shp\" inside Paraview. In the following figures we show the Cartesian representation (not geolocalized - left) and the UTM (UTM). Our shape files can only be loaded in the cartesian:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"(Image: Tutorial_Flegrei_Geomorphology)","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"To reproduce it, represent the coastline as data points with black solid color and assign your favourite color map to the morphology. Note that each block color number corresponds to a different morphology. Beware that this file only works in cartesian coordinate, as it is still impossible to generate shape files in real UTM coordinates","category":"page"},{"location":"man/tutorial_local_Flegrei/#.-Earthquakes","page":"Kilometer-scale volcano","title":"3. Earthquakes","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Now let's plot earthquake data provided as text files. Start loading the data contained in \"./SeismicLocations/*.txt\". The first column gives us a temporal marker we can use to plot earthquakes in different periods.","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"julia> using DelimitedFiles, GeophysicalModelGenerator, Glob, GeoStats\njulia> data_80s            = readdlm(\"SeismicLocations/Seismicity_UTM_1983_1984.txt\", '\\t', skipstart=0, header=false);\njulia> data_00s            = readdlm(\"SeismicLocations/Seismicity_UTM_2005_2016.txt\", ' ', skipstart=0, header=false);\njulia> data                = vcat(data_80s,data_00s)        \njulia> time                = data[:,1];\njulia> WE                  = data[:,2];\njulia> SN                  = data[:,3];\njulia> depth               = data[:,4];\njulia> EQ_Data_Cart        = CartData(WE,SN,depth,(Depth=depth * m,Time=time * yr,));\njulia> Write_Paraview(EQ_Data_Cart, \"CF_Earthquakes_Cartesian\", PointsData=true)\njulia> EQ_Data_UTM         = UTMData(WE, SN, depth, 33, true, (Depth=depth * m,Time=time * yr,));\njulia> Data_set_UTM        =   convert(GeophysicalModelGenerator.GeoData,EQ_Data_UTM)\njulia> Write_Paraview(Data_set_UTM, \"CF_Earthquakes_UTM\", PointsData=true)","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Save in paraview with both cartesian and UTM formats. The final seismicity map looks like this:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"(Image: Tutorial_Flegrei_seismicity)","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"The colour scale distinguishes earthquakes of different decades. Notice the progressive migration of recent seismicity (black dots) towards East.","category":"page"},{"location":"man/tutorial_local_Flegrei/#.-Velocity-model","page":"Kilometer-scale volcano","title":"4. Velocity model","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Using the Alps tutorial it is easy to create a paraview file from the Vp, Vs and Vp/Vs model in \"./TravelTmeTomography/modvPS.dat\" for both cartesian and UTM coordinates.","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"julia> using DelimitedFiles, GeophysicalModelGenerator\njulia> data            =   readdlm(\"TravelTimeTomography/modvPS.dat\", '\\t', Float64, skipstart=0, header=false);\njulia> WE              =   data[:,1];\njulia> SN              =   data[:,2];\njulia> depth           =   data[:,3];\njulia> Vp              =   data[:,4];\njulia> Vs              =   data[:,5];\njulia> VpVs            =   data[:,6];\njulia> resolution      =   (length(unique(depth)),  length(unique(SN)), length(unique(WE)))\njulia> dim_perm        =   [3 2 1]\njulia> we              =   permutedims(reshape(WE, resolution), dim_perm);\njulia> sn              =   permutedims(reshape(SN, resolution), dim_perm);\njulia> depth           =   permutedims(reshape(depth, resolution), dim_perm);\njulia> Vp3d            =   permutedims(reshape(Vp, resolution), dim_perm);\njulia> Vs3d            =   permutedims(reshape(Vs, resolution), dim_perm);\njulia> Vp_Vs3d         =   permutedims(reshape(VpVs, resolution), dim_perm);\njulia> Data_set_Cartesian  =   CartData(we, sn, depth, (vp = Vp3d * (km / s), vs = Vs3d * (km / s), vpvs = Vp_Vs3d,))\njulia> Write_Paraview(Data_set_Cartesian, \"CF_Velocity_Cartesian\")\njulia> Data_set        =   UTMData(we, sn, depth, 33, true, (vp = Vp3d * (km / s), vs = Vs3d * (km / s), vpvs = Vp_Vs3d,))\njulia> Data_set_UTM    =   convert(GeophysicalModelGenerator.GeoData,Data_set)\njulia> Write_Paraview(Data_set_UTM, \"CF_Velocity_UTM\")","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Including the Vp/Vs model in the previous Paraview file workspace:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"(Image: Tutorial_Flegrei_VpVs)","category":"page"},{"location":"man/tutorial_local_Flegrei/#.-Horizontal-slices-of-shear-velocity-on-irregular-grid","page":"Kilometer-scale volcano","title":"5. Horizontal slices of shear velocity on irregular grid","text":"","category":"section"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Using ambient noise you can map shear wave velocity at different depths. The models at each depth are contained in the files \"./NoiseTomography/*.txt\". We read them consecutively in a \"for\" loop:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"julia> list_files        = glob(\"AmbientNoiseTomography/*.txt\");\njulia> li                = size(list_files, 1);\njulia> for i = 1:li\njulia>   nameFile        = list_files[i];\njulia>   name_vts        = name_vts[24:26];\njulia>   data            = readdlm(nameFile, '\\t', Float64);\njulia>   WE              = data[:,1];\njulia>   SN              = data[:,2];\njulia>   depth           = data[:,3];\njulia>   Vs              = data[:,4];","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"However these models are too wide, so it is better to constrain them:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"julia>   findall( (WE .>= 419000) .& (WE.<=435000) .& (SN.>=4514000) .& (SN.<=4528000) );\njulia>   WE              = WE[ind];\njulia>   SN              = SN[ind];\njulia>   depth           = depth[ind];\njulia>   Vs              = Vs[ind];","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"Also, nodes are irregular, hence we create a 3D regular UTM:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"julia>  l                = length(WE);\njulia>  n_WE             = minimum(WE):100:maximum(WE);\njulia>  n_SN             = minimum(SN):100:maximum(SN);\njulia>  we, sn, Depth    = XYZGrid(n_WE, n_SN, depth[1]);\njulia>  Vs_3D            = zeros(size(Depth));\njulia>  Cgrid            = GeoStats.CartesianGrid((size(we, 1), size(we, 2)), (minimum(we), minimum(sn)), (we[2,2,1] - we[1,1,1], sn[2,2,1] - sn[1,1,1]))\njulia>  coord            = PointSet([WE[:]'; SN[:]']);\njulia>  Geo              = georef((Vs = Vs[:],), coord);\njulia>  P                = EstimationProblem(Geo, Cgrid, :Vs);\njulia>  S                = IDW(:Vs => (;neighbors=2));\njulia>  sol              = solve(P, S);\njulia>  sol_Vs           = values(sol).Vs;\njulia>  Vs_2D            = reshape(sol_Vs, size(domain(sol)));\njulia>  Vs_3D[:,:,1]     = Vs_2D;\njulia>  Data_set_Cart    = CartData(we, sn, Depth, (Vs = Vs_3D  * (km / s),))\njulia>  Write_Paraview(Data_set_Cart, \"CF_Noise\" * name_vts * \"_Cartesian\")\njulia>  Data_set         = UTMData(we, sn, Depth, 33, true, (Vs = Vs_3D*(km / s),));\njulia>  Data_set_UTM     = convert(GeophysicalModelGenerator.GeoData, Data_set);\njulia>  Write_Paraview(Data_set_UTM, \"CF_Noise_UTM_\"*name_vts)\njulia>  end","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"This is one of the horizontal sections created by the code in the previous model in both reference systems:","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"(Image: Tutorial_Flegrei_Noise)","category":"page"},{"location":"man/tutorial_local_Flegrei/","page":"Kilometer-scale volcano","title":"Kilometer-scale volcano","text":"If you want to run the entire example, you can find the .jl code here","category":"page"},{"location":"man/tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"man/tools/","page":"Tools","title":"Tools","text":"We have a number of functions with which we can extract sub-data from a 2D or 3D GeoData structure.","category":"page"},{"location":"man/tools/","page":"Tools","title":"Tools","text":"GeophysicalModelGenerator.CrossSection\nGeophysicalModelGenerator.ExtractSubvolume\nGeophysicalModelGenerator.InterpolateDataFields\nGeophysicalModelGenerator.VoteMap\nGeophysicalModelGenerator.SubtractHorizontalMean\nGeophysicalModelGenerator.AboveSurface\nGeophysicalModelGenerator.BelowSurface\nGeophysicalModelGenerator.InterpolateDataOnSurface\nGeophysicalModelGenerator.ParseColumns_CSV_File\nGeophysicalModelGenerator.RotateTranslateScale!\nGeophysicalModelGenerator.Convert2UTMzone\nGeophysicalModelGenerator.Convert2CartData\nGeophysicalModelGenerator.ImportTopo\nGeophysicalModelGenerator.ProjectCartData\nGeophysicalModelGenerator.DrapeOnTopo\nGeophysicalModelGenerator.LithostaticPressure!","category":"page"},{"location":"man/tools/#GeophysicalModelGenerator.CrossSection","page":"Tools","title":"GeophysicalModelGenerator.CrossSection","text":"CrossSection(Volume::GeoData; dims=(100,100), Interpolate=false, Depth_level=nothing; Lat_level=nothing; Lon_level=nothing; Start=nothing, End=nothing )\n\nCreates a cross-section through a volumetric (3D) GeoData object. \n\nCross-sections can be horizontal (map view at a given depth), if Depth_level is specified\nThey can also be vertical, either by specifying Lon_level or Lat_level (for a fixed lon/lat), or by defining both Start=(lon,lat) & End=(lon,lat) points.\nInterpolate indicates whether we want to simply extract the data from the 3D volume (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in dims\n\nExample:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2;                # some data\njulia> Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);\njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz))); \njulia> Data_cross      =   CrossSection(Data_set3D, Depth_level=-100km)  \nGeoData \n  size  : (11, 11, 1)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -100.0 km : -100.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.ExtractSubvolume","page":"Tools","title":"GeophysicalModelGenerator.ExtractSubvolume","text":"ExtractSubvolume(V::GeoData; Interpolate=false, Lon_level=nothing, Lat_level=nothing, Depth_level=nothing, dims=(50,50,50))\n\nExtract or \"cuts-out\" a piece of a 2D or 3D GeoData set, defined by Lon, Lat and Depth coordinates.\n\nThis is useful if you are only interested in a part of a much bigger larger data set.\n\nLon_level,Lat_level and Depth_level should be tuples that indicate (minimum_value, maximum_value) along the respective direction. If not specified we use the full range. \nBy default, Interpolate=false and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).\nAlternatively, if Interpolate=true we interpolate the data onto a new grid that has dimensions dims. This can be useful to compare data sets that are originally given in different resolutions.\n\n3D Example with no interpolation:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2;                # some data\njulia> Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);\njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))\nGeoData \n  size  : (11, 11, 13)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\njulia> Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))\nGeoData \n  size  : (3, 6, 13)\n  lon   ϵ [ 10.0 : 12.0]\n  lat   ϵ [ 35.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\nBy default it extracts the data points closest to the area defined by Lonlevel/Latlevel/Depth_level.\n\n3D Example with interpolation:\n\nAlternatively, you can also interpolate the data onto a new grid:\n\njulia> Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40), Interpolate=true, dims=(50,51,52))\nGeoData \n  size  : (50, 51, 52)\n  lon   ϵ [ 10.0 : 12.0]\n  lat   ϵ [ 35.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData, :Velocity)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.InterpolateDataFields","page":"Tools","title":"GeophysicalModelGenerator.InterpolateDataFields","text":"InterpolateDataFields(V::GeoData, Lon, Lat, Depth)\n\nInterpolates a data field V on a grid defined by Lon,Lat,Depth\n\n\n\n\n\nInterpolateDataFields(V::UTMData, EW, NS, Depth)\n\nInterpolates a data field V on a grid defined by UTM,Depth\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.VoteMap","page":"Tools","title":"GeophysicalModelGenerator.VoteMap","text":"VoteMap(DataSets::Vector{GeoData}, criteria::Vector{String}, dims=(50,50,50))\n\nCreates a Vote map which shows consistent features in different 2D/3D tomographic datasets.\n\nThe way it works is:\n\nFind a common region between the different GeoData sets (overlapping lon/lat/depth regions)\nInterpolate the fields of all DataSets to common coordinates\nFilter data points in one model (e.g., areas with a velocity anomaly > 2 percent). Set everything that satisfies this criteria to 1 and everything else to 0.\nSum the results of the different datasets\n\nIf a feature is consistent between different datasets, it will have larger values. \n\nExample\n\nWe assume that we have 2 seismic velocity datasets Data_Zhao_Pwave and DataKoulakov_Alps:\n\njulia> Data_Zhao_Pwave\nGeoData \n  size  : (121, 94, 101)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> DataKoulakov_Alps\n  GeoData \n    size  : (108, 81, 35)\n    lon   ϵ [ 4.0 : 20.049999999999997]\n    lat   ϵ [ 37.035928143712574 : 49.01197604790419]\n    depth ϵ [ -700.0 km : -10.0 km]\n    fields: (:dVp_percentage, :dVs_percentage)\n\nYou can create a VoteMap which combines the two data sets with:\n\njulia> Data_VoteMap = VoteMap([Data_Zhao_Pwave,DataKoulakov_Alps],[\"dVp_Percentage>2.5\",\"dVp_percentage>3.0\"])\nGeoData \n  size  : (50, 50, 50)\n  lon   ϵ [ 4.0 : 18.0]\n  lat   ϵ [ 38.0 : 49.01197604790419]\n  depth ϵ [ -700.0 km : -10.0 km]\n  fields: (:VoteMap,)\n\nYou can also create a VoteMap of a single dataset:\n\njulia> Data_VoteMap = VoteMap(Data_Zhao_Pwave,\"dVp_Percentage>2.5\", dims=(50,51,52))\nGeoData \n  size  : (50, 51, 52)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:VoteMap,)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.SubtractHorizontalMean","page":"Tools","title":"GeophysicalModelGenerator.SubtractHorizontalMean","text":"V_sub = SubtractHorizontalMean(V::AbstractArray{T, 3}; Percentage=false)\n\nSubtracts the horizontal average of the 3D data array V.\n\nIf Percentage=true, the result is given as percentage; otherwise absolute values are returned\n\n\n\n\n\nV_sub = SubtractHorizontalMean(V::AbstractArray{T, 2}; Percentage=false)\n\nSubtracts the horizontal average of the 2D data array V.\n\nIf Percentage=true, the result is given as percentage; otherwise absolute values are returned\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.AboveSurface","page":"Tools","title":"GeophysicalModelGenerator.AboveSurface","text":"AboveSurface(Data::GeoData, DataSurface::GeoData; above=true)\n\nReturns a boolean array of size(Data.Lon), which is true for points that are above the surface DataSurface (or for points below if above=false).\n\nThis can be used, for example, to mask points above/below the Moho in a volumetric dataset or in a profile.\n\nExample\n\nFirst we create a 3D data set and a 2D surface:\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data            =   Depth*2; \njulia> Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon))\nGeoData \n  size  : (11, 11, 13)\n  lon   ϵ [ 10.0 : 20.0]\n  lat   ϵ [ 30.0 : 40.0]\n  depth ϵ [ -300.0 km : 0.0 km]\n  fields: (:Depthdata, :LonData)\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,-40km);  \njulia> Data_Moho       =   GeoData(Lon,Lat,Depth+Lon*km, (MohoDepth=Depth,))\n  GeoData \n    size  : (11, 11, 1)\n    lon   ϵ [ 10.0 : 20.0]\n    lat   ϵ [ 30.0 : 40.0]\n    depth ϵ [ -30.0 km : -20.0 km]\n    fields: (:MohoDepth,)\n\nNext, we intersect the surface with the data set:\n\njulia> Above       =   AboveSurface(Data_set3D, Data_Moho); \n\nNow, Above is a boolean array that is true for points above the surface and false for points below and at the surface.\n\n\n\n\n\nAbove = AboveSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData; above=true)\n\nDetermines if points within the 3D Data_Cart structure are above the Cartesian surface DataSurface_Cart\n\n\n\n\n\nAbove = AboveSurface(Data_Cart::CartData, DataSurface_Cart::CartData; above=true)\n\nDetermines if points within the 3D Data_Cart structure are above the Cartesian surface DataSurface_Cart\n\n\n\n\n\nAbove = AboveSurface(Grid::CartGrid, DataSurface_Cart::CartData; above=true)\n\nDetermines if points described by the Grid CartGrid structure are above the Cartesian surface DataSurface_Cart\n\n\n\n\n\nAbove = AboveSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)\n\nDetermines if points within the 3D LaMEM_grid structure are above the Cartesian surface DataSurface_Cart\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.BelowSurface","page":"Tools","title":"GeophysicalModelGenerator.BelowSurface","text":"Below = BelowSurface(Data::GeoData, DataSurface::GeoData)\n\nDetermines if points within the 3D Data structure are below the GeoData surface DataSurface\n\n\n\n\n\nBelow = BelowSurface(Grid::CartGrid, DataSurface_Cart::CartData)\n\nDetermines if points described by the `Grid` CartGrid structure are above the Cartesian surface `DataSurface_Cart`\n\n\n\n\n\nBelow = BelowSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData)\n\nDetermines if points within the 3D DataCart structure are below the Cartesian surface DataSurfaceCart\n\n\n\n\n\nBelow = BelowSurface(Data_Cart::CartData, DataSurface_Cart::CartData)\n\nDetermines if points within the 3D DataCart structure are below the Cartesian surface DataSurfaceCart\n\n\n\n\n\nBelow = BelowSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)\n\nDetermines if points within the 3D LaMEM_grid structure are below the Cartesian surface DataSurface_Cart\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.InterpolateDataOnSurface","page":"Tools","title":"GeophysicalModelGenerator.InterpolateDataOnSurface","text":"Surf_interp = InterpolateDataOnSurface(V::ParaviewData, Surf::ParaviewData)\n\nInterpolates a 3D data set V on a surface defined by Surf. nex\n\nExample\n\njulia> Data\nParaviewData \n  size  : (33, 33, 33)\n  x     ϵ [ -3.0 : 3.0]\n  y     ϵ [ -2.0 : 2.0]\n  z     ϵ [ -2.0 : 0.0]\n  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\njulia> surf\nParaviewData \n  size  : (96, 96, 1)\n  x     ϵ [ -2.9671875 : 3.2671875]\n  y     ϵ [ -1.9791666666666667 : 1.9791666666666667]\n  z     ϵ [ -1.5353766679763794 : -0.69925457239151]\n  fields: (:Depth,)\njulia> Surf_interp = InterpolateDataOnSurface(Data, surf)\n  ParaviewData \n    size  : (96, 96, 1)\n    x     ϵ [ -2.9671875 : 3.2671875]\n    y     ϵ [ -1.9791666666666667 : 1.9791666666666667]\n    z     ϵ [ -1.5353766679763794 : -0.69925457239151]\n    fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\n\n\n\n\n\nSurf_interp = InterpolateDataOnSurface(V::GeoData, Surf::GeoData)\n\nInterpolates a 3D data set V on a surface defined by Surf\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.ParseColumns_CSV_File","page":"Tools","title":"GeophysicalModelGenerator.ParseColumns_CSV_File","text":"ParseColumns_CSV_File(data_file, num_columns)\n\nThis parses numbers from CSV file that is read in with CSV.File. That is useful in case the CSV files has tables that contain both strings (e.g., station names) and numbers (lat/lon/height) and you are only intested in the numbers\n\nExample\n\nThis example assumes that the data starts at line 18, that the colums are separated by spaces, and that it contains at most 4 columns with data:\n\njulia> using CSV\njulia> data_file        =   CSV.File(\"FileName.txt\",datarow=18,header=false,delim=' ')\njulia> data = ParseColumns_CSV_File(data_file, 4)\n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.DrapeOnTopo","page":"Tools","title":"GeophysicalModelGenerator.DrapeOnTopo","text":"Topo = DrapeOnTopo(Topo::GeoData, Data::GeoData)\n\nThis drapes fields of a data set Data on the topography Topo    \n\n\n\n\n\nDrapeOnTopo(Topo::CartData, Data::CartData)\n\nDrapes Cartesian Data on topography \n\n\n\n\n\n","category":"function"},{"location":"man/tools/#GeophysicalModelGenerator.LithostaticPressure!","page":"Tools","title":"GeophysicalModelGenerator.LithostaticPressure!","text":"LithostaticPressure!(Plithos::Array, Density::Array, dz::Number; g=9.81)\n\nComputes lithostatic pressure from a 3D density array, assuming constant soacing dz in vertical direction. Optionally, the gravitational acceleration g can be specified.\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_MohoTopo/#Moho-topography","page":"Visualize Moho topography","title":"Moho topography","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/#Goal","page":"Visualize Moho topography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"This explains how to load the Moho topography for Italy and the Alps and create a paraview file ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Spada, M., Bianchi, I., Kissling, E., Agostinetti, N.P., Wiemer, S., 2013. Combining controlled-source seismology and receiver function information to derive 3-D Moho topography for Italy. Geophysical Journal International 194, 1050–1068. doi:10.1093/gji/ggt148","category":"page"},{"location":"man/tutorial_MohoTopo/#Steps","page":"Visualize Moho topography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/#.-Download-data","page":"Visualize Moho topography","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The data is available as digital dataset on the researchgate page of Prof. Edi Kissling https://www.researchgate.net/publication/322682919MohoMap_Data-WesternAlps-SpadaETAL2013","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"We have also uploaded it here: https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The full data set actually includes 3 different Moho's (Europe, Adria, Tyrrhenia-Corsica). To simplify matters, we have split the full file into 3 seperate ascii files and uploaded it.","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Please download the files Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho1.txt, Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho2.txt and Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho3.txt","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Read-data-into-Julia","page":"Visualize Moho topography","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The data sets start at line 39. We read this into julia as:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using DelimitedFiles\njulia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho1.txt\",' ',Float64,'\\n', skipstart=38,header=false)\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Note that depth is made negative.","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Reformat-the-data","page":"Visualize Moho topography","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Next, let's check if the data is spaced in a regular manner in Lon/Lat direction.  For that, we plot it using the Plots package (you may have to install that first on your machine).","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using Plots\njulia> scatter(lon,lat,marker_z=depth, ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, c = :roma)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"What we can see nicely here is that the data is reasonably regular but also that there are obviously locations where no data is define.","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The easiest way to transfer this to Paraview is to simply save this as 3D data points:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using GeophysicalModelGenerator\njulia> data_Moho1 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\nGeoData \n  size  : (12355,)\n  lon   ϵ [ 4.00026 - 11.99991]\n  lat   ϵ [ 42.51778 - 48.99544]\n  depth ϵ [ -57.46 km - -21.34 km]\n  fields: (:MohoDepth,)\njulia>  Write_Paraview(data_Moho1, \"Spada_Moho_Europe\", PointsData=true) ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"And we can do the same with the other two Moho's:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho2.txt\",' ',Float64,'\\n', skipstart=38,header=false);\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];\njulia> data_Moho2 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\njulia> Write_Paraview(data_Moho2, \"Spada_Moho_Adria\", PointsData=true) \njulia> data =readdlm(\"Moho_Map_Data-WesternAlps-SpadaETAL2013_Moho3.txt\",' ',Float64,'\\n', skipstart=38,header=false);\njulia> lon, lat, depth        = data[:,1], data[:,2], -data[:,3];\njulia> data_Moho3 = GeoData(lon,lat,depth,(MohoDepth=depth*km,))\njulia> Write_Paraview(data_Moho3, \"Spada_Moho_Tyrrhenia\", PointsData=true) ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"If we plot this in paraview, it looks like this: (Image: DataPoints_PV)","category":"page"},{"location":"man/tutorial_MohoTopo/#.1-Fitting-a-mesh-through-the-data","page":"Visualize Moho topography","title":"3.1 Fitting a mesh through the data","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"So obviously, the Moho is discontinuous between these three Mohos. Often, it looks nicer if we fit a regular surface through these data points. To do this we first combine the data points of the 3 surfaces into one set of points   ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> lon   = [data_Moho1.lon.val;   data_Moho2.lon.val;   data_Moho3.lon.val];\njulia> lat   = [data_Moho1.lat.val;   data_Moho2.lat.val;   data_Moho3.lat.val];\njulia> depth = [data_Moho1.depth.val; data_Moho2.depth.val; data_Moho3.depth.val];\njulia> data_Moho_combined = GeoData(lon, lat, depth, (MohoDepth=depth*km,))","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Next, we define a regular lon/lat grid ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> Lon,Lat,Depth     =   LonLatDepthGrid(4.1:0.1:11.9,42.5:.1:49,-30km);","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"And we will use a nearest neighbor interpolation method to fit a surface through the data. This has the advantage that it will take the discontinuities into account. We will use the package NearestNeighbors.jl for this, which you may have to install first ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> using NearestNeighbors\njulia> kdtree = KDTree([lon'; lat'])\njulia> idxs, dists = knn(kdtree, [Lon[:]'; Lat[:]'], 1, true)","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"idxs contains the indices of the closest points to the grid in (Lon,Lat). Next ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> Depth = zeros(size(Lon))*km;\njulia> for i=1:length(idxs)\n          Depth[i] = depth[idxs[i]][1]\n       end","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"Now, we can create a GeoData structure with the regular surface and save it to paraview:","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> data_Moho = GeoData(Lon, Lat, Depth, (MohoDepth=Depth,))\njulia> Write_Paraview(data_Moho, \"Spada_Moho_combined\") ","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The result is shown here, where the previous points are colored white and are a bit smaller. Obviously, the datasets coincide well. (Image: DataPoints_Moho_surface)","category":"page"},{"location":"man/tutorial_MohoTopo/#.-Julia-script","page":"Visualize Moho topography","title":"4. Julia script","text":"","category":"section"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_MohoTopo/","page":"Visualize Moho topography","title":"Visualize Moho topography","text":"julia> include(\"MohoTopo_Spada.jl\")","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Extract-ETOPO1-topographic-data-using-GMT.jl-and-drape-a-geological-map-on-top-of-the-topography-(given-as-raster-graphics)","page":"ETOPO1 Topography and geological maps","title":"Extract ETOPO1 topographic data using GMT.jl and drape a geological map on top of the topography (given as raster graphics)","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Goal","page":"ETOPO1 Topography and geological maps","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"In many cases, we want to add topographic data as well a information about tectonic units to our visualization. This tutorial shows how to use GMT.jl to import data from an ETOPO1 file for a certain region, load a geological map from a raster graphics file (here: PNG), drape it over the topography and transfer that.","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"note: Note\nIt may be tricky to get GMT.jl installed and working correctly on your system (at least until someone prevides a BinaryBuilder package for julia, that is). You first need to have a working version of GMT on your system and only after that, you can install GMT.jl. See the installation instructions on their webpage for details.   On a MacBook Pro, a tested procedure to install GMT and to make it work with julia is to directly install the binaries for Julia, GMT (and possibly Ghostscript) and not use any package manager (such as spack or homebrew). ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#Steps","page":"ETOPO1 Topography and geological maps","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Download-topographic-data-and-tectonic-maps-of-the-Alpine-region","page":"ETOPO1 Topography and geological maps","title":"1. Download topographic data and tectonic maps of the Alpine region","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The ETOPO1 data file used in this example can be downloaded here:   https://ngdc.noaa.gov/mgg/global/global.html. For this example we downloaded ETOPO1Iceg_gmt4.grd and stored it directly in the folder where we will be working. For the geological map, we download the data from the SPP 4DMB repository and extract the zip file (also in the current folder). In this data set, a gmt file with the data for different tectonic units is given in ./ tectonicmaps4dmb20200917/GMTexample/alcapadi_polygons.gmt . ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Create-a-tectonic-map-with-orthogonal-projection","page":"ETOPO1 Topography and geological maps","title":"2. Create a tectonic map with orthogonal projection","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"To create a png with an orthogonal map projection (which we need for the png import), we do the following in julia:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> \njulia> using GMT\njulia> filename_gmt = \"./tectonic_maps_4dmb_2020_09_17/GMT_example/alcapadi_polygons.gmt\"\njulia> plot(filename_gmt,region=\"4/20/37/49\",show=true)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"This opens a window with the plotted map. Save this image in your current working folder. Open it with a image manipulation of your choice (e.g. GIMP) and crop it to the map itself. Save the cropped image in your current working directory. For this tutorial, we have named the cropped png file tectonicmap_SPP.png. It looks like this:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"(Image: Tutorial_GMT_topography_GeologicalMap_PNG)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Import-data-to-paraview","page":"ETOPO1 Topography and geological maps","title":"3. Import data to paraview","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Now, to import the ETOPO1 topography data and to drape the geologic map over it, open julia again. Load the following packages:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> using GMT, NearestNeighbors, GeoParams, GeophysicalModelGenerator","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"First, define the filenames of the files you want to import:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> filename_topo = \"./ETOPO1/ETOPO1_Ice_g_gmt4.grd\" \njulia> filename_geo  = \"./tectonicmap_SPP.png\"","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Next, define the region that you want to visualize (note that we use the same coordinates here as we used previously for the generation of the geological map):  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> lat_min = 37.0\njulia> lat_max = 49.0\njulia> lon_min = 4.0\njulia> lon_max = 20.0","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"and import the data","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> G = gmtread(filename_topo, limits=[lon_min,lon_max,lat_min,lat_max], grid=true);\nLon,Lat,Depth    =   LonLatDepthGrid(G.x[1:end],G.y[1:end],0);\nnumel_topo       =   prod(size(Lon));\nDepth[:,:,1]     =   1e-3*G.z';\nDataTopo         =   GeophysicalModelGenerator.GeoData(Lon, Lat, Depth, (Topography=Depth*km,))","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"At this step, only the topographic data is imported. Now we have to import the tectonic map from the png file. To do so, first define the longitude and latitude of the lower left and upper right corner of the png (as we create:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> Corner_LowerLeft    =   ( lon_min, lat_min , 0.0)\njulia> Corner_UpperRight   =   (lon_max, lat_max , 0.0)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"and import the png file with the GMG function ScreenshotToGeoData:  ","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> DataPNG = Screenshot_To_GeoData(filename_geo, Corner_LowerLeft, Corner_UpperRight)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The tricky part is then to interpolate the colors from the geological map to the topography. Here, we simply use nearesat neighbor interpolation (NearestNeighbors.jl) to do so. First, we have to set up the KDTree and determine the nearest neighbors of the points in our Lat/Lon grid","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> coord = [vec(DataPNG.lon.val)';vec(DataPNG.lat.val)'];\njulia> kdtree = KDTree(coord; leafsize = 10);\njulia> points = [vec(Lon)';vec(Lat)'];\njulia> dx,dist = nn(kdtree, points);","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Once this is done, the respective colors have to be assigned to a field in the DataTopo structure:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> red   = zeros(size(Depth));\njulia> green = zeros(size(Depth));\njulia> blue  = zeros(size(Depth));\njulia> tmp                = DataPNG.fields.colors[1];\njulia> red[1:numel_topo] = tmp[idx];\njulia> tmp                = DataPNG.fields.colors[2];\njulia> green[1:numel_topo] = tmp[idx];\njulia> tmp                = DataPNG.fields.colors[3];\njulia> blue[1:numel_topo] = tmp[idx];","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Finally, to avoid artefacts, all colors outside the region described by the tectonic map are set to white:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> ind_tmp = Lat .<  Corner_LowerLeft[2];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lat .> Corner_UpperRight[2];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lon .<  Corner_LowerLeft[1];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;\n\njulia> ind_tmp = Lon .> Corner_UpperRight[1];\njulia> red[ind_tmp] .= 1;\njulia> green[ind_tmp] .= 1;\njulia> blue[ind_tmp] .= 1;","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/#.-Save","page":"ETOPO1 Topography and geological maps","title":"4. Save","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"Transforming the to Paraview is now a piece of cake:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"julia> Data_set        =   GeoData(Lon, Lat, Depth, (Topography=Depth*km,colors=(red,green,blue)))\njulia> Write_Paraview(Data_set, \"test_GeoMap\")","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"The result is shown here:","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"(Image: Tutorial_GMT_topography_GeologicalMap)","category":"page"},{"location":"man/tutorial_GMT_Topography_GeologicalMap/","page":"ETOPO1 Topography and geological maps","title":"ETOPO1 Topography and geological maps","text":"In case you are interested: we are employing the oleron scientific colormap from Fabio Crameri's scientific colormap package here.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#D-tomography-model-in-CSV-formation","page":"3D seismic tomography from ASCII","title":"3D tomography model in CSV formation","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/#Goal","page":"3D seismic tomography from ASCII","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This explains how to load a 3D P-wave model and plot it in Paraview as a 3D volumetric data set. It also shows how you can create horizontal or vertical cross-sections through the data in a straightforward manner and how you can extract subsets of the data; The example is the P-wave velocity model of the Alps as described in: ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Zhao, L., Paul, A., Malusà, M.G., Xu, X., Zheng, T., Solarino, S., Guillot, S., Schwartz, S., Dumont, T., Salimbeni, S., Aubert, C., Pondrelli, S., Wang, Q., Zhu, R., 2016. Continuity of the Alpine slab unraveled by high-resolution P wave tomography. Journal of Geophysical Research: Solid Earth 121, 8720–8737. doi:10.1002/2016JB013310","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The data is given in ASCII format with longitude/latitude/depth/velocity anomaly (percentage) format.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#Steps","page":"3D seismic tomography from ASCII","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/#.-Download-data","page":"3D seismic tomography from ASCII","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The data is can be downloaded from https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/, where you should download the file Zhao_etal_JGR_2016_Pwave_Alps_3D_k60.txt. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Read-data-into-Julia","page":"3D seismic tomography from ASCII","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The dataset has no comments, and the data values in every row are separated by a space. In order to read this into julia as a matrix, we can use the build-in julia package DelimitedFiles.    We want the resulting data to be stored as double precision values (Float64), and the end of every line is a linebreak (\\n).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using DelimitedFiles\njulia> data=readdlm(\"Zhao_etal_JGR_2016_Pwave_Alps_3D_k60.txt\",' ',Float64,'\\n', skipstart=0,header=false)\n1148774×4 Matrix{Float64}:\n  0.0   38.0   -1001.0  -0.113\n  0.15  38.0   -1001.0  -0.081\n  0.3   38.0   -1001.0  -0.069\n  0.45  38.0   -1001.0  -0.059\n  0.6   38.0   -1001.0  -0.055\n  0.75  38.0   -1001.0  -0.057\n  ⋮                     \n 17.25  51.95     -1.0  -0.01\n 17.4   51.95     -1.0  -0.005\n 17.55  51.95     -1.0   0.003\n 17.7   51.95     -1.0   0.007\n 17.85  51.95     -1.0   0.006\n 18.0   51.95     -1.0   0.003","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next, extract vectors from it:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> lon        = data[:,1];\njulia> lat        = data[:,2];\njulia> depth      = data[:,3];\njulia> dVp_perc   = data[:,4];","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Note that depth needs to with negative numbers.","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Reformat-the-data","page":"3D seismic tomography from ASCII","title":"3. Reformat the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Let's first have a look at the depth range of the data set:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Depth_vec = unique(depth)\n101-element Vector{Float64}:\n -1001.0\n  -991.0\n  -981.0\n  -971.0\n  -961.0\n  -951.0\n     ⋮\n   -51.0\n   -41.0\n   -31.0\n   -21.0\n   -11.0\n    -1.0","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"So the data has a vertical spacing of 10 km. Next, let's check if the data is spaced in a regular manner in Lon/Lat direction.  For that, we read the data at a given depth level (say -101km) and plot it using the Plots package (you may have to install that first on your machine).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using Plots\njulia> ind=findall(x -> x==-101.0, depth)\njulia> scatter(lon[ind],lat[ind],marker_z=dVp_perc[ind], ylabel=\"latitude\",xlabel=\"longitude\",markersize=2.5, c = :roma)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Note that we employ the scientific colormap roma here. This gives an overview of available colormaps. You can download the colormaps for Paraview here.  ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Clearly, the data is given as regular Lat/Lon points:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> unique(lon[ind])\n121-element Vector{Float64}:\n  0.0\n  0.15\n  0.3\n  0.45\n  0.6\n  0.75\n  ⋮\n 17.25\n 17.4\n 17.55\n 17.7\n 17.85\n 18.0\njulia> unique(lat[ind])\n94-element Vector{Float64}:\n 38.0\n 38.15\n 38.3\n 38.45\n 38.6\n 38.75\n  ⋮\n 51.2\n 51.35\n 51.5\n 51.65\n 51.8\n 51.95","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.1-Reshape-data-and-save-to-paraview","page":"3D seismic tomography from ASCII","title":"3.1 Reshape data and save to paraview","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next, we reshape the vectors with lon/lat/depth data into 3D matrixes:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> resolution =  (length(unique(lon)), length(unique(lat)), length(unique(depth)))\n(121, 94, 101)\njulia> Lon          = reshape(lon,      resolution);\njulia> Lat          = reshape(lat,      resolution);\njulia> Depth        = reshape(depth,    resolution);\njulia> dVp_perc_3D  = reshape(dVp_perc, resolution);","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Check that the results are consistent","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> iz=findall(x -> x==-101.0, Depth[1,1,:])\n1-element Vector{Int64}:\n 91\njulia> data=dVp_perc_3D[:,:,iz];\njulia> heatmap(unique(lon), unique(lat),data[:,:,1]', c=:roma,title=\"$(Depth[1,1,iz]) km\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: DataPoints)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"So this looks good.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Next we create a paraview file:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(dVp_Percentage=dVp_perc_3D,))\nGeoData \n  size  : (121, 94, 101)\n  lon   ϵ [ 0.0 - 18.0]\n  lat   ϵ [ 38.0 - 51.95]\n  depth ϵ [ -1001.0 km - -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_set, \"Zhao_etal_2016_dVp_percentage\")\n1-element Vector{String}:\n \"Zhao_etal_2016_dVp_percentage.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Plotting-data-in-Paraview","page":"3D seismic tomography from ASCII","title":"4. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In paraview you should open the *.vts file, and press Apply (left menu) after doing that. Once you did that you can select dVp_Percentage and Surface (see red ellipses below)/. In paraview you can open the file and visualize it. ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_1)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This visualisation employs the default colormap, which is not particularly good.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"You can change that by importing the roma colormap (using the link described earlier). For this, open the colormap editor and click the one with the heart on the right hand side. Next, import roma and select it.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_2)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In order to change the colorrange select the button in the red ellipse and change the lower/upper bound. (Image: Paraview_3)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you want to create a horizontal cross-section @ 200 km depth, you need to select the Slice tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_4)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"After pushing Apply, you'll see this:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_5)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you want to plot iso-surfaces (e.g. at -3%), you can use the Clip option again, but this time select scalar and don't forget to unclick invert.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_6)","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Extract-and-plot-cross-sections-of-the-data","page":"3D seismic tomography from ASCII","title":"5. Extract and plot cross-sections of the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"In many cases you would like to create cross-sections through the 3D data sets as well, and visualize that in Paraview. That is in principle possible in Paraview as well (using the Slice tool, as described above). Yet, in many cases we want to have it at a specific depth, or through pre-defined lon/lat coordinates.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"There is a simple way to achieve this using the CrossSection function. To make a cross-section at a given depth:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Depth_level=-100km)  \nGeoData \n  size  : (121, 94, 1)\n  lon   ϵ [ 0.0 : 18.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -101.0 km : -101.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_100km\")\n1-element Vector{String}:\n \"Zhao_CrossSection_100km.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Or at a specific longitude:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Lon_level=10)\nGeoData \n  size  : (1, 94, 101)\n  lon   ϵ [ 10.05 : 10.05]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,) \njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_Lon10\")\n1-element Vector{String}:\n \"Zhao_CrossSection_Lon10.vts\"","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"As you see, this cross-section is not taken at exactly 10 degrees longitude. That is because by default we don't interpolate the data, but rather use the closest point in longitude in the original data set.","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you wish to interpolate the data, specify Interpolate=true:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Lon_level=10, Interpolate=true)\nGeoData \n  size  : (1, 100, 100)\n  lon   ϵ [ 10.0 : 10.0]\n  lat   ϵ [ 38.0 : 51.95]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_Lon10_interpolated\");","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"as you see, this causes the data to be interpolated on a (100,100) grid (which can be changed by adding a dims input parameter).","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"We can also create a diagonal cut through the model:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_cross  =   CrossSection(Data_set, Start=(1.0,39), End=(18,50))\nGeoData \n  size  : (100, 100, 1)\n  lon   ϵ [ 1.0 : 18.0]\n  lat   ϵ [ 39.0 : 50.0]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_cross, \"Zhao_CrossSection_diagonal\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Here an image that shows the resulting cross-sections: ","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"(Image: Paraview_7)","category":"page"},{"location":"man/tutorial_load3DSeismicData/#.-Extract-a-(3D)-subset-of-the-data","page":"3D seismic tomography from ASCII","title":"6. Extract a (3D) subset of the data","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"Sometimes, the data set covers a large region (e.g., the whole Earth), and you are only interested in a subset of this data for your project. You can obviously cut your data to the correct size in Paraview. Yet, an even easier way is the routine ExtractSubvolume:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_subset     =   ExtractSubvolume(Data_set,Lon_level=(5,12), Lat_level=(40,45))\nGeoData \n  size  : (48, 35, 101)\n  lon   ϵ [ 4.95 : 12.0]\n  lat   ϵ [ 39.95 : 45.05]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_subset, \"Zhao_Subset\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"This gives the resulting image. You can obviously use that new, smaller, data set to create cross-sections etc. (Image: Paraview_8)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"By default, we extract the original data and do not interpolate it on a new grid. In some cases, you will want to interpolate the data on a different grid. Use the Interpolate=true option for that:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> Data_subset_interp     =   ExtractSubvolume(Data_set,Lon_level=(5,12), Lat_level=(40,45), Interpolate=true)\nGeoData \n  size  : (50, 50, 50)\n  lon   ϵ [ 5.0 : 12.0]\n  lat   ϵ [ 40.0 : 45.0]\n  depth ϵ [ -1001.0 km : -1.0 km]\n  fields: (:dVp_Percentage,)\njulia> Write_Paraview(Data_subset, \"Zhao_Subset_interp\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/#Load-and-save-data-to-disk","page":"3D seismic tomography from ASCII","title":"Load and save data to disk","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"It would be useful to save the 3D data set we just created to disk, such that we can easily load it again at a later stage and create cross-sections etc, or compare it with other models.  It is quite easy to do so with the JLD2.jl package:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using JLD2\njulia> jldsave(\"Zhao_Pwave.jld2\"; Data_set)","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"If you, at a later stage, want to load this file again do it as follows:","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> using JLD2, GeophysicalModelGenerator\njulia> Data_set_Zhao2016_Vp = load_object(\"Zhao_Pwave.jld2\")","category":"page"},{"location":"man/tutorial_load3DSeismicData/#Julia-script","page":"3D seismic tomography from ASCII","title":"Julia script","text":"","category":"section"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_load3DSeismicData/","page":"3D seismic tomography from ASCII","title":"3D seismic tomography from ASCII","text":"julia> include(\"Alps_VpModel_Zhao_etal_JGR2016.jl\")","category":"page"},{"location":"man/datastructures/#Data-structures","page":"Data Structures","title":"Data structures","text":"","category":"section"},{"location":"man/datastructures/","page":"Data Structures","title":"Data Structures","text":"The main data structure used in GeophysicalModelGenerator.jl is GeoData, which contains info about the longitude,latitude, and depth of a data set, as well as several data sets itself. We also provide a UTMData, which is essentially the same but with UTM coordinates, and a CartData structure, which has Cartesian coordinates in kilometers (as used in many geodynamic codes). If one wishes to transfer GeoData to CartData, one needs to provide a ProjectionPoint. For plotting, we transfer this into the ParaviewData structure, which has cartesian coordinates around the center of the Earth. We employ the wgs84 reference ellipsoid as provided by the Geodesy.jl package to perform this transformation.","category":"page"},{"location":"man/datastructures/","page":"Data Structures","title":"Data Structures","text":"GeophysicalModelGenerator.GeoData\nGeophysicalModelGenerator.UTMData\nGeophysicalModelGenerator.ParaviewData\nGeophysicalModelGenerator.CartData\nGeophysicalModelGenerator.LonLatDepthGrid\nGeophysicalModelGenerator.XYZGrid\nGeophysicalModelGenerator.ProjectionPoint","category":"page"},{"location":"man/datastructures/#GeophysicalModelGenerator.GeoData","page":"Data Structures","title":"GeophysicalModelGenerator.GeoData","text":"GeoData(lon::Any, lat:Any, depth::GeoUnit, fields::NamedTuple)\n\nData structure that holds one or several fields with longitude, latitude and depth information.\n\ndepth can have units of meter, kilometer or be unitless; it will be converted to km.\nfields should ideally be a NamedTuple which allows you to specify the names of each of the fields. \nIn case you only pass one array we will convert it to a NamedTuple with default name.\nA single field should be added as (DataFieldName=Data,) (don't forget the comma at the end).\nMultiple fields  can be added as well. lon,lat,depth should all have the same size as each of the fields.\nIn case you want to display a vector field in paraview, add it as a tuple: (Velocity=(Veast,Vnorth,Vup), Veast=Veast, Vnorth=Vnorth, Vup=Vup); we automatically apply a vector transformation when transforming this to a ParaviewData structure from which we generate Paraview output. As this changes the magnitude of the arrows, you will no longer see the [Veast,Vnorth,Vup] components in Paraview which is why it is a good ideas to store them as separate Fields.\nYet, there is one exception: if the name of the 3-component field is colors, we do not apply this vector transformation as this field is regarded to contain RGB colors. \nLat,Lon,Depth should have the same size as the Data array. The ordering of the arrays is important. If they are 3D arrays, as in the example below, we assume that the first dimension corresponds to lon, second dimension to lat and third dimension to depth (which should be in km). See below for an example.\n\nExample\n\njulia> Lat         =   1.0:3:10.0;\njulia> Lon         =   11.0:4:20.0;\njulia> Depth       =   (-20:5:-10)*km;\njulia> Lon3D,Lat3D,Depth3D = LonLatDepthGrid(Lon, Lat, Depth);\njulia> Lon3D\n3×4×3 Array{Float64, 3}:\n[:, :, 1] =\n 11.0  11.0  11.0  11.0\n 15.0  15.0  15.0  15.0\n 19.0  19.0  19.0  19.0\n\n[:, :, 2] =\n 11.0  11.0  11.0  11.0\n 15.0  15.0  15.0  15.0\n 19.0  19.0  19.0  19.0\n\n[:, :, 3] =\n 11.0  11.0  11.0  11.0\n 15.0  15.0  15.0  15.0\n 19.0  19.0  19.0  19.0\njulia> Lat3D\n 3×4×3 Array{Float64, 3}:\n [:, :, 1] =\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\n \n [:, :, 2] =\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\n \n [:, :, 3] =\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\n  1.0  4.0  7.0  10.0\njulia> Depth3D\n  3×4×3 Array{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}, 3}:\n  [:, :, 1] =\n   -20.0 km  -20.0 km  -20.0 km  -20.0 km\n   -20.0 km  -20.0 km  -20.0 km  -20.0 km\n   -20.0 km  -20.0 km  -20.0 km  -20.0 km\n  \n  [:, :, 2] =\n   -15.0 km  -15.0 km  -15.0 km  -15.0 km\n   -15.0 km  -15.0 km  -15.0 km  -15.0 km\n   -15.0 km  -15.0 km  -15.0 km  -15.0 km\n  \n  [:, :, 3] =\n   -10.0 km  -10.0 km  -10.0 km  -10.0 km\n   -10.0 km  -10.0 km  -10.0 km  -10.0 km\n   -10.0 km  -10.0 km  -10.0 km  -10.0 km\njulia> Data        =   zeros(size(Lon3D));\njulia> Data_set    =   GeophysicalModelGenerator.GeoData(Lon3D,Lat3D,Depth3D,(DataFieldName=Data,))   \nGeoData \n  size      : (3, 4, 3)\n  lon       ϵ [ 11.0 : 19.0]\n  lat       ϵ [ 1.0 : 10.0]\n  depth     ϵ [ -20.0 km : -10.0 km]\n  fields    : (:DataFieldName,)\n  attributes: [\"note\"]\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.UTMData","page":"Data Structures","title":"GeophysicalModelGenerator.UTMData","text":"UTMData(EW::Any, NS:Any, depth::GeoUnit, UTMZone::Int, NorthernHemisphere=true, fields::NamedTuple)\n\nData structure that holds one or several fields with UTM coordinates (east-west), (north-south) and depth information.\n\ndepth can have units of meters, kilometer or be unitless; it will be converted to meters (as UTMZ is usually in meters)\nfields should ideally be a NamedTuple which allows you to specify the names of each of the fields. \nIn case you only pass one array we will convert it to a NamedTuple with default name.\nA single field should be added as (DataFieldName=Data,) (don't forget the comma at the end).\nMultiple fields  can be added as well.\nIn case you want to display a vector field in paraview, add it as a tuple: (Velocity=(Veast,Vnorth,Vup), Veast=Veast, Vnorth=Vnorth, Vup=Vup); we automatically apply a vector transformation when transforming this to a ParaviewData structure from which we generate Paraview output. As this changes the magnitude of the arrows, you will no longer see the [Veast,Vnorth,Vup] components in Paraview which is why it is a good ideas to store them as separate Fields.\nYet, there is one exception: if the name of the 3-component field is colors, we do not apply this vector transformation as this field is regarded to contain RGB colors. \nLat,Lon,Depth should have the same size as the Data array. The ordering of the arrays is important. If they are 3D arrays, as in the example below, we assume that the first dimension corresponds to lon, second dimension to lat and third dimension to depth (which should be in km). See below for an example.\n\nExample\n\njulia> ew          =   422123.0:100:433623.0\njulia> ns          =   4.514137e6:100:4.523637e6\njulia> depth       =   -5400:250:600\njulia> EW,NS,Depth =   XYZGrid(ew, ns, depth);\njulia> Data        =   ustrip.(Depth);\njulia> Data_set    =   UTMData(EW,NS,Depth,33, true, (FakeData=Data,Data2=Data.+1.))  \nUTMData \n  UTM zone : 33-33 North\n    size    : (116, 96, 25)\n    EW      ϵ [ 422123.0 : 433623.0]\n    NS      ϵ [ 4.514137e6 : 4.523637e6]\n    depth   ϵ [ -5400.0 m : 600.0 m]\n    fields  : (:FakeData, :Data2)\n  attributes: [\"note\"]\n\nIf you wish, you can convert this from UTMData to GeoData with\n\njulia> Data_set1 =  convert(GeoData, Data_set)\nGeoData \n  size      : (116, 96, 25)\n  lon       ϵ [ 14.075969111533457 : 14.213417764154963]\n  lat       ϵ [ 40.77452227533946 : 40.86110443583479]\n  depth     ϵ [ -5.4 km : 0.6 km]\n  fields    : (:FakeData, :Data2)\n  attributes: [\"note\"]\n\nwhich would allow visualizing this in paraview in the usual manner:\n\njulia> Write_Paraview(Data_set1, \"Data_set1\")\n1-element Vector{String}:\n \"Data_set1.vts\"\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.ParaviewData","page":"Data Structures","title":"GeophysicalModelGenerator.ParaviewData","text":"ParaviewData(x::GeoUnit, y::GeoUnit, z::GeoUnit, values::NamedTuple)\n\nCartesian data in x/y/z coordinates to be used with Paraview. This is usually generated automatically from the GeoData structure, but you can also invoke do this manually:\n\njulia> Data_set    =   GeophysicalModelGenerator.GeoData(1.0:10.0,11.0:20.0,(-20:-11)*km,(DataFieldName=(-20:-11),))   \njulia> Data_cart = convert(ParaviewData, Data_set)\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.CartData","page":"Data Structures","title":"GeophysicalModelGenerator.CartData","text":"CartData(x::Any, y::Any, z::GeoUnit, fields::NamedTuple)\n\nData structure that holds one or several fields with with Cartesian x/y/z coordinates. Distances are in kilometers\n\nx,y,z can have units of meters, kilometer or be unitless; they will be converted to kilometers\nfields should ideally be a NamedTuple which allows you to specify the names of each of the fields. \nIn case you only pass one array we will convert it to a NamedTuple with default name.\nA single field should be added as (DataFieldName=Data,) (don't forget the comma at the end).\nMultiple fields  can be added as well.\nIn case you want to display a vector field in paraview, add it as a tuple: (Velocity=(Vx,Vnorth,Vup), Veast=Veast, Vnorth=Vnorth, Vup=Vup); we automatically apply a vector transformation when transforming this to a ParaviewData structure from which we generate Paraview output. As this changes the magnitude of the arrows, you will no longer see the [Veast,Vnorth,Vup] components in Paraview which is why it is a good ideas to store them as separate Fields.\nYet, there is one exception: if the name of the 3-component field is colors, we do not apply this vector transformation as this field is regarded to contain RGB colors. \nx,y,z should have the same size as the Data array. The ordering of the arrays is important. If they are 3D arrays, as in the example below, we assume that the first dimension corresponds to x, second dimension to y and third dimension to z (which should be in km). See below for an example.\n\nExample\n\njulia> x        =   0:2:10\njulia> y        =   -5:5\njulia> z        =   -10:2:2\njulia> X,Y,Z    =   XYZGrid(x, y, z);\njulia> Data     =   Z\njulia> Data_set =   CartData(X,Y,Z, (FakeData=Data,Data2=Data.+1.))\nCartData \n    size    : (6, 11, 7)\n    x       ϵ [ 0.0 km : 10.0 km]\n    y       ϵ [ -5.0 km : 5.0 km]\n    z       ϵ [ -10.0 km : 2.0 km]\n    fields  : (:FakeData, :Data2)\n  attributes: [\"note\"]\n\nCartData is particularly useful in combination with cartesian geodynamic codes, such as LaMEM, which require cartesian grids. You can directly save your data to Paraview with\n\njulia> Write_Paraview(Data_set, \"Data_set\")\n1-element Vector{String}:\n \"Data_set.vts\"\n\nIf you wish, you can convert this to UTMData (which will simply convert the )\n\njulia> Data_set1 =  convert(GeoData, Data_set)\nGeoData \n  size  : (116, 96, 25)\n  lon   ϵ [ 14.075969111533457 : 14.213417764154963]\n  lat   ϵ [ 40.77452227533946 : 40.86110443583479]\n  depth ϵ [ -5.4 km : 0.6 km]\n  fields: (:FakeData, :Data2)\n\nwhich would allow visualizing this in paraview in the usual manner:\n\n\n\n\n\n","category":"type"},{"location":"man/datastructures/#GeophysicalModelGenerator.LonLatDepthGrid","page":"Data Structures","title":"GeophysicalModelGenerator.LonLatDepthGrid","text":"Lon, Lat, Depth = LonLatDepthGrid(Lon::Any, Lat::Any, Depth:Any)\n\nCreates 3D arrays of Lon, Lat, Depth from 1D vectors or numbers\n\nExample 1: Create 3D grid\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,(-10:-1)km);\njulia> size(Lon)\n(11, 11, 10)\n\nExample 2: Create 2D lon/lat grid @ a given depth\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,-50km);\njulia> size(Lon)\n(11, 11)\n\nExample 3: Create 2D lon/depth grid @ a given lat\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10:20,30,(-10:-1)km);\njulia> size(Lon)\n(11, 11)\n\nExample 4: Create 1D vertical line @ a given lon/lat point\n\njulia> Lon,Lat,Depth =  LonLatDepthGrid(10,30,(-10:-1)km);\njulia> size(Lon)\n(10, )\n\n\n\n\n\n","category":"function"},{"location":"man/datastructures/#GeophysicalModelGenerator.XYZGrid","page":"Data Structures","title":"GeophysicalModelGenerator.XYZGrid","text":"X,Y,Z = XYZGrid(X_vec::Any, Y_vec::Any, Z_vec::Any)\n\nCreates a X,Y,Z grid. It works just as LonLatDepthGrid apart from the better suited name.\n\nExample 1: Create 3D grid\n\njulia> X,Y,Z =  XYZGrid(10:20,30:40,(-10:-1)km);\njulia> size(X)\n(11, 11, 10)\n\nSee LonLatDepthGrid for more examples.\n\n\n\n\n\n","category":"function"},{"location":"man/datastructures/#GeophysicalModelGenerator.ProjectionPoint","page":"Data Structures","title":"GeophysicalModelGenerator.ProjectionPoint","text":"struct ProjectionPoint\n    Lon     :: Float64\n    Lat     :: Float64\n    EW      :: Float64\n    NS      :: Float64\n    zone    :: Integer\n    isnorth :: Bool\nend\n\nStructure that holds the coordinates of a point that is used to project a data set from Lon/Lat to a Cartesian grid and vice-versa.\n\n\n\n\n\n","category":"type"},{"location":"man/tutorial_time_Seismicity/#How-to-create-a-movie-to-show-seismic-distribution-through-time","page":"Create movies","title":"How to create a movie to show seismic distribution through time","text":"","category":"section"},{"location":"man/tutorial_time_Seismicity/#Goal","page":"Create movies","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"This tutorial creates a movie of the spatial variations in seismicity using the earthquakes previously visualized at Campi Flegrei caldera. We visualize it against the travel-time model and tomography:","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Earthquake data for the 1983-84 unrest:\nDe Siena, L., Chiodini, G., Vilardo, G., Del Pezzo, E., Castellano, M., Colombelli, S., Tisato, N. and Ventura, G., 2017. Source and dynamics of a volcanic caldera unrest: Campi Flegrei, 1983–84. Scientific reports, 7(1), pp.1-13. doi:10.1038/s41598-017-08192-7","category":"page"},{"location":"man/tutorial_time_Seismicity/#Steps","page":"Create movies","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_time_Seismicity/#.-Download-all-data-for-region","page":"Create movies","title":"1. Download all data for region","text":"","category":"section"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"You will need to download the zipped folder containing all files from here.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Make sure that you are in the unzipped directory. To reproduce exactly the figure, you will need the velocity model loaded in the km-scale volcano tutorial, here","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"(Image: Tutorial_SeismicTime_1)","category":"page"},{"location":"man/tutorial_time_Seismicity/#.-Earthquakes-in-movie","page":"Create movies","title":"2. Earthquakes in movie","text":"","category":"section"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Create the folder TemporalSeismicity in the current folder and open the movie with the function Movie_Paraview.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"julia> using DelimitedFiles, GeophysicalModelGenerator, Dates\njulia> p2                  = @__FILE__;\njulia> p2last              = findlast(\"/\",p2);\njulia> p3                  = chop(p2,head=0,tail = length(p2)-p2last[1]+1);\njulia> output_path         = string(p3,\"/\");\njulia> movie               = Movie_Paraview(name=string(p3,\"/TemporalSeismicity\"), Initialize=true);\njulia> if isdir(string(p3,\"/TemporalSeismicity\"))==0\njulia>     mkdir(string(p3,\"/TemporalSeismicity\"));\njulia> end\n","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Now let's load the earthquake data provided as text files. The first column gives us a temporal marker we can use to plot earthquakes in different periods. We used the Date package to transform this time into dates.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"julia> data                = readdlm(\"SeismicLocations/Seismicity_UTM_1983_1984.txt\", '\\t', skipstart=0, header=false);\njulia> l                   = length(data[:,1]);\njulia> dates               = Date.(zeros(l,1))\njulia> for i = 1:l\njulia>     df              = DateFormat(\"yyyymmdd\");\njulia>     t1              = string(\"19\",@sprintf(\"%5.o\", data[i,1]));\njulia>     t2              = Date(t1[1:8],df);\njulia>     dates[i,1]      = t2;\njulia> end\njulia> WE                  = data[:,2];\njulia> SN                  = data[:,3];\njulia> depth               = data[:,4];\njulia> dates_num           = dates - dates[1];\n","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Select earthquakes every 50 days from the starting date (17/01/1983) and use them to create the frames for the video.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"julia> nt                  = 50;\njulia> dt                  = Dates.Day(nt);\njulia> t                   = minimum(dates):dt:maximum(dates);\njulia> for itime = 1:length(t)-1\njulia>    name            = string(p3,\"/TemporalSeismicity/\", string(itime));\njulia>    tt=findall(x->(x>=t[itime]) & (x<=t[itime+1]),dates);\njulia>    we             = WE[tt];\njulia>    sn             = SN[tt];\njulia>    Depth1          = depth[tt];\njulia>    DN              = dates_num[tt];\njulia>    label_time      = Dates.value(DN[end]);\njulia>    if size(tt,1)>1\njulia>        Data_set    = UTMData(we, sn, Depth1, 33, true, (Depth=Depth1*km,Timedata=DN));\njulia>        movie       = Write_Paraview(Data_set, name,pvd=movie,time=label_time,PointsData=true);\njulia>    end\njulia>end\njulia>Movie_Paraview(pvd=movie, Finalize=true)\n","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"This tutorial has created a new TemporalSeismicity.pvd that can be loaded in Paraview.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"(Image: Tutorial_SeismicTime_PVD)","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"Notice the animation panel, allowing you to run the video. You can select video speed by opening the Animation View under the View tab. Note that you can slow down the movie there if you need.","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"(Image: Tutorial_SeismicTime_Movie)","category":"page"},{"location":"man/tutorial_time_Seismicity/","page":"Create movies","title":"Create movies","text":"If you want to run the entire example, you can find the .jl code here","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#Import-profiles/maps-from-published-papers","page":"Import screenshots","title":"Import profiles/maps from published papers","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/#Goal","page":"Import screenshots","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Ideally, all data should be availabe in digital format, after which you could use the tools described in the other tutorial to transform them into GeoData and export them to VTK. Yet, the reality is different and often data is not (yet) available, or papers are old and the authors can no longer be contacted.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For that reason, GeophysicalModelGenerator has tools that allow you to transfer a screenshot from any published paper into GeoData/Paraview and see it in 3D at the correct geographic location. This can be done for vertical profiles and for mapviews, which gives you a quick and easy way to see those papers in a new (3D) light.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Here, we explain how. ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Import profiles/maps from published papers\nGoal\nGeneral procedure\n1. Download data and crop images\n2. Read data of a cross-section & create VTS file\n3. Read data of a mapview & create *.vts file\n4. Using an automatic digitizer to pick points on map\n5. Creating a multiblock Paraview/*.vtm file\n6. Julia script","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#General-procedure","page":"Import screenshots","title":"General procedure","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Download-data-and-crop-images","page":"Import screenshots","title":"1. Download data and crop images","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For this example, we use a well-known paper about the Alps which is now openly available:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Lippitsch, R., 2003. Upper mantle structure beneath the Alpine orogen from high-resolution teleseismic tomography. J. Geophys. Res. 108, 2376. https://doi.org/10.1029/2002JB002016","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Figure 12 contains a number of horizontal slices @ different depth, whereas Figure 13 contains 3 vertical profiles and a mapview that illustrates where the profile was taken. The first profile is shown here:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_1)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"The first step is to crop the image such that we only see the profile itself:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_2)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Read-data-of-a-cross-section-and-create-VTS-file","page":"Import screenshots","title":"2. Read data of a cross-section & create VTS file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"We look at the bigger image and determine the lon,lat,depth coordinates of the lower left and upper right corners of this image. We estimate this to be (well, in fact, Mark Handy knew the exact coordinates, which contain a typo in the paper but are correct in her PhD thesis):","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> Corner_LowerLeft  = ( 4.65, 45.73, -400.0)\njulia> Corner_UpperRight = (17.23, 43.80, 0.0)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once this is done, and we saved the picture under Lippitsch_Fig13a.png, you can transfer it into GeoData format with:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> using GeophysicalModelGenerator\njulia> data_profile1 = Screenshot_To_GeoData(\"Lippitsch_Fig13a.png\",Corner_LowerLeft, Corner_UpperRight)\nExtracting GeoData from: Lippitsch_Fig13a.png\n           └ Corners:         lon       lat       depth\n              └ lower left  = (4.65   , 45.73  ,  -400.0 )\n              └ lower right = (17.23  , 43.8   ,  -400.0 )\n              └ upper left  = (4.65   , 45.73  ,  0.0    )\n              └ upper right = (17.23  , 43.8   ,  0.0    )\nGeoData \n  size  : (325, 824, 1)\n  lon   ϵ [ 4.6499999999999995 : 17.230000000000004]\n  lat   ϵ [ 43.79999999999999 : 45.730000000000004]\n  depth ϵ [ -400.00000000000006 km : 0.0 km]\n  fields: (:colors,)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Finally, you save it in Paraview format as always:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> Write_Paraview(data_profile1, \"Lippitsch_Fig13a_profile\") ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"You can open this in paraview. Here, it is shown along with topographic data (made transparent):","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"(Image: Tutorial_ScreenShots_Lippitsch_1) Note that if you want to see the image with the original colors, you should unselect the Map Scalars option in the Properties tab (red ellipse).","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Read-data-of-a-mapview-and-create-*.vts-file","page":"Import screenshots","title":"3. Read data of a mapview & create *.vts file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Creating a map follows the same procedure. The only difference is that maps are sometimes distorted which means that the axis are not necessarily orthogonal in lon/lat space. In that case, you need to specify all 4 corners. Internally, we linearly interpolate between those values.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"An example is given here, which uses the mapview of Fig. 13 of the same paper (@ 150 km depth): (Image: Fig13_mapview)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Corner_LowerLeft    =   ( 3.5, 43.0 , -150.0)\nCorner_UpperRight   =   (15.5, 50.0 , -150.0)\nCorner_LowerRight   =   (15.5, 43.0 , -150.0)\nCorner_UpperLeft    =   (3.5 , 50.0 , -150.0)\ndata_Fig13_map      =   Screenshot_To_GeoData(\"Fig13_mapview.png\",Corner_LowerLeft, Corner_UpperRight, Corner_LowerRight=Corner_LowerRight,Corner_UpperLeft=Corner_UpperLeft)\nWrite_Paraview(data_Fig13_map, \"Lippitsch_Fig13_mapview\") ","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once added to paraview (together with a few additional map views from the same paper):   (Image: Tutorial_ScreenShots_Lippitsch_4)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Using-an-automatic-digitizer-to-pick-points-on-map","page":"Import screenshots","title":"4. Using an automatic digitizer to pick points on map","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Often, it is not straightforward to determine the begin/end points of a profile and have to guess that by looking at the mapview (which is inprecise). To help with that, you can digitize the map and use an automatic digitizer to pick points on the map.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"A great online tool to do exactly that can be found here: https://automeris.io/WebPlotDigitizer/","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For this, you need to create a screenshot that is slightly larger and includes the axis (or a scale bar). As an example, you can use the image Digitizer_1.png which you can download here https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/main/docs/src/assets/img/Digitizer_1.png.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"If import this in the online tool and indicate this to be a 2D (X-Y) Plot, it will ask us to pick 2 points on the X axis and 2 points on the Y axis: (Image: Digitizer_2)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Once the map is referenced accordingly, we can pick points (here for C' - C) and show the corresponding data values: (Image: Digitizer_3)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Which can again be used to set your profile.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Creating-a-multiblock-Paraview/*.vtm-file","page":"Import screenshots","title":"5. Creating a multiblock Paraview/*.vtm file","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"If you are importing a lot of cross-sections at the same time in Paraview, you end up having a lot of open profiles. For that reason it is possible to save a \"multi-block\" *.vtm file, which combines several files into one. The general approach is simple: open a multiblock file, and pass the filename to Write_Paraview. Once you are done, save it. An example showing you how this works is:","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> vtmfile = vtk_multiblock(\"Lippitsch_CrossSections\")\njulia> Write_Paraview(data_Fig12_90km, vtmfile) \njulia> Write_Paraview(data_Fig12_180km, vtmfile) \njulia> Write_Paraview(data_Fig12_300km, vtmfile) \njulia> Write_Paraview(data_Fig12_400km, vtmfile) \njulia> vtk_save(vtmfile)","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"Note that you have to create the cross-sections first (see the julia script below).","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/#.-Julia-script","page":"Import screenshots","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"For convenience we collected a few screenshots and uploaded it from https://seafile.rlp.net/d/a50881f45aa34cdeb3c0/.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"The full julia script that interprets all the figures is given here.","category":"page"},{"location":"man/tutorial_Screenshot_To_Paraview/","page":"Import screenshots","title":"Import screenshots","text":"julia> include(\"Lippitsch_Screenshots.jl\")","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/tutorial_GPS/#Plot-GPS-data","page":"Plot GPS vectors","title":"Plot GPS data","text":"","category":"section"},{"location":"man/tutorial_GPS/#Goal","page":"Plot GPS vectors","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The aim of this tutorial is to show you how you can download and plot GPS data, which are vector data.  The example is based on a paper by Sanchez et al. (2018) https://essd.copernicus.org/articles/10/1503/2018/#section7","category":"page"},{"location":"man/tutorial_GPS/#Steps","page":"Plot GPS vectors","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GPS/#.-Download-and-import-GPS-data:","page":"Plot GPS vectors","title":"1. Download and import GPS data:","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The data related to the paper can be downloaded from: https://doi.pangaea.de/10.1594/PANGAEA.886889 There you will find links to several data sets. Some are the data on the actual stations and some are interpolated data on a grid. Here, we will use the gridded data as an example (which interpolates the ), and will therefore download the following data sets:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"ALPS2017DEFHZ\tSurface deformation model of the Alpine Region\thttps://store.pangaea.de/Publications/Sanchez-etal2018/ALPS2017DEF_HZ.GRD\nALPS2017DEFVT\tVertical deformation model of the Alpine Region\thttps://store.pangaea.de/Publications/Sanchez-etal2018/ALPS2017DEF_VT.GRD","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we have a look at the data themselves. We will use the package CSV.jl to load the comma-separated data. Let's have a look at the file ALPS2017_DEF_VT.GRD. If we open it with a text editor, we see that the data starts at line 18, and has the following format:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Column 1: Longitude [degrees]\nColumn 2: Latitude [degrees]\nColumn 3: Velocity in the height direction [m/a]\nColumn 4: Uncertainty of the height component [m/a]\n\n\n 4.00    43.00    0.000067   0.000287\n 4.30    43.00   -0.001000   0.000616\n 4.60    43.00   -0.001067   0.000544","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So we have 4 columns with data values, and the data is separated by spaces. We can load that in julia as:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using CSV, GeophysicalModelGenerator\njulia> data_file =   CSV.File(\"ALPS2017_DEF_VT.GRD\",datarow=18,header=false,delim=' ');","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"We can read the numerical data from the file with:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> data                    =   ParseColumns_CSV_File(data_file, 4);     \njulia> lon_Vz, lat_Vz, Vz_vec  =   data[:,1], data[:,2], data[:,3];","category":"page"},{"location":"man/tutorial_GPS/#.-Check-and-reshape-vertical-velocity","page":"Plot GPS vectors","title":"2. Check & reshape vertical velocity","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Let's have a look at the data, by plotting it:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using Plots\njulia> Plots.scatter(lon_Vz,lat_Vz)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"(Image: Tutorial_GPS_1)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So clearly, this is a fully regular grid. We can determine the size of the grid with ","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> unique(lon_Vz)\n41-element Vector{Float64}:\n  4.0\n  4.3\n  4.6\n  4.9\n  5.2\n  5.5\n  5.8\n  ⋮\n 14.5\n 14.8\n 15.1\n 15.4\n 15.7\n 16.0\njulia> unique(lat_Vz)\n31-element Vector{Float64}:\n 43.0\n 43.2\n 43.4\n 43.6\n 43.8\n 44.0\n 44.2\n  ⋮\n 48.0\n 48.2\n 48.4\n 48.6\n 48.8\n 49.0","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So we have a 41 by 31 grid. GMG requires 3D matrixes for the data (as we want to plot the results in paraview in 3D). That is why we first initialize 3D matrixes for lon,lat,Vz:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> lon, lat, Vz            =   zeros(41,31,1),zeros(41,31,1),zeros(41,31,1)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"And we can reshape the vectors accordingly:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> lon[:,:,1]              =   reshape(lon_Vz,(41,31))\njulia> lat[:,:,1]              =   reshape(lat_Vz,(41,31))\njulia> Vz[:,:,1]               =   reshape(Vz_vec,(41,31))","category":"page"},{"location":"man/tutorial_GPS/#.-Load-horizontal-velocities","page":"Plot GPS vectors","title":"3. Load horizontal velocities","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we load the horizontal velocities from the file ALPS2017_DEF_HZ.GRD","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> data_file                       =   CSV.File(\"ALPS2017_DEF_HZ.GRD\",datarow=18,header=false,delim=' ');\njulia> data                            =   ParseColumns_CSV_File(data_file, 6);\njulia> lon_Hz, lat_Hz, Ve_Hz, Vn_Hz    =   data[:,1], data[:,2], data[:,3],  data[:,4];","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Let's plot the data as well:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Plots.scatter(lon_Hz,lat_Hz)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"(Image: Tutorial_GPS_2)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"So it appears that the horizontal velocities are given on the same regular grid as well, but not in the water.  This thus requires a bit more work. The strategy we take is to first define 2D matrixes with horizontal velocities with the same size as Vz which are initialized with NaN (not a number), which is treated specially by Paraview.","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Ve = ones(size(Vz))*NaN;\njulia> Vn = ones(size(Vz))*NaN;","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next we loop over all points in lon_Hz,lat_Hz and place them into the 2D matrixes:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia>  for i in eachindex(lon_Hz)\n            ind = intersect(findall(x->x==lon_Hz[i], lon), findall(x->x==lat_Hz[i], lat))\n            Ve[ind] .= Ve_Hz[i];\n            Vn[ind] .= Vn_Hz[i];\n        end","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage, we have horizontal and vertical velocities in units of m/yr. Yet, given the small velocities in the Alps, it makes more sense to have them in units of mm/yr:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Vz = Vz*1000;\njulia> Ve = Ve*1000;\njulia> Vn = Vn*1000;","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"And the magnitude is:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Vmagnitude  =   sqrt.(Ve.^2 + Vn.^2 + Vz.^2);  ","category":"page"},{"location":"man/tutorial_GPS/#.-Interpolate-topography-on-grid","page":"Plot GPS vectors","title":"4. Interpolate topography on grid","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage we have the 3D velocity components on a grid. Yet, we don't have information yet about the elevation of the stations (as the provided data set did not give this).  We could ignore that and set the elevation to zero, which would allow saving the data directly to paraview.","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Yet, a better way is to load the topographic map of the area and interpolate the elevation to the velocity grid. We are using the GMT.jl to load the topographic data:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using GMT\njulia> Elevation =   gmtread(\"@earth_relief_01m.grd\", limits=[3,17,42,50]);","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Next, we use the Interpolations.jl package to interpolate the topography:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> using Interpolations\njulia> interpol = LinearInterpolation((Elevation.x[1:end-1], Elevation.y[1:end-1]), Elevation.z');    \njulia> height   = interpol.(lon,lat)/1e3;","category":"page"},{"location":"man/tutorial_GPS/#.-Saving-and-plotting-in-Paraview","page":"Plot GPS vectors","title":"5. Saving and plotting in Paraview","text":"","category":"section"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"At this stage, we have all we need. As the velocity is a vector field, we need to save it as a data structure with 3 components. When saving to paraview, GMG internally does a vector transformation. As this transformation does not retain the east/north components of the velocity field, it is a good idea to save them as separate fields so we can color the vectors accordingly in Paraview. Also note that we do not attach units to the vector fields, but we do have them for the scalar fields:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> GPS_Sanchez_grid = GeoData(lon,lat,height,(Velocity_mm_year=(Ve,Vn,Vz),V_north=Vn*mm/yr, V_east=Ve*mm/yr, V_vertical=Vz*mm/yr, Vmagnitude = Vmagnitude*mm/yr, Topography = height*km))\nGeoData \n  size  : (41, 31, 1)\n  lon   ϵ [ 4.0 : 16.0]\n  lat   ϵ [ 43.0 : 49.0]\n  depth ϵ [ -2.6545 km : 3.426 km]\n  fields: (:Velocity_mm_year, :V_north, :V_east, :V_vertical, :Vmagnitude, :Topography)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Saving this to paraview is as always:","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"julia> Write_Paraview(GPS_Sanchez_grid, \"GPSAlps_Sanchez_2017_grid\")","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"Opening and plotting the vertical field gives: (Image: Tutorial_GPS_3)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"In order to plot the velocities as arrows, you need to select the Glyph tool (red circle). Also specify Velocity_mm_year () as both Orientation and Scale Array, and add 50 as scale factor. Once you push Apply it should look like: (Image: Tutorial_GPS_4)","category":"page"},{"location":"man/tutorial_GPS/","page":"Plot GPS vectors","title":"Plot GPS vectors","text":"The arrows can now be colored by the individual velocity components or its magnitude.","category":"page"},{"location":"man/gravity_code/#Gravity-code","page":"Gravity code","title":"Gravity code","text":"","category":"section"},{"location":"man/gravity_code/","page":"Gravity code","title":"Gravity code","text":"The voxGrav function allows for the voxel-based computation of Bouguer anomalies and gradients from a 3D density matrix.","category":"page"},{"location":"man/gravity_code/","page":"Gravity code","title":"Gravity code","text":"GeophysicalModelGenerator.voxGrav","category":"page"},{"location":"man/gravity_code/#GeophysicalModelGenerator.voxGrav","page":"Gravity code","title":"GeophysicalModelGenerator.voxGrav","text":"voxGrav(X::Array{Float64, 3}, Y::Array{Float64, 3}, Z::Array{Float64, 3}, RHO::Array{Float64, 3};\nrefMod=\"AVG\", lengthUnit=\"m\", rhoTol=1e-9, Topo=[], outName=\"Bouguer\", printing=true)\n\nComputes Bouguer anomalies and gradients  \n\nRequired arguments:  \nX,Y,Z:       3D matrices with the coordinates of the grid (X should vary in the first dimension, Y in the second, Z (vertical) in the thrid)  \nRHO:         3D matrix with the densitiy at each grid point [kg/m^3]  \n\nOptional arguments:  \nrefMod:      1D vector with the reference density for each depth  \n             Alternatively, the strings \"NE\", \"SE\", \"SW\", \"NW\", \"AVG\" can be used.  \n             In that case, one of the corners of `RHO` is used as reference model.  \n             In case of \"AVG\" the reference model is the average of each depth slice.  \nlengthUnit:  The unit of the coordinates and topography file. Either \"m\" or \"km\"  \nrhoTol:      density differences smaller than rhoTol will be ignored [kg/m^3]  \nTopo:        2D matrix with the topography of the surface (only relevant for the paraview output)  \noutName:     name of the paraview output (do not include file type)  \nprinting:    activate printing of additional information [true or false]\n\n\n\n\n\n","category":"function"},{"location":"man/installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"GeophysicalModelGenerator.jl is written in the julia programming language, which is an extremely powerful, modern, scientific computing language. Julia works on all major operating systems, is free, fast, and has a very active user basis (with many useful packages). In case you haven't heard about julia yet, you are not alone. Yet, perhaps a look at this or this article, which explains nicely why it has an enormous potential for computational geosciences as well.","category":"page"},{"location":"man/installation/#.-Install-julia","page":"Installation","title":"1. Install julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use then package you obviously need to install julia. We recommend downloading and installing binaries from the julia webpage.","category":"page"},{"location":"man/installation/#.-Install-Visual-Studio-Code","page":"Installation","title":"2. Install Visual Studio Code","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The julia files itself are text files (just like matlab scripts). You may want to edit or modify them at some stage, for which you can use any text editor for that. We prefer to use the freely available Visual Studio Code as it has a build-in terminal and is the comes with the (official) julia debugger (install the Julia extension for that).","category":"page"},{"location":"man/installation/#.-Getting-started-with-julia","page":"Installation","title":"3. Getting started with julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You start julia on the command line with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"kausb$ julia","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This will start the command-line interface of julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"From the julia prompt, you start the package manager by typing ]:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"(@v1.6) pkg> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"And you return to the command line with a backspace.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Also useful is that julia has a build-in terminal, which you can reach by typing ; on the command line:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia>;\nshell> ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In the shell, you can use the normal commands like listing the content of a directory, or the current path:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"shell> ls\nLICENSE         Manifest.toml   Project.toml    README.md       docs            src             test            tutorial\nshell> pwd\n/Users/kausb/.julia/dev/GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"As before, return to the main command line (called REPL) with a backspace.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you want to see help information for any julia function, type ? followed by the command.  An example for tan is:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"help?> tan\nsearch: tan tanh tand atan atanh atand instances transpose transcode contains UnitRange ReentrantLock StepRange StepRangeLen trailing_ones trailing_zeros\n\n  tan(x)\n\n  Compute tangent of x, where x is in radians.\n\n  ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  tan(A::AbstractMatrix)\n\n  Compute the matrix tangent of a square matrix A.\n\n  If A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise, the tangent is determined by calling exp.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> tan(fill(1.0, (2,2)))\n  2×2 Matrix{Float64}:\n   -1.09252  -1.09252\n   -1.09252  -1.09252","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you are in a directory that has a julia file (which have the extension *.jl), you can open that file with Visual Studio Code:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"shell> code runtests.jl","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Execute the file with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> include(\"runtests\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Note that you do not include the *.jl extension.","category":"page"},{"location":"man/installation/#.-Install-GeophysicalModelGenerator.jl","page":"Installation","title":"4. Install GeophysicalModelGenerator.jl","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to install GeophysicalModelGenerator.jl, start julia and go to the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> add GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This will automatically install various other packages it relies on (using the correct version).","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you want, you can test if it works on your machine by running the test suite in the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> test GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Note that we run these tests automatically on Windows, Linux and Mac every time we add a new feature to GeophysicalModelGenerator (using different julia versions). This Continuous Integration (CI) ensures that new features do not break others in the package. The results can be seen here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The installation of GMG only needs to be done once, and will precompile the package and all other dependencies.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you, at a later stage, want to upgrade to the latest version of GMG, you can type:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> update GeophysicalModelGenerator","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can load GeophysicalModelGenerator, for example to create cross-sections, with:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> using GeophysicalModelGenerator","category":"page"},{"location":"man/installation/#.-Other-useful-packages","page":"Installation","title":"5. Other useful packages","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"As you will work your way through the tutorials you will see that we often use external packages, for example to load ascii data files into julia. You will find detailed instructions in the respective tutorials. ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you already want to install some of those, here our favorites. Install them through the package manager:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"CSV: Read comma-separated data files into julia.  \nPlots: Create all kinds of plots in julia (quite an extensive package, but very useful to have). \nJLD2: This allows saving julia objects (such as a tomographic model) to a binary file and load it again at a later stage.\nGeodesy: Convert UTM coordinates to latitude/longitude/altitude.\nNetCDF: Read NetCDF files.\nGMT: A julia interface to the Generic Mapping Tools (GMT), which is a highly popular package to create (geophysical) maps. Note that installing GMT.jl is more complicated than installing the other packages listed above, as you first need to have a working version of GMT on your machine (it is not yet installed automatically). Installation instructions for Windows/Linux are on their webpage. On a mac, we made the best experiences by downloading the binaries from their webpage and not using a package manager to install GMT.","category":"page"},{"location":"man/visualise/#Visualisation","page":"Visualisation","title":"Visualisation","text":"","category":"section"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"The standard visualisation way of GMG is to generate Paraview (VTK) files & look at them there. Yet, often we just want to have a quick look at the data without opening a new program. For that reason, we created the Visualise widget, which uses GLMakie and allows you to explore the data.","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"It requires you to load both GLMakie and GeophysicalModelGenerator. A small example in which we load the tomography data of the alps is:","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> using GeophysicalModelGenerator, GLMakie\njulia> using GMT, JLD2","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"The last line loads packages we need to read in the pre-generated JLD2 file (see the tutorials) and download topography from the region. Lets load the data, by first moving to the correct directory (will likely be different on your machine).","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> ;\nshell> cd ~/Downloads/Zhao_etal_2016_data/      ","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"Now you can use the backspace key to return to the REPL, where we will load the data","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> Data = JLD2.load(\"Zhao_Pwave.jld2\",\"Data_set_Zhao2016_Vp\");    ","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"At this stage you can look at it with","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> Visualise(Data);    ","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"Note that this tends to take a while, the first time you do this (faster afterwards).","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"Let's add topography to the plot as well, which requires us to first load that:","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> Topo = ImportTopo([0,18,38,52], file=\"@earth_relief_01m.grd\");\njulia> Visualise(Data, Topography=Topo);    ","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"Which will look like: (Image: Tutorial_Visualize)","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"This is an example where we used GeoData to visualize results. Alternatively, we can also visualize results in km (often more useful for numerical modelling setups). For Visualize to work with this, we however need orthogonal cartesian data, which can be obtained by projecting both the data.","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> p=ProjectionPoint(Lon=10, Lat=45)\nProjectionPoint(45.0, 10.0, 578815.302916711, 4.983436768349297e6, 32, true)\njulia> Data_Cart  = CartData(XYZGrid(-600:10:600,-600:10:600,-1000:10:-1));\njulia> Topo_Cart  = CartData(XYZGrid(-600:10:600,-600:10:600,0));\njulia> Topo_Cart  = ProjectCartData(Topo_Cart, Topo, p)\nCartData \n    size    : (121, 121, 1)\n    x       ϵ [ -600.0 : 600.0]\n    y       ϵ [ -600.0 : 600.0]\n    z       ϵ [ -3.6270262031545473 : 3.654942280296281]\n    fields  : (:Topography,)\n  attributes: [\"note\"]\njulia> Data_Cart  = ProjectCartData(Data_Cart, Data, p)\nCartData \n    size    : (121, 121, 100)\n    x       ϵ [ -600.0 : 600.0]\n    y       ϵ [ -600.0 : 600.0]\n    z       ϵ [ -1000.0 : -10.0]\n    fields  : (:dVp_Percentage,)\n  attributes: [\"note\"]","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"And once we have done that, you can visualize the data in the same way:","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"julia> Visualise(Data_Cart, Topography=Topo_Cart)","category":"page"},{"location":"man/visualise/","page":"Visualisation","title":"Visualisation","text":"GeophysicalModelGenerator.Visualise","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#D-tomography-model-that-is-given-as-a-netCDF-file","page":"3D seismic tomography from netCDF","title":"3D tomography model that is given as a netCDF file","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#Goal","page":"3D seismic tomography from netCDF","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"This explains how to load a 3D seismic data set that is given in netCDF format, and plot it in paraview. The example is a shear-wave velocity model of the Alpine-Mediterranean region, described in:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"El-Sharkawy et al. (2020), The Slab Puzzle of the Alpine‐Mediterranean Region: Insights from a new, High‐Resolution, Shear‐Wave Velocity Model of the Upper Mantle, G^3 https://doi.org/10.1029/2020GC008993","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#Steps","page":"3D seismic tomography from netCDF","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Download-data","page":"3D seismic tomography from netCDF","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The data is can be downloaded from https://ds.iris.edu/files/products/emc/emc-files/El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc. Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Read-data-into-Julia","page":"3D seismic tomography from netCDF","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The main data-file, El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc, is given as netCDF file. To read in data of this type, it is necessary to load an appropriate package. Here, we will use the https://github.com/JuliaGeo/NetCDF.jl package. Download and install the package with:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using Pkg\njulia> Pkg.add(\"NetCDF\")","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"First, let us have a look at the contents of this file (assuming that you are in the same directory where the file is located):","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using NetCDF\njulia> ncinfo(\"El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc\")\n##### NetCDF File #####\n\n/Users/mthiel/PROJECTS/CURRENT/SPP2017/GeophysicalModelGenerator/InputData/El-Sharkawy/El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-0.0.nc\n\n##### Dimensions #####\n\nName                                                                            Length                                  \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                                                           301                                     \nlatitude                                                                        100                                     \nlongitude                                                                       100                                     \n\n##### Variables #####\n\nName                                            Type                    Dimensions                                      \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                           FLOAT                   depth                                           \nlatitude                                        FLOAT                   latitude                                        \nlongitude                                       FLOAT                   longitude                                       \nVs                                              FLOAT                   longitude latitude depth                        \n\n##### Attributes #####\n\nVariable                      Name                          Value                                                       \n--------------------------------------------------------------------------------------------------------------------------\nglobal                        author_email                  amr.elsharkawy@ifg.uni-kiel.de                              \nglobal                        data_revision                 r.0.0                                                       \nglobal                        author_institution            Institute of Geosciences, University of Kiel, Otto-Hahn Pl..\nglobal                        keywords                      seismic tomography, shear wave, Mediterranean, phase veloc..\nglobal                        acknowledgment                Model was provided by Dr. El-Sharkawy, Institute of Geosci..\nglobal                        history                       2020-09-29 14:37:43 UTC Converted to netCDF by GeoCSV_2_ne..\nglobal                        repository_pid                doi:10.17611/dp/emc.2020.meresvelsh.1                       \nglobal                        id                            MeRE2020                                                    \nglobal                        author_name                   Amr EL-Sharkawy                                             \nglobal                        comment                       model converted to netCDF by IRIS EMC                       \nglobal                        NCO                           netCDF Operators version 4.7.5 (Homepage = http://nco.sf.n..\nglobal                        summary                       MeRE2020 is a high-resolution Shearâwave velocity mod..\nglobal                        repository_institution        IRIS DMC                                                    \nglobal                        netCDF_file                   El-Sharkawy-etal-G3.2020-MeRE2020-Mediterranean-1.0.nc      \nglobal                        author_url                    https://www.seismologie.ifg.uni-kiel.de                     \nglobal                        reference                     El-Sharkawy, et al. (2020)                                  \nglobal                        repository_name               EMC                                                         \nglobal                        Conventions                   CF-1.0                                                      \nglobal                        Metadata_Conventions          Unidata Dataset Discovery v1.0                              \nglobal                        title                         The Slab Puzzle of the AlpineâMediterranean Region: I..\ndepth                         units                         km                                                          \ndepth                         long_name                     depth in km                                                 \ndepth                         display_name                  depth in km                                                 \ndepth                         positive                      down                                                        \nlatitude                      units                         degrees_north                                               \nlatitude                      long_name                     Latitude; positive north                                    \nlatitude                      standard_name                 latitude                                                    \nlongitude                     units                         degrees_east                                                \nlongitude                     long_name                     Longitude; positive east                                    \nlongitude                     standard_name                 longitude                                                   \nVs                            units                         km.s-1                                                      \nVs                            long_name                     Shear wave velocity                                         \nVs                            display_name                  S Velocity (km/s) ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"As you can see, there is quite some information present in this file. The most important information here are the different variables stored in this file:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"##### Variables #####\n\nName                                            Type                    Dimensions                                      \n--------------------------------------------------------------------------------------------------------------------------\ndepth                                           FLOAT                   depth                                           \nlatitude                                        FLOAT                   latitude                                        \nlongitude                                       FLOAT                   longitude                                       \nVs                                              FLOAT                   longitude latitude depth                        ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Here we can see that there are four variables in this file, three of them (depth,latitude, longitude) having a single dimension and the fourth one (Vs) having dimensions of the three previous variables. The three one-dimensional vectors therefore denote a regualr grid of coordinates defining the locations where Vs is stored.   To load this data, we can now simply use the commmand ncread:  ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> lat = ncread(filename,\"latitude\")\njulia> lon = ncread(filename,\"longitude\")\njulia> depth = ncread(filename,\"depth\")\njulia> Vs_3D = ncread(filename,\"Vs\")\njulia> depth = -1 .* depth ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Note that we multiplied depth with -1. This is necessary to make depth to be negative, as that is what GeophysicalModelGenerator.jl expects.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Reformat-the-coordinate-data","page":"3D seismic tomography from netCDF","title":"3. Reformat the coordinate data","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"In the netCDF file, coordinates are given as 1D vectors denoting the location of nodes in a regular grid. However, GeophysicalModelGenerator.jl expects true 3D data, where each data point is assigned a latitude,longitude, depth and the respective property (here: Vs). To generate this full regular 3D grid, do the following:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Lon3D,Lat3D,Depth3D = LonLatDepthGrid(lon, lat, depth);","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Generate-Paraview-file","page":"3D seismic tomography from netCDF","title":"4. Generate Paraview file","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Once the 3D coordinate matrix has been generated, producing a Paraview file is done with the following command ","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> using GeophysicalModelGenerator\njulia> Data_set    =   GeoData(Lon,Lat,Depth,(Vs_km_s=Vs_3D,))   \nGeoData \n  size  : (100, 100, 301)\n  lon   ϵ [ 29.0 - 51.0]\n  lat   ϵ [ -11.0 - 45.9900016784668]\n  depth ϵ [ -350.0 km - -50.0 km]\n  fields: (:Vs_km_s,) \njulia> Write_Paraview(Data_set, \"MeRe_ElSharkawy\")\n1-element Vector{String}:\n \"MeRe_ElSharkawy.vts\"","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Plotting-data-in-Paraview","page":"3D seismic tomography from netCDF","title":"5. Plotting data in Paraview","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"In paraview you can open the file and visualize it:","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"(Image: DataPoints_Paraview)","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"Note that we employ the perceptually uniform color map Barlow, which you can download here.","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"If you want to clip the data set @ 200 km depth, you need to select the Clip tool, select Sphere as a clip type, set the center to [0,0,0] and set the radius to 6171 (=radius earth - 200 km).","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"(Image: Tutorial_ElSharkawy_MeRe_DataPoints_Paraview_2)","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/#.-Julia-script","page":"3D seismic tomography from netCDF","title":"6. Julia script","text":"","category":"section"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"The full julia script that does it all is given here. You need to be in the same directory as in the data file, after which you can run it in julia with","category":"page"},{"location":"man/tutorial_loadregular3DSeismicData_netCDF/","page":"3D seismic tomography from netCDF","title":"3D seismic tomography from netCDF","text":"julia> include(\"MeRe_ElSharkawy.jl\")","category":"page"},{"location":"man/paraview_output/#Paraview-output","page":"Paraview output","title":"Paraview output","text":"","category":"section"},{"location":"man/paraview_output/","page":"Paraview output","title":"Paraview output","text":"We have one main routine to generate Paraview output for data that is either stored in a GeoData structure (that has lat/lon info), or ParaviewData (Cartesian). If GeoData is supplied it is internally automatically converted to the right format. Vectors, such as velocity, are also converted accordingly. You can also visualize time-dependent data.","category":"page"},{"location":"man/paraview_output/","page":"Paraview output","title":"Paraview output","text":"GeophysicalModelGenerator.Write_Paraview\nGeophysicalModelGenerator.Movie_Paraview","category":"page"},{"location":"man/paraview_output/#GeophysicalModelGenerator.Write_Paraview","page":"Paraview output","title":"GeophysicalModelGenerator.Write_Paraview","text":"pvd = Write_Paraview(DataSet::ParaviewData, filename=\"test\"; PointsData=false, pvd=nothing, time=nothing, directory=nothing)\n\nWrites a structure with Geodatato a paraview (or VTK) file. If you have unstructured points (e.g., earthquake data), setPointsData=true. In case you want to create a movie in Paraview, and this is a timestep of that movie you also have to passtimeandpvd`\n\nExample 1: Write a 3D volume\n\njulia> Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);\njulia> Data_set        =   GeoData(Lat,Lon,Depth,(Depthdata=Depth,LonData=Lon))  \njulia> Write_Paraview(Data_set, \"test_depth3D\")\n\nExample 2: Horizontal slice @ given depth\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  \njulia> Write_Paraview(Data_set, \"test\")\n\nExample 3: Case with topography\n\njulia> Lon,Lat,Depth    =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Depth[2:4,2:4,1] .=  25km     \njulia> Data_set         =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  \njulia> Write_Paraview(Data_set, \"test2\")\n\nExample 4: Profile\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,35,(-300:25:0)km);\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth,Depth=Depth))  \njulia> Write_Paraview(Data_set, \"test\")\n\nExample 5: Velocity vectors\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);\njulia> Ve, Vn, Vz     =   ones(size(Depth)), ones(size(Depth))*0.5, zeros(size(Depth));\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth, Velocity=(Ve,Vn,Vz)))\nGeoData \n  size  : (11, 11, 1)\n  lon   ϵ [ 30.0 - 40.0]\n  lat   ϵ [ 10.0 - 20.0]\n  depth ϵ [ 10.0 km - 10.0 km]\n  fields: (:DataSet, :Velocity)  \njulia> Write_Paraview(Data_set, \"test_Velocity\")\n\nExample 6: Unconnected points (e.g., earthquake locations)\n\nNote that these points should be 1D vectors.\n\njulia> Lon,Lat,Depth  =   LonLatDepthGrid(10:5:20,35:2:40,(-300:50:0)km);\njulia> Lon=Lon[:]; Lat=Lat[:]; Depth=Depth[:];\njulia> Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth[:],Depth=Depth*10));  \njulia> Write_Paraview(Data_set, \"test_Points\", PointsData=true)\n\n\n\n\n\nWrite_Paraview(DataSet::UTMData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing)\n\nWrites a UTMData structure to paraview. Note that this data is not transformed into an Earth-like framework, but remains cartesian instead. \n\n\n\n\n\nWrite_Paraview(DataSet::CartData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing)\n\nWrites a CartData structure to paraview. \n\n\n\n\n\n","category":"function"},{"location":"man/paraview_output/#GeophysicalModelGenerator.Movie_Paraview","page":"Paraview output","title":"GeophysicalModelGenerator.Movie_Paraview","text":"pvd = Movie_Paraview(; name=\"Movie\", pvd=pvd, Finalize::Bool=false, Initialize::Bool=true)\n\nIf you want to make a movie of your data set, you can use this routine to initialize and to finalize the movie-file. It will create a *.pvd file, which you can open in Paraview \n\nIndividual timesteps are added to the movie by passing pvd and the time of the timestep to the Write_Paraview routine.\n\nExample\n\nUsually this is used inside a *.jl script, as in this pseudo-example:\n\nmovie = Movie_Paraview(name=\"Movie\", Initialize=true)\nfor itime=1:10\n    name = \"test\"*string(itime)\n    movie = Write_Paraview(Data, name, pvd=movie, time=itime)\nend\nMovie_Paraview(pvd=movie, Finalize=true)\n\n\n\n\n\n","category":"function"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"EditURL = \"<unknown>/Tutorial_Votemaps.jl\"","category":"page"},{"location":"man/Tutorial_Votemaps/#Votemaps","page":"VoteMaps","title":"Votemaps","text":"","category":"section"},{"location":"man/Tutorial_Votemaps/#Aim","page":"VoteMaps","title":"Aim","text":"","category":"section"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"In this tutorial, your will learn how to create Votemaps that compare different tomographic models and look for similarities between different models.","category":"page"},{"location":"man/Tutorial_Votemaps/#Steps","page":"VoteMaps","title":"Steps","text":"","category":"section"},{"location":"man/Tutorial_Votemaps/#.-Load-data","page":"VoteMaps","title":"1. Load data","text":"","category":"section"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"We assume that you have all tomographic models already available as *.JLD2 files. In our example we use the data uploaded to https://seafile.rlp.net/d/22b0fb85550240758552/","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Specifically, we will use the tomographic models of Paffrath, Zhao and Koulakov, as we have them all available in processed form Download the corresponding *.jld2 files to the same directory","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"using JLD2, GeophysicalModelGenerator\n\nPwave_Zhao = load(\"Zhao_Pwave.jld2\",\"Data_set_Zhao2016_Vp\")\nPSwave_Koulakov = load(\"Koulakov_Europe.jld2\",\"DataKoulakov_Alps\")\nPwave_Paffrath = load(\"Paffrath_Pwave.jld2\",\"Data_set_Paffrath2021_Vp\")","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"The 3 data sets all contain tomographic models for roughly the alpine area, but as you can see, they all have a different resolution and the fields are sometimes called different as well:","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Pwave_Paffrath\nGeoData\n  size  : (162, 130, 42)\n  lon   ϵ [ -13.3019 : 35.3019]\n  lat   ϵ [ 30.7638 : 61.2362]\n  depth ϵ [ -606.0385 km : 31.0385 km]\n  fields: (:dVp_Percentage, :Vp, :Resolution)\n\nPSwave_Koulakov\n  GeoData\n  size  : (108, 81, 35)\n  lon   ϵ [ 4.0 : 20.049999999999997]\n  lat   ϵ [ 37.035928143712574 : 49.01197604790419]\n  depth ϵ [ -700.0 km : -10.0 km]\n  fields: (:dVp_percentage, :dVs_percentage)","category":"page"},{"location":"man/Tutorial_Votemaps/#.-Creating-a-Votemap","page":"VoteMaps","title":"2. Creating a Votemap","text":"","category":"section"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"The idea of Votemaps is rather simple:","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"assume that a certain perturbation describes a feature (say, P wave anomalies >3% are interpreted to be slabs in the model of Paffrath)\nEverything that fulfills this criteria gets the number 1, everything else 0.\nDo the same with other tomographic models (using the same criteria or a different one).\nMake sure that all tomographic models are interpolated to the same grid.\nSum up the 3 models.\nThe resulting 3D map will have the number 3 at locations where all 3 models see a high-velocity anomaly (say a slab), implying that this feature is consistent between all models. Features that have a number 1 or 2 are only seen in a single or in 2/3 models.","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"The result of this gives a feeling which features are consistent between the 3 models. It is ofcourse still subjective, as you still have to choose a criteria and as we are assuming in this that the 3 tomographic models are comparable (which they are not as they are produced using different amounts of datam, etc. etc.)","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"So how do we create Votemaps? Doing this is rather simple:","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Data_VoteMap = VoteMap( [Pwave_Paffrath,       PSwave_Koulakov,    Pwave_Zhao],\n                        [\"dVp_Percentage>3.0\",\"dVp_percentage>2.0\",\"dVp_Percentage>2.0\"], dims=(100,100,100))","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"This will look at the common lon,lat,depth ranges between all 3 models, interpret each of the models to a common grid of size (100,100,100) and apply each of the criteria specified The resulting GeoData struct looks like:","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"GeoData\n  size  : (100, 100, 100)\n  lon   ϵ [ 4.0 : 18.0]\n  lat   ϵ [ 38.0 : 49.01197604790419]\n  depth ϵ [ -606.0385 km : -10.0 km]\n  fields: (:VoteMap,)","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"And from this, we can generate profiles, visualize 3D features in Paraview etc. etc.","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Write_Paraview(Data_VoteMap, \"VoteMap_Alps\")","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"In paraview, this gives (Image: Tutorial_VoteMap)","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"You can ofcourse argue that newer tomographic models include more data & should therefore count more A simple way to take that into account is to list the model twice:","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Data_VoteMap = VoteMap( [Pwave_Paffrath,       Pwave_Paffrath,       PSwave_Koulakov,    Pwave_Zhao],\n                        [\"dVp_Percentage>3.0\",\"dVp_Percentage>3.0\", \"dVp_percentage>2.0\",\"dVp_Percentage>2.0\"],\n                        dims=(100,100,100))","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"Similarly, you could only look at a single model (even when that is perhaps easier done directly in paraview, where you can simply select a different isocontour value)","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"","category":"page"},{"location":"man/Tutorial_Votemaps/","page":"VoteMaps","title":"VoteMaps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/projection/#Projecting-and-converting-data","page":"Projection","title":"Projecting & converting data","text":"","category":"section"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Typically, you load a dataset by reading it into julia and either generating a GeoData structure (in case you have longitude/latitude/depth info), or as UTMData (in case the data is in UTM coordinates, which requires you to specify the zone & hemisphere).","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"If you write the data to Paraview, it is internally converted to a Paraview structure (which involves x,y,z Cartesian Earth-Centered-Earth-Fixed (ECEF) coordinates using the wgs84 ellipsoid). ","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Yet, if you do geodynamic calculations the chances are that the geodynamic code does not operate in spherical coordinates, but rather use cartesian ones. In that case you should transfer your data to the CartData structure, which requires you to specify a ProjectionPoint that is a point on the map that will later have the coordinates (0,0) in the CartData structure.","category":"page"},{"location":"man/projection/#.-Converting","page":"Projection","title":"1. Converting","text":"","category":"section"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Converting from one coordinate system to the other is straightforward. Let's use Europe as an example:","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> using GeophysicalModelGenerator, GMT\njulia> Topo = ImportTopo(lon = [-10, 45], lat=[25, 50], file=\"@earth_relief_20m\")\nGeoData \n  size  : (165, 75, 1)\n  lon   ϵ [ -10.0 : 44.666666666666664]\n  lat   ϵ [ 25.0 : 49.666666666666664]\n  depth ϵ [ -4.9855 km : 3.123 km]\n  fields: (:Topography,)\njulia> Write_Paraview(Topo,\"Topo\")\nSaved file: Topo.vts","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"The result is shown on the globe as:  (Image: Topo_Europe_GeoData)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"You can convert this to UTM zone as:","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> convert(UTMData, Topo)\nUTMData \n  UTM zone : 29-38 North\n    size   : (165, 75, 1)\n    EW     ϵ [ 197181.31221507967 : 769155.4572884373]\n    NS     ϵ [ 2.7649477474783654e6 : 5.505892073781423e6]\n    depth  ϵ [ -4985.5 m : 3123.0 m]\n    fields : (:Topography,)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"As the area is large, it covers a range of UTM zones (and every point has a UTM zone attached). Within each zone, the coordinates are approximately orthogonal. Plotting this to Paraview does not result in a sensible dataset.","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Yet, what we could do instead is show all data with respect to a single UTM zone. For this, we have to select a point around which we project (in this case more or less in the center):","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> p=ProjectionPoint(Lon=17.3, Lat=37.5)\nProjectionPoint(37.5, 17.3, 703311.4380385976, 4.152826288024972e6, 33, true)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Projecting the GeoData set using this projection point is done with:","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> Convert2UTMzone(Topo,p)\nUTMData \n  UTM zone : 33-33 North\n    size   : (165, 75, 1)\n    EW     ϵ [ -2.0750691599137965e6 : 3.581351293385453e6]\n    NS     ϵ [ 2.7649477474783654e6 : 5.938114212160672e6]\n    depth  ϵ [ -4985.5 m : 3123.0 m]\n    fields : (:Topography,)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Whereas this is now in UTM Data (in meters), it is distorted.  (Image: Topo_Europe_UTMData)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Often it is more convenient to have this in CartData, which is done in a similar manner:","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> Topo_Cart = Convert2CartData(Topo,p)\nCartData \n    size   : (165, 75, 1)\n    x      ϵ [ -2778.3805979523936 km : 2878.039855346856 km]\n    y      ϵ [ -1387.8785405466067 km : 1785.2879241356998 km]\n    z      ϵ [ -4.9855 km : 3.123 km]\n    fields : (:Topography,)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"This shows that the model is ~5600 by 3000 km. (Image: Topo_Europe_CartData)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Whereas this is ok to look at and compare with a LaMEM model setup, we cannot use it to perform internal calculations (or to generate a LaMEM model setup), because the x and y coordinates are distorted and not orthogonal. ","category":"page"},{"location":"man/projection/#.-Projecting-data","page":"Projection","title":"2. Projecting data","text":"","category":"section"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"For use with LaMEM, you would need an orthogonal cartesian grid. From the last command above we get some idea on the area, so we can create this:","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> Topo_Cart_orth  = CartData(XYZGrid(-2000:20:2000,-1000:20:1000,0))\nCartData \n    size   : (201, 101, 1)\n    x      ϵ [ -2000.0 km : 2000.0 km]\n    y      ϵ [ -1000.0 km : 1000.0 km]\n    z      ϵ [ 0.0 km : 0.0 km]\n    fields : (:Z,)","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"Next, we can project the topographic data (in GeoData format) on this orthogonal grid","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"julia> Topo_Cart_orth  = ProjectCartData(Topo_Cart_orth, Topo, p)\nCartData \n    size   : (201, 101, 1)\n    x      ϵ [ -2000.0 km : 2000.0 km]\n    y      ϵ [ -1000.0 km : 1000.0 km]\n    z      ϵ [ -4.485650671162607 km : 2.5909655318121865 km]\n    fields : (:Topography,)\njulia> Write_Paraview(Topo_Cart_orth,\"Topo_Cart_orth\");    ","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"(Image: Topo_Europe_CartData_Proj) So this interpolates the topographic data from the GeoData to the orthogonal cartesian grid (which can be used with LaMEM, for example).","category":"page"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"You can do similar projections with full 3D data sets or pointwise data. ","category":"page"},{"location":"man/projection/#.-List-of-functions","page":"Projection","title":"3. List of functions","text":"","category":"section"},{"location":"man/projection/","page":"Projection","title":"Projection","text":"GeophysicalModelGenerator.Convert2CartData\nGeophysicalModelGenerator.ProjectCartData\nGeophysicalModelGenerator.Convert2UTMzone","category":"page"},{"location":"man/projection/#GeophysicalModelGenerator.Convert2CartData","page":"Projection","title":"GeophysicalModelGenerator.Convert2CartData","text":"Convert2CartData(d::UTMData, proj::ProjectionPoint)\n\nConverts a UTMData structure to a CartData structure, which essentially transfers the dimensions to km\n\n\n\n\n\nConvert2CartData(d::GeoData, proj::ProjectionPoint)\n\nConverts a GeoData structure to a CartData structure, which essentially transfers the dimensions to km\n\n\n\n\n\n","category":"function"},{"location":"man/projection/#GeophysicalModelGenerator.ProjectCartData","page":"Projection","title":"GeophysicalModelGenerator.ProjectCartData","text":"d_cart = ProjectCartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)\n\nProjects all datafields from the GeoData struct d to the CartData struct d_cart, around the projection point p. d_cart must be an orthogonal cartesian grid (deformed doesn't work; use Convert2CartData(d, proj), where proj is a projection point in that case).\n\nNote:\n\nIf d_cart and d are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    \n\n\n\n\n\nd_cart = ProjectCartData(d_cart::CartData, d::UTMData, p::ProjectionPoint)\n\nProjects all datafields from the UTMData struct d to the CartData struct d_cart, around the projection point p.     d_cart must be an orthogonal cartesian grid (deformed doesn't work; use Convert2CartData(d, proj), where proj is a projection point in that case).\n\n# Note:    \n- If `d_cart` and `d` are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.\n\n\n\n\n\n","category":"function"},{"location":"man/projection/#GeophysicalModelGenerator.Convert2UTMzone","page":"Projection","title":"GeophysicalModelGenerator.Convert2UTMzone","text":"Convert2UTMzone(d::GeoData, p::ProjectionPoint)\n\nConverts a GeoData structure to fixed UTM zone, around a given ProjectionPoint       This useful to use real data as input for a cartesian geodynamic model setup (such as in LaMEM). In that case, we need to project map coordinates to cartesian coordinates.     One way to do this is by using UTM coordinates. Close to the ProjectionPoint the resulting coordinates will be rectilinear and distance in meters. The map distortion becomes larger the further you are away from the center.\n\n\n\n\n\nConvert2UTMzone(d::CartData, proj::ProjectionPoint)\n\nThis transfers a CartData dataset to a UTMData dataset, that has a single UTM zone. The point around which we project is ProjectionPoint\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_UTM/#Read-in-UTM-data","page":"Read UTM data","title":"Read in UTM data","text":"","category":"section"},{"location":"man/tutorial_UTM/#Goal","page":"Read UTM data","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"The aim of this tutorial is to show you how you can read in data that is given in UTM coordinates. The example we use is the 3D density model of the Alps derived by Spooner et al. (2010), which you can download following the link from","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"Spooner, Cameron; Scheck-Wenderoth, Magdalena; Götze, Hans-Jürgen; Ebbing, Jörg; Hetényi, György (2019): 3D ALPS: 3D Gravity Constrained Model of Density Distribution Across the Alpine Lithosphere. V. 2.0. GFZ Data Services. https://doi.org/10.5880/GFZ.4.5.2019.004","category":"page"},{"location":"man/tutorial_UTM/#Steps","page":"Read UTM data","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_UTM/#.-Download-and-import-UTM-data:","page":"Read UTM data","title":"1. Download and import UTM data:","text":"","category":"section"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"Download the data file 2019-004_Spooner_Lithospheric Mantle.txt from http://doi.org/10.5880/GFZ.4.5.2019.004 and make sure that you change to the directory using julia. If you open the data with a text editor, you'll see that it looks like:","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"# These data are freely available under the Creative Commons Attribution 4.0 International Licence (CC BY 4.0)\t\t\t\t\t\n# when using the data please cite as: \t\t\t\t\t\n# Spooner, Cameron; Scheck-Wenderoth, Magdalena; Götze, Hans-Jürgen; Ebbing, Jörg; Hetényi, György (2019): 3D Gravity Constrained Model of Density Distribution Across the Alpine Lithosphere. GFZ Data Services. http://doi.org/10.5880/GFZ.4.5.2019.004\nX COORD (UTM Zone 32N)\tY COORD (UTM Zone 32N)\tTOP (m.a.s.l)\tTHICKNESS (m)\tDENSITY (Kg/m3)\n286635\t4898615\t-24823.2533\t70418.125\t3305\n286635\t4918615\t-25443.48901\t69410.01563\t3305\n286635\t4938615\t-28025.24511\t66402.49219\t3305\n286635\t4958615\t-32278.13135\t61663.48438\t3305\n286635\t4978615\t-35885.5625\t57459.14063\t3305\n286635\t4998615\t-37270.9812\t55318.71094\t3305\n286635\t5018615\t-36134.30481\t55497.16406\t3305\n286635\t5038615\t-34866.0697\t55555.41406\t3305","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"So we have 5 columns with data values, and the data is separated by spaces. We can load that in julia as:","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> using DelimitedFiles, GeophysicalModelGenerator\njulia> data=readdlm(\"2019-004_Spooner_Lithospheric Mantle.txt\",skipstart=4)\n1023×5 Matrix{Float64}:\n 286635.0  4.89862e6  -24823.3  70418.1  3305.0\n 286635.0  4.91862e6  -25443.5  69410.0  3305.0\n 286635.0  4.93862e6  -28025.2  66402.5  3305.0\n 286635.0  4.95862e6  -32278.1  61663.5  3305.0\n      ⋮                                  \n 926635.0  5.45862e6  -35302.7  83215.6  3335.0\n 926635.0  5.47862e6  -34908.6  84203.0  3335.0\n 926635.0  5.49862e6  -34652.4  85398.3  3335.0","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"We can read the numerical data from the file with:","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> ew, ns, depth, thick, rho  =   data[:,1], data[:,2], data[:,3], data[:,4], data[:,5];","category":"page"},{"location":"man/tutorial_UTM/#.-Check-and-reshape-vertical-velocity","page":"Read UTM data","title":"2. Check & reshape vertical velocity","text":"","category":"section"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"The data is initially available as 1D columns, which needs to be reshaped into 2D arrays.  We first reshape it into 2D arrays (using reshape). Yet, if we later want to visualize a perturbed surface in paraview, we need to save this as a 3D array (with 1 as 3rd dimension).","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> res = ( length(unique(ns)), length(unique(ew)), 1)\njulia> EW  =  reshape(ew,res) \njulia> NS  =  reshape(ns,res)\njulia> Depth =  reshape(depth,res)\njulia> T     =  reshape(thick,res)\njulia> Rho   =  reshape(rho,res)","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"Next we can examine EW: ","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> EW\n31×33×1 Array{Float64, 3}:\n[:, :, 1] =\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0  …  826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n      ⋮                                                 ⋮              ⋱                                     ⋮              \n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0     826635.0  846635.0  866635.0  886635.0  906635.0  926635.0\n 286635.0  306635.0  326635.0  346635.0  366635.0  386635.0  406635.0  …  826635.0  846635.0  866635.0  886635.0  906635.0  926635.0","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"So, on fact, the EW array varies in the 2nd dimension. It should, however, vary in the first dimension which is why we need to apply a permutation & switch the first and second dimensions:","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> EW  =  permutedims(EW,[2 1 3]) \njulia> NS  =  permutedims(NS,[2 1 3]) \njulia> Depth =  permutedims(Depth,[2 1 3]) \njulia> T     =  permutedims(T,[2 1 3]) \njulia> Rho   =  permutedims(Rho,[2 1 3]) ","category":"page"},{"location":"man/tutorial_UTM/#.-Create-UTMData-structure","page":"Read UTM data","title":"3. Create UTMData structure","text":"","category":"section"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"Next we can add the data to the UTMData structure. In this, we use the information that the UTM zone was 32 North.","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> Data_LM = UTMData(EW,NS,Depth,32, true, (Thickness=T/1e3*km, Density=Rho*kg/m^3 ))\nUTMData \n  UTM zone : 32-32 North\n    size   : (33, 31, 1)\n    EW     ϵ [ 286635.0 : 926635.0]\n    NS     ϵ [ 4.898615e6 : 5.498615e6]\n    depth  ϵ [ -52579.56788 m : -20873.400850000003 m]\n    fields : (:Thickness, :Density)","category":"page"},{"location":"man/tutorial_UTM/#.-Saving-and-plotting-in-Paraview","page":"Read UTM data","title":"4. Saving and plotting in Paraview","text":"","category":"section"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"We can transfer this into a GeoData structure as:","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> Data_LM_lonlat = convert(GeoData,Data_LM)\nGeoData \n  size  : (33, 31, 1)\n  lon   ϵ [ 6.046903388679526 : 14.892535147436673]\n  lat   ϵ [ 44.11618022783332 : 49.64004892531006]\n  depth ϵ [ -52.57956788 km : -20.873400850000003 km]\n  fields: (:Thickness, :Density)","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"and save it to Paraview in the usual way","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"julia> Write_Paraview(Data_LM_lonlat, \"Data_LM_lonlat\")","category":"page"},{"location":"man/tutorial_UTM/","page":"Read UTM data","title":"Read UTM data","text":"Opening and plotting the vertical field gives: (Image: Tutorial_UTM)","category":"page"},{"location":"man/lamem/#LaMEM","page":"LaMEM","title":"LaMEM","text":"","category":"section"},{"location":"man/lamem/","page":"LaMEM","title":"LaMEM","text":"In order to generate geodynamic simulations from setups created with GeophysicalModelGenerator.jl, we provide a few routines that directly create marker input files for the 3D geodynamic modelling software LaMEM, which is an open-source cartesian code that is well-suited to perform crustal and lithospheric-scale simulations.  If you want to learn how to run LaMEM simulations, please have a look at the wiki page. ","category":"page"},{"location":"man/lamem/","page":"LaMEM","title":"LaMEM","text":"The routines provided here have the following functionality:","category":"page"},{"location":"man/lamem/","page":"LaMEM","title":"LaMEM","text":"Read LaMEM *.dat files (to get the size of the domain)\nRead LaMEM processor partitioning file\nAdd lithospheric boxes to a setup, that may have a layered structure and various thermal structures\nSave LaMEM marker files in serial or in parallel\nRead a LaMEM timestep","category":"page"},{"location":"man/lamem/","page":"LaMEM","title":"LaMEM","text":"GeophysicalModelGenerator.ReadLaMEM_InputFile\nGeophysicalModelGenerator.GetProcessorPartitioning\nGeophysicalModelGenerator.Save_LaMEMTopography\nGeophysicalModelGenerator.Save_LaMEMMarkersParallel\nGeophysicalModelGenerator.ReadData_PVTR\nGeophysicalModelGenerator.AddBox!\nGeophysicalModelGenerator.AddSphere!\nGeophysicalModelGenerator.AddEllipsoid!\nGeophysicalModelGenerator.AddCylinder!\nGeophysicalModelGenerator.makeVolcTopo\nGeophysicalModelGenerator.ConstantTemp\nGeophysicalModelGenerator.LinearTemp\nGeophysicalModelGenerator.HalfspaceCoolingTemp\nGeophysicalModelGenerator.SpreadingRateTemp\nGeophysicalModelGenerator.ConstantPhase\nGeophysicalModelGenerator.Compute_Phase\nGeophysicalModelGenerator.LithosphericPhases\nGeophysicalModelGenerator.LaMEM_grid\nGeophysicalModelGenerator.CreatePartitioningFile","category":"page"},{"location":"man/lamem/#GeophysicalModelGenerator.ReadLaMEM_InputFile","page":"LaMEM","title":"GeophysicalModelGenerator.ReadLaMEM_InputFile","text":"Grid::LaMEM_grid = ReadLaMEM_InputFile(file)\n\nParses a LaMEM input file and stores grid information in the Grid structure.\n\nExample\n\njulia> Grid = ReadLaMEM_InputFile(\"SaltModels.dat\") \nLaMEM Grid: \nnel         : (32, 32, 32)\nmarker/cell : (3, 3, 3)\nmarkers     : (96, 96, 96)\nx           ϵ [-3.0 : 3.0]\ny           ϵ [-2.0 : 2.0]\nz           ϵ [-2.0 : 0.0]\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.GetProcessorPartitioning","page":"LaMEM","title":"GeophysicalModelGenerator.GetProcessorPartitioning","text":"nProcX,nProcY,nProcZ, xc,yc,zc, nNodeX,nNodeY,nNodeZ = GetProcessorPartitioning(filename)\n\nReads a LaMEM processor partitioning file, used to create marker files, and returns the parallel layout \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.Save_LaMEMTopography","page":"LaMEM","title":"GeophysicalModelGenerator.Save_LaMEMTopography","text":"Save_LaMEMTopography(Topo::CartData, filename::String)\n\nThis writes a topography file Topo for use in LaMEM, which should have size (nx,ny,1) and contain the field :Topography \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.Save_LaMEMMarkersParallel","page":"LaMEM","title":"GeophysicalModelGenerator.Save_LaMEMMarkersParallel","text":"Save_LaMEMMarkersParallel(Grid::CartData; PartitioningFile=empty, directory=\"./markers\", verbose=true)\n\nSaves a LaMEM marker file from the CartData structure Grid. It must have a field called Phases, holding phase information (as integers) and optionally a field Temp with temperature info.  It is possible to provide a LaMEM partitioning file PartitioningFile. If not, output is assumed to be for one processor.\n\nThe size of Grid should be consistent with what is provided in the LaMEM input file. In practice, the size of the mesh can be retrieved from a LaMEM input file using ReadLaMEM_InputFile.\n\nExample\n\njulia> Grid    = ReadLaMEM_InputFile(\"LaMEM_input_file.dat\")\njulia> Phases  = zeros(Int32,size(Grid.X));\njulia> Temp    = ones(Float64,size(Grid.X));\njulia> Model3D = CartData(Grid, (Phases=Phases,Temp=Temp))\njulia> Save_LaMEMMarkersParallel(Model3D)\nWriting LaMEM marker file -> ./markers/mdb.00000000.dat\n\nIf you want to create a LaMEM input file for multiple processors:\n\njulia> Save_LaMEMMarkersParallel(Model3D, PartitioningFile=\"ProcessorPartitioning_4cpu_1.2.2.bin\")\nWriting LaMEM marker file -> ./markers/mdb.00000000.dat\nWriting LaMEM marker file -> ./markers/mdb.00000001.dat\nWriting LaMEM marker file -> ./markers/mdb.00000002.dat\nWriting LaMEM marker file -> ./markers/mdb.00000003.dat\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.ReadData_PVTR","page":"LaMEM","title":"GeophysicalModelGenerator.ReadData_PVTR","text":"Data::ParaviewData = ReadData_PVTR(fname, dir)\n\nReads a parallel, rectilinear, *.vts file with the name fname and located in dir and create a 3D Data struct from it.\n\nExample\n\njulia> Data = ReadData_PVTR(\"Haaksbergen.pvtr\", \"./Timestep_00000005_3.35780500e-01/\")\nParaviewData \n  size  : (33, 33, 33)\n  x     ϵ [ -3.0 : 3.0]\n  y     ϵ [ -2.0 : 2.0]\n  z     ϵ [ -2.0 : 0.0]\n  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.AddBox!","page":"LaMEM","title":"GeophysicalModelGenerator.AddBox!","text":"AddBox!(Phase, Temp, Grid::AbstractGeneralGrid; xlim=Tuple{2}, [ylim=Tuple{2}], zlim=Tuple{2},\n        Origin=nothing, StrikeAngle=0, DipAngle=0,\n        phase = ConstantPhase(1),\n        T=nothing )\n\nAdds a box with phase & temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models\n\nParameters\n\nPhase - Phase array (consistent with Grid)\nTemp  - Temperature array (consistent with Grid)\nGrid -  grid structure (usually obtained with ReadLaMEM_InputFile, but can also be other grid types)\nxlim -  left/right coordinates of box\nylim -  front/back coordinates of box [optional; if not specified we use the whole box]\nzlim -  bottom/top coordinates of box\nOrigin - the origin, used to rotate the box around. Default is the left-front-top corner\nStrikeAngle - strike angle of slab\nDipAngle - dip angle of slab\nphase - specifies the phase of the box. See ConstantPhase(),LithosphericPhases() \nT - specifies the temperature of the box. See ConstantTemp(),LinearTemp(),HalfspaceCoolingTemp(),SpreadingRateTemp() \n\nExamples\n\nExample 1) Box with constant phase and temperature & a dip angle of 10 degrees:\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\nLaMEM Grid: \n  nel         : (32, 32, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (96, 96, 96)\n  x           ϵ [-3.0 : 3.0]\n  y           ϵ [-2.0 : 2.0]\n  z           ϵ [-2.0 : 0.0]\njulia> Phases = zeros(Int32,   size(Grid.X));\njulia> Temp   = zeros(Float64, size(Grid.X));\njulia> AddBox!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))\njulia> Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model\njulia> Write_Paraview(Model3D,\"LaMEM_ModelSetup\")           # Save model to paraview \n1-element Vector{String}:\n \"LaMEM_ModelSetup.vts\"   \n\nExample 2) Box with halfspace cooling profile\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\njulia> Phases = zeros(Int32,   size(Grid.X));\njulia> Temp   = zeros(Float64, size(Grid.X));\njulia> AddBox!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))\njulia> Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model\njulia> Write_Paraview(Model3D,\"LaMEM_ModelSetup\")           # Save model to paraview \n1-element Vector{String}:\n \"LaMEM_ModelSetup.vts\"   \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.AddSphere!","page":"LaMEM","title":"GeophysicalModelGenerator.AddSphere!","text":"AddSphere!(Phase, Temp, Grid::AbstractGeneralGrid; cen=Tuple{3}, radius=Tuple{1},\n        phase = ConstantPhase(1).\n        T=nothing )\n\nAdds a sphere with phase & temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models\n\nParameters\n\nPhase - Phase array (consistent with Grid)\nTemp  - Temperature array (consistent with Grid)\nGrid - LaMEM grid structure (usually obtained with ReadLaMEM_InputFile)\ncen - center coordinates of sphere\nradius - radius of sphere\nphase - specifies the phase of the box. See ConstantPhase(),LithosphericPhases() \nT - specifies the temperature of the box. See ConstantTemp(),LinearTemp(),HalfspaceCoolingTemp(),SpreadingRateTemp() \n\nExample\n\nSphere with constant phase and temperature:\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\nLaMEM Grid: \n  nel         : (32, 32, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (96, 96, 96)\n  x           ϵ [-3.0 : 3.0]\n  y           ϵ [-2.0 : 2.0]\n  z           ϵ [-2.0 : 0.0]\njulia> Phases = zeros(Int32,   size(Grid.X));\njulia> Temp   = zeros(Float64, size(Grid.X));\njulia> AddSphere!(Phases,Temp,Grid, cen=(0,0,-1), radius=0.5, phase=ConstantPhase(2), T=ConstantTemp(800))\njulia> Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model\njulia> Write_Paraview(Model3D,\"LaMEM_ModelSetup\")           # Save model to paraview \n1-element Vector{String}:\n \"LaMEM_ModelSetup.vts\"   \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.AddEllipsoid!","page":"LaMEM","title":"GeophysicalModelGenerator.AddEllipsoid!","text":"AddEllipsoid!(Phase, Temp, Grid::AbstractGeneralGrid; cen=Tuple{3}, axes=Tuple{3},\n        Origin=nothing, StrikeAngle=0, DipAngle=0,\n        phase = ConstantPhase(1).\n        T=nothing )\n\nAdds an Ellipsoid with phase & temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models\n\nParameters\n\nPhase - Phase array (consistent with Grid)\nTemp  - Temperature array (consistent with Grid)\nGrid - LaMEM grid structure (usually obtained with ReadLaMEM_InputFile)\ncen - center coordinates of sphere\naxes - semi-axes of ellipsoid in X,Y,Z\nOrigin - the origin, used to rotate the box around. Default is the left-front-top corner\nStrikeAngle - strike angle of slab\nDipAngle - dip angle of slab\nphase - specifies the phase of the box. See ConstantPhase(),LithosphericPhases() \nT - specifies the temperature of the box. See ConstantTemp(),LinearTemp(),HalfspaceCoolingTemp(),SpreadingRateTemp() \n\nExample\n\nEllipsoid with constant phase and temperature, rotated 90 degrees and tilted by 45 degrees:\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\nLaMEM Grid: \n  nel         : (32, 32, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (96, 96, 96)\n  x           ϵ [-3.0 : 3.0]\n  y           ϵ [-2.0 : 2.0]\n  z           ϵ [-2.0 : 0.0]\njulia> Phases = zeros(Int32,   size(Grid.X));\njulia> Temp   = zeros(Float64, size(Grid.X));\njulia> AddEllipsoid!(Phases,Temp,Grid, cen=(-1,-1,-1), axes=(0.2,0.1,0.5), StrikeAngle=90, DipAngle=45, phase=ConstantPhase(3), T=ConstantTemp(600))\njulia> Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model\njulia> Write_Paraview(Model3D,\"LaMEM_ModelSetup\")           # Save model to paraview \n1-element Vector{String}:\n \"LaMEM_ModelSetup.vts\"   \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.AddCylinder!","page":"LaMEM","title":"GeophysicalModelGenerator.AddCylinder!","text":"AddCylinder!(Phase, Temp, Grid::AbstractGeneralGrid; base=Tuple{3}, cap=Tuple{3}, radius=Tuple{1},\n        phase = ConstantPhase(1).\n        T=nothing )\n\nAdds a cylinder with phase & temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models\n\nParameters\n\nPhase - Phase array (consistent with Grid)\nTemp  - Temperature array (consistent with Grid)\nGrid - Grid structure (usually obtained with ReadLaMEM_InputFile)\nbase - center coordinate of bottom of cylinder\ncap - center coordinate of top of cylinder\nradius - radius of the cylinder\nphase - specifies the phase of the box. See ConstantPhase(),LithosphericPhases() \nT - specifies the temperature of the box. See ConstantTemp(),LinearTemp(),HalfspaceCoolingTemp(),SpreadingRateTemp() \n\nExample\n\nCylinder with constant phase and temperature:\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\nLaMEM Grid: \n  nel         : (32, 32, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (96, 96, 96)\n  x           ϵ [-3.0 : 3.0]\n  y           ϵ [-2.0 : 2.0]\n  z           ϵ [-2.0 : 0.0]\njulia> Phases = zeros(Int32,   size(Grid.X));\njulia> Temp   = zeros(Float64, size(Grid.X));\njulia> AddCylinder!(Phases,Temp,Grid, base=(-1,-1,-1.5), cap=(1,1,-0.5), radius=0.25, phase=ConstantPhase(4), T=ConstantTemp(400))\njulia> Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model\njulia> Write_Paraview(Model3D,\"LaMEM_ModelSetup\")           # Save model to paraview \n1-element Vector{String}:\n \"LaMEM_ModelSetup.vts\"   \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.makeVolcTopo","page":"LaMEM","title":"GeophysicalModelGenerator.makeVolcTopo","text":"makeVolcTopo(Grid::LaMEM_grid; center::Array{Float64, 1}, height::Float64, radius::Float64, crater::Float64,             base=0.0m, background=nothing)\n\nCreates a generic volcano topography (cones and truncated cones)\n\nParameters\n\nGrid - LaMEM grid (created by ReadLaMEM_InputFile)\ncenter - x- and -coordinates of center of volcano\nheight - height of volcano\nradius - radius of volcano\n\nOptional Parameters\n\ncrater - this will create a truncated cone and the option defines the radius of the flat top\nbase - this sets the flat topography around the volcano\nbackground - this allows loading in a topography and only adding the volcano on top (also allows stacking of several cones to get a volcano with different slopes)\n\nExample\n\nCylinder with constant phase and temperature:\n\njulia> Grid = ReadLaMEM_InputFile(\"test_files/SaltModels.dat\")\nLaMEM Grid: \n  nel         : (32, 32, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (96, 96, 96)\n  x           ϵ [-3.0 : 3.0]\n  y           ϵ [-2.0 : 2.0]\n  z           ϵ [-2.0 : 0.0]\njulia> Topo = makeVolcTopo(Grid, center=[0.0,0.0], height=0.4, radius=1.5, crater=0.5, base=0.1)\nCartData \n    size    : (33, 33, 1)\n    x       ϵ [ -3.0 : 3.0]\n    y       ϵ [ -2.0 : 2.0]\n    z       ϵ [ 0.1 : 0.4]\n    fields  : (:Topography,)\n  attributes: [\"note\"]\njulia> Topo = makeVolcTopo(Grid, center=[0.0,0.0], height=0.8, radius=0.5, crater=0.0, base=0.4, background=Topo.fields.Topography)\nCartData \n    size    : (33, 33, 1)\n    x       ϵ [ -3.0 : 3.0]\n    y       ϵ [ -2.0 : 2.0]\n    z       ϵ [ 0.1 : 0.8]\n    fields  : (:Topography,)\n  attributes: [\"note\"]\njulia> Write_Paraview(Topo,\"VolcanoTopo\")           # Save topography to paraview \nSaved file: VolcanoTopo.vts  \n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.ConstantTemp","page":"LaMEM","title":"GeophysicalModelGenerator.ConstantTemp","text":"ConstantTemp(T=1000)\n\nSets a constant temperature inside the box\n\nParameters\n\nT : the value\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.LinearTemp","page":"LaMEM","title":"GeophysicalModelGenerator.LinearTemp","text":"LinearTemp(Ttop=0, Tbot=1000)\n\nSet a linear temperature structure from top to bottom\n\nParameters\n\nTtop : the value @ the top\nTbot : the value @ the bottom\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.HalfspaceCoolingTemp","page":"LaMEM","title":"GeophysicalModelGenerator.HalfspaceCoolingTemp","text":"HalfspaceCoolingTemp(Tsurface=0, Tmantle=1350, Age=60, Adiabat=0)\n\nSets a halfspace temperature structure in plate\n\nParameters\n\nTsurface : surface temperature [C]\nTmantle : mantle temperature [C]\nAge : Thermal Age of plate [Myrs]\nAdiabat : Mantle Adiabat [K/km]\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.SpreadingRateTemp","page":"LaMEM","title":"GeophysicalModelGenerator.SpreadingRateTemp","text":"SpreadingRateTemp(Tsurface=0, Tmantle=1350, Adiabat=0, MORside=\"left\",SpreadingVel=3, AgeRidge=0, maxAge=80)\n\nSets a halfspace temperature structure within the box, combined with a spreading rate (which implies that the plate age varies)\n\nParameters\n\nTsurface : surface temperature [C]\nTmantle : mantle temperature [C]\nAdiabat : Mantle Adiabat [K/km]\nMORside : side of the box where the MOR is located [\"left\",\"right\",\"front\",\"back\"]\nSpreadingVel : spreading velocity [cm/yr]\nAgeRidge : thermal age of the ridge [Myrs]\nmaxAge : maximum thermal Age of plate [Myrs]\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.ConstantPhase","page":"LaMEM","title":"GeophysicalModelGenerator.ConstantPhase","text":"ConstantPhase(phase=1)\n\nSets a constant phase inside the box\n\nParameters\n\nphase : the value\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.Compute_Phase","page":"LaMEM","title":"GeophysicalModelGenerator.Compute_Phase","text":"Phase = Compute_Phase(Phase, Temp, X, Y, Z, s::LithosphericPhases, Ztop)\n\nor\n\nPhase = Compute_Phase(Phase, Temp, Grid::AbstractGeneralGrid, s::LithosphericPhases)\n\nThis copies the layered lithosphere onto the Phase matrix.\n\nParameters\n\nPhase - Phase array\nTemp  - Temperature array\nX     - x-coordinate array (consistent with Phase and Temp)\nY     - y-coordinate array (consistent with Phase and Temp)\nZ     - Vertical coordinate array (consistent with Phase and Temp)\ns     - LithosphericPhases\nZtop  - Vertical coordinate of top of model box\nGrid  - Grid structure (usually obtained with ReadLaMEM_InputFile)\n\n\n\n\n\n","category":"function"},{"location":"man/lamem/#GeophysicalModelGenerator.LithosphericPhases","page":"LaMEM","title":"GeophysicalModelGenerator.LithosphericPhases","text":"LithosphericPhases(Layers=[10 20 15], Phases=[1 2 3 4], Tlab=nothing )\n\nThis allows defining a layered lithosphere. Layering is defined from the top downwards.\n\nParameters\n\nLayers : The thickness of each layer, ordered from top to bottom. The thickness of the last layer does not have to be specified.\nPhases : The phases of the layers, ordered from top to bottom.\nTlab   : Temperature of the lithosphere asthenosphere boundary. If specified, the phases at locations with T>Tlab are set to Phases[end].\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.LaMEM_grid","page":"LaMEM","title":"GeophysicalModelGenerator.LaMEM_grid","text":"Structure that holds information about the LaMEM grid (usually read from an input file).\n\n\n\n\n\n","category":"type"},{"location":"man/lamem/#GeophysicalModelGenerator.CreatePartitioningFile","page":"LaMEM","title":"GeophysicalModelGenerator.CreatePartitioningFile","text":"CreatePartitioningFile(LaMEM_input::String, NumProc::Int64; LaMEM_dir::String=pwd(), LaMEM_options::String=\"\", MPI_dir=\"\")\n\nThis executes LaMEM for the input file LaMEM_input & creates a parallel partitioning file for NumProc processors. The directory where the LaMEM binary is can be specified; if not it is assumed to be in the current directory. Likewise for the mpiexec directory (if not specified it is assumed to be available on the command line).\n\n\n\n\n\n","category":"function"},{"location":"man/tutorial_GMT_Topography/#Extract-topographic-data-from-GMT.jl","page":"Create GMT-based topography","title":"Extract topographic data from GMT.jl","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/#Goal","page":"Create GMT-based topography","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"In many cases, we want to add topographic data as well to our visualization. This tutorial shows how to use GMT.jl to download data from a certain region, and transfer that.","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"note: Note\nIt may be tricky to get GMT.jl installed and working correctly on your system (at least until someone prevides a BinaryBuilder package for julia, that is). You first need to have a working version of GMT on your system and only after that, you can install GMT.jl. See the installation instructions on their webpage for details.   On a MacBook Pro, a tested procedure to install GMT and to make it work with julia is to directly install the binaries for Julia, GMT (and possibly Ghostscript) and not use any package manager (such as spack or homebrew). ","category":"page"},{"location":"man/tutorial_GMT_Topography/#Steps","page":"Create GMT-based topography","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/#.-Download-topographic-data-of-the-Alpine-region","page":"Create GMT-based topography","title":"1. Download topographic data of the Alpine region","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The nice thing about GMT is that it automatically downloads data for you for a certain region and with a certain resolution. As this is a routine that you may use often in your daily workflow, we added the function ImportTopo that simplifies this. Note that this function only is available once GMT is loaded. ","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"julia> using GeophysicalModelGenerator, GMT\njulia> Topo = ImportTopo([4,20,37,49], file=\"@earth_relief_01m.grd\")\nGeoData \n  size  : (960, 720, 1)\n  lon   ϵ [ 4.0 : 19.983333333333334]\n  lat   ϵ [ 37.0 : 48.983333333333334]\n  depth ϵ [ -3.8725 km : 4.2495 km]\n  fields: (:Topography,)","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The data is available in different resolutions; see here for an overview. Generally, it is advisable to not use the largest resolution if you have a large area. ","category":"page"},{"location":"man/tutorial_GMT_Topography/#.-Save","page":"Create GMT-based topography","title":"2. Save","text":"","category":"section"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"Transforming this to Paraview is a piece of cake:","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"julia> Write_Paraview(Topo, \"Topography_Alps\") ","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"The result is shown here, together with Moho data","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"(Image: Tutorial_GMT_topography)","category":"page"},{"location":"man/tutorial_GMT_Topography/","page":"Create GMT-based topography","title":"Create GMT-based topography","text":"In case you are interested: we are employing the oleron scientific colormap here.","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"EditURL = \"<unknown>/LaPalma_example.jl\"","category":"page"},{"location":"man/LaPalma_example/#Create-a-3D-LaMEM-setup-for-La-Palma","page":"Generating LaMEM model","title":"Create a 3D LaMEM setup for La Palma","text":"","category":"section"},{"location":"man/LaPalma_example/#Aim","page":"Generating LaMEM model","title":"Aim","text":"","category":"section"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In this tutorial, your will learn how to use real data to create a geodynamic model setup with LaMEM. We will use the data of La Palma, which is a volcanic island that started erupting in mid september 2021. LaMEM is a cartesian geodynamic model, which implies that you will have to transfer the data from GeoData to CartData.","category":"page"},{"location":"man/LaPalma_example/#.-Load-data","page":"Generating LaMEM model","title":"1. Load data","text":"","category":"section"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"We will use two types of data to create the model","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Topography\nEarthquake locations","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"We start with loading the required packages","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"using GeophysicalModelGenerator, JLD2\nusing GMT","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In case you managed to install GMT on your machine, you can automatically download the topography with","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Topo = ImportTopo(lon = [-18.7, -17.1], lat=[28.0, 29.2], file=\"@earth_relief_03s.grd\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"GeoData \n  size  : (1921, 1441, 1)\n  lon   ϵ [ 341.3 : 342.9]\n  lat   ϵ [ 28.0 : 29.2]\n  depth ϵ [ -4.38297802734375 km : 2.414 km]\n  fields: (:Topography,)\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In case you did not manage that, we have prepared a JLD2 file here. Download it, and doublecheck that you are in the same directory as the data file with:","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"pwd()","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"\"/Users/kausb/.julia/dev/GeophysicalModelGenerator/docs/src/scripts\"","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Load the data:","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Topo=load(\"Topo_LaPalma.jld2\",\"Topo\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"GeoData \n  size  : (1921, 1441, 1)\n  lon   ϵ [ 341.3 : 342.9]\n  lat   ϵ [ 28.0 : 29.2]\n  depth ϵ [ -4.38297802734375 km : 2.414 km]\n  fields: (:Topography,)\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Next, lets load the seismicity. We have prepared a file with earthquake locations up to early November (from https://www.ign.es/web/ign/portal/vlc-catalogo). Download that here","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"data_all_EQ = load(\"EQ_Data.jld2\",\"data_all_EQ\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"GeoData \n  size  : (6045,)\n  lon   ϵ [ -18.0341 : -17.6671]\n  lat   ϵ [ 28.3102 : 28.8144]\n  depth ϵ [ NaN km : NaN km]\n  fields: (:Magnitude, :TimeSinceJan1_2021)\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Write the data to paraview with","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Write_Paraview(data_all_EQ,\"data_all_EQ\",PointsData=true)\nWrite_Paraview(Topo,\"Topo\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Saved file: data_all_EQ.vtu\nSaved file: Topo.vts\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"As earthquakes are point-wise data, you have to specify this. (Image: LaPalma_EQTopo_GeoData) Note that this data is not in \"easy\" coordinates (see coordinate axis in the plot, where z is not pointing upwards).","category":"page"},{"location":"man/LaPalma_example/#.-Convert-data","page":"Generating LaMEM model","title":"2. Convert data","text":"","category":"section"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In order to create model setups, it is helpful to first transfer the data to Cartesian. This requires us to first determine a projection point, that is fixed. Often, it is helpful to use the center of the topography for this. In the present example, we will center the model around La Palma itself:","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"proj = ProjectionPoint(Lon=-17.84, Lat=28.56)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"ProjectionPoint(28.56, -17.84, 222158.69478000276, 3.1625327286383654e6, 28, true)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Once this is done you can convert the topographic data to the cartesian reference frame","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"EQ_cart   = Convert2CartData(data_all_EQ, proj);\nTopo_cart = Convert2CartData(Topo, proj)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"CartData \n    size   : (1921, 1441, 1)\n    x      ϵ [ -86.09445705828863 km : 73.67229892155609 km]\n    y      ϵ [ -63.5531883197492 km : 73.28446155584604 km]\n    z      ϵ [ -4.38297802734375 km : 2.414 km]\n    fields : (:Topography,)\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"It is important to realize that the cartesian coordinates of the topographic grid is no longer strictly orthogonal after this conversion. You don't notice that in the current example, as the model domain is rather small. In other cases, however, this is quite substantial (e.g., India-Asia collision zone). LaMEM needs an orthogonal grid of topography, which we can create with:","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Topo_LaMEM = CartData(XYZGrid(-70:.2:70,-60:.2:70,0));\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In a next step, the routine ProjectCartData projects a GeoData structure to a CartData struct","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Topo_LaMEM = ProjectCartData(Topo_LaMEM, Topo, proj)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"CartData \n    size   : (701, 651, 1)\n    x      ϵ [ -70.0 km : 70.0 km]\n    y      ϵ [ -60.0 km : 70.0 km]\n    z      ϵ [ -4.29541702331831 km : 2.3840784607152257 km]\n    fields : (:Topography,)\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Let's have a look at the data:","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Write_Paraview(EQ_cart,\"EQ_cart\",PointsData=true)\nWrite_Paraview(Topo_LaMEM,\"Topo_LaMEM\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Saved file: EQ_cart.vtu\nSaved file: Topo_LaMEM.vts\n","category":"page"},{"location":"man/LaPalma_example/#.-Create-LaMEM-setup","page":"Generating LaMEM model","title":"3. Create LaMEM setup","text":"","category":"section"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In a next step, we need to read the LaMEM input file of the simulation. In particular, this will read the lateral dimensions of the grid and the number of control volumes (elements), you want to apply in every direction. The LaMEM input file can be downloaded here. Make sure you are in the same directory as the *.dat file & execute the following command","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Grid    = ReadLaMEM_InputFile(\"LaPalma.dat\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"LaMEM Grid: \n  nel         : (64, 64, 32)\n  marker/cell : (3, 3, 3)\n  markers     : (192, 192, 192)\n  x           ϵ [-50.0 : 50.0]\n  y           ϵ [-40.0 : 40.0]\n  z           ϵ [-80.0 : 15.0]\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"The LaMEM_grid structure contains the number of elements in every direction and the number of markers in every cell. It also contains Grid.X, Grid.Y, Grid.Z, which are the coordinates of each of the markers in the 3 directions.","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In a next step we need to give each of these points a Phase number (which is an integer, that indicates the type of the rock that point has), as well as the temperature (in Celcius).","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Phases  = ones(Int32,size(Grid.X))*2;\nTemp    = ones(Float64,size(Grid.X));\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"In this example we set the temperature based on the depth, assuming a constant geotherm. Depth is given in kilometers","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Geotherm =  30;\nTemp     =  -Grid.Z.*Geotherm;\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Since we are in La Palma, we assume that temperatures are not less than 20 degrees. Moreover, in the mantle, we have the mantle adiabat (1350 C)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Temp[Temp.<20]    .=  20;\nTemp[Temp.>1350]  .=  1350;\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Because of lacking data, we have pretty much no idea where the Moho is in La Palma. Somewhat arbitrary, we assume it to be at 40 km depth, and set the rocks below that to \"mantle\":","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"ind = findall( Grid.Z .< -40);\nPhases[ind] .= 3;\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Everything above the free surface is assumed to be \"air\"","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"ind     =   AboveSurface(Grid, Topo_cart);\nPhases[ind] .= 0;\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"And all \"air\" points that are below sea-level becomes \"water\"","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"ind = findall( (Phases.==0) .& (Grid.Z .< 0));\nPhases[ind] .= 1;\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"You can interpret the seismicity in different ways. If you assume that there are fully molten magma chambers, there should be no earthquakes within the magma chamber (as stresses are liklely to be very small). If, however, this is a partially molten mush, extraction of melt of that mush will change the fluid pressure and may thus release build-up stresses. We will assume the second option in our model setup.","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Looking at the seismicity, there is a swarm at around 35 km depth","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"AddSphere!(Phases,Temp,Grid, cen=(0,0,-35), radius=5, phase=ConstantPhase(5), T=ConstantTemp(1200));\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"A shallower one exists as well","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"AddEllipsoid!(Phases,Temp,Grid, cen=(-1,0,-11), axes=(3,3,8), StrikeAngle=225, DipAngle=45, phase=ConstantPhase(5), T=ConstantTemp(1200));\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"And there might be a mid-crustal one","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"AddEllipsoid!(Phases,Temp,Grid, cen=(-0,0,-23), axes=(8,8,2), StrikeAngle=0, DipAngle=0, phase=ConstantPhase(5), T=ConstantTemp(1200));\nnothing #hide","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"We can generate a 3D model setup, which must include the Phases and Temp arrays","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Model3D = CartData(Grid, (Phases=Phases,Temp=Temp))\nWrite_Paraview(Model3D,\"Model3D\")","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Saved file: Model3D.vts\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"The model setup looks like this (Image: LaMEM_ModelSetup_LaPalma)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"We can create a LaMEM marker file from the Model3D setup and the (cartesian) topography","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Save_LaMEMTopography(Topo_cart, \"Topography.txt\")\nSave_LaMEMMarkersParallel(Model3D)","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Written LaMEM topography file: Topography.txt\nWriting LaMEM marker file -> ./markers/mdb.00000000.dat\n","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"Next, you can use this to run the LaMEM model and visualize the model results in Paraview as well. If you are interested in doing this, have a look at the LaMEM wiki pages.","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"","category":"page"},{"location":"man/LaPalma_example/","page":"Generating LaMEM model","title":"Generating LaMEM model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeophysicalModelGenerator","category":"page"},{"location":"#GeophysicalModelGenerator","page":"Home","title":"GeophysicalModelGenerator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeophysicalModelGenerator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main purpose of this package is to simplify the process of going from 1D/2D/3D geophysical data to a 3D consistent model of the region. By simplifying the process of plotting the data, it becomes easier to compare different data sets, and generate a 3D models that can be used for other computations such as geodynamic simulations, or forward modelling of gravity anomalies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this, GeophysicalModelGenerator provides the following functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A consistent GeoData structure, that holds the data along with lon/lat/depth information. \nRoutines to generate VTK files from the GeoData structure in order to visualize results in Paraview.\nThe ability to deal with points, 2D profiles and 3D volumes, for both scalar and vector values.\nRapidly import screenshots of published papers and compare them with other data sets in 3D using paraview.\nCreate movies for representation of earthquake or wave propagation.\nCreate geodynamic input models (for LaMEM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started is to look at the tutorials.","category":"page"},{"location":"man/tutorial_ISC_data/#Plot-ISC-earthquake-data","page":"ISC earthquake data","title":"Plot ISC earthquake data","text":"","category":"section"},{"location":"man/tutorial_ISC_data/#Goal","page":"ISC earthquake data","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"This explains how to load earthquake data obtained from the ISC catalogue.","category":"page"},{"location":"man/tutorial_ISC_data/#Steps","page":"ISC earthquake data","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_ISC_data/#.-Download-data","page":"ISC earthquake data","title":"1. Download data","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"You can get data from the ISC catalogue here:   http://www.isc.ac.uk/iscbulletin/search/catalogue/ The catalogue will give you an on screen CSV output that will then have to be copied to a file of your choice (here we will call it ISC1.dat). Do that and start julia from the directory where it was downloaded.","category":"page"},{"location":"man/tutorial_ISC_data/#.-Read-data-into-Julia","page":"ISC earthquake data","title":"2. Read data into Julia","text":"","category":"section"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"The main data-file, ISC1.dat, has 23 lines of comments (indicated with #), after which the data starts. We can use the julia package https://github.com/JuliaData/CSV.jl to read in the data, and tell it that the data is seperated by ,.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> using CSV, GeophysicalModelGenerator\njulia> data_file        =   CSV.File(\"ISC1.dat\",datarow=24,header=false,delim=',')","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"As this data contains a lot of information that we are not interested in at the moment and which is given in non-numeric fomats (e.g. date, time etc.), we will use our helper function ParseColumnsCSVFile to only extract columns with numeric data.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> data        =   ParseColumns_CSV_File(data_file, 14)\njulia> lon         = data[:,2];\njulia> lat         = data[:,1];\njulia> depth       = -1* data[:,3];\njulia> magnitude   = data[:,4];","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"Converting this data to a GeoStruct data and to export is to Paraview is then straightforward.","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"julia> EQ_Data = GeoData(lon,lat,depth,(Magnitude=magnitude,Depth=depth));\njulia> Write_Paraview(EQ_Data, \"EQ_ISC\", PointsData=true)","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"The result the looks like this (plotted here together with the topography):","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"(Image: Tutorial_ISC)","category":"page"},{"location":"man/tutorial_ISC_data/","page":"ISC earthquake data","title":"ISC earthquake data","text":"In case you are interested: we are employing the oleron scientific colormap from Fabio Crameri's scientific colormap package here.","category":"page"},{"location":"man/tutorial_Coastlines/#Add-coastlines","page":"Coastlines","title":"Add coastlines","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#Goal","page":"Coastlines","title":"Goal","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"For orientation, it is often nice to add country borders and coastlines to your paraview plots. ","category":"page"},{"location":"man/tutorial_Coastlines/#Steps","page":"Coastlines","title":"Steps","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#.-Coast-lines","page":"Coastlines","title":"1. Coast lines","text":"","category":"section"},{"location":"man/tutorial_Coastlines/#.1-Download-land/sea-data","page":"Coastlines","title":"1.1 Download land/sea data","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The package GeoDatasets.jl has a simple interface to get a grid that explains whether the Earth surface is land, sea or a lake.","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"julia> using GeoDatasets\njulia> lon,lat,data = GeoDatasets.landseamask(;resolution='l',grid=1.25);\njulia> ind_lon = findall( (lon .> 0) .& (lon .< 30 ) );\njulia> ind_lat = findall( (lat .> 35) .& (lat .< 50 ) );","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The parameter resolution should be either c,l,i,h or f (standing for crude, low, intermediate, high and full resolution)","category":"page"},{"location":"man/tutorial_Coastlines/#.2-Save-in-Paraview","page":"Coastlines","title":"1.2 Save in Paraview","text":"","category":"section"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"julia> Lon,Lat,Depth    =   LonLatDepthGrid(lon[ind_lon],lat[ind_lat],0km);\njulia> data_surf        =   zeros(size(Lon));\njulia> data_surf[:,:,1] =   data[ind_lon,ind_lat]\njulia> data_surface     =   GeoData(Lon, Lat, Depth, (SurfaceType=data_surf,))\njulia> Write_Paraview(data_surface, \"ContinentOcean\") ","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"The result is shown here, together with Moho data","category":"page"},{"location":"man/tutorial_Coastlines/","page":"Coastlines","title":"Coastlines","text":"(Image: Tutorial_Coastlines)","category":"page"}]
}
