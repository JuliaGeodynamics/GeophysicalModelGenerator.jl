<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools · GeophysicalModelGenerator.jl</title><meta name="title" content="Tools · GeophysicalModelGenerator.jl"/><meta property="og:title" content="Tools · GeophysicalModelGenerator.jl"/><meta property="twitter:title" content="Tools · GeophysicalModelGenerator.jl"/><meta name="description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="og:description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="twitter:description" content="Documentation for GeophysicalModelGenerator.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeophysicalModelGenerator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../tutorial_load3DSeismicData/">1 - 3D seismic tomography from ASCII</a></li><li><a class="tocitem" href="../tutorial_loadregular3DSeismicData_netCDF/">2 - 3D seismic tomography from netCDF</a></li><li><a class="tocitem" href="../tutorial_MohoTopo/">3 - Visualize Moho topography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography/">4 - Create GMT-based topography</a></li><li><a class="tocitem" href="../tutorial_Coastlines/">5 - Coastlines</a></li><li><a class="tocitem" href="../tutorial_Screenshot_To_Paraview/">6 - Import screenshots</a></li><li><a class="tocitem" href="../tutorial_loadirregular3DSeismicData/">7 - Interpolate irregular 3D seismic tomography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography_GeologicalMap/">8 - ETOPO1 Topography and geological maps</a></li><li><a class="tocitem" href="../tutorial_ISC_data/">9 - ISC earthquake data</a></li><li><a class="tocitem" href="../tutorial_GPS/">10 - Plot GPS vectors</a></li><li><a class="tocitem" href="../tutorial_UTM/">11 - Read UTM data</a></li><li><a class="tocitem" href="../Tutorial_Votemaps/">12 - VoteMaps</a></li><li><a class="tocitem" href="../tutorial_local_Flegrei/">13 - Campi Flegrei</a></li><li><a class="tocitem" href="../LaPalma_example/">14 - Cartesian Volcano Model</a></li><li><a class="tocitem" href="../tutorial_time_Seismicity/">15 - Create movies</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../dataimport/">Data Import</a></li><li><a class="tocitem" href="../projection/">Projection</a></li><li><a class="tocitem" href="../paraview_output/">Paraview output</a></li><li class="is-active"><a class="tocitem" href>Tools</a></li><li><a class="tocitem" href="../visualise/">Visualisation</a></li><li><a class="tocitem" href="../gravity_code/">Gravity code</a></li><li><a class="tocitem" href="../lamem/">LaMEM</a></li><li><a class="tocitem" href="../profile_processing/">Profile Processing</a></li></ul></li><li><a class="tocitem" href="../listfunctions/">List of functions</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/main/docs/src/man/tools.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tools"><a class="docs-heading-anchor" href="#Tools">Tools</a><a id="Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Tools" title="Permalink"></a></h1><p>We have a number of functions with which we can extract sub-data from a 2D or 3D <code>GeoData</code> structure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CrossSection" href="#GeophysicalModelGenerator.CrossSection"><code>GeophysicalModelGenerator.CrossSection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CrossSection(DataSet::AbstractGeneralGrid; dims=(100,100), Interpolate=false, Depth_level=nothing, Lat_level=nothing, Lon_level=nothing, Start=nothing, End=nothing, Depth_extent=nothing, section_width=50km)</code></pre><p>Creates a cross-section through a <code>GeoData</code> object.</p><ul><li>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</li><li>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</li><li>Depending on the type of input data (volume, surface or point data), cross sections will be created in a different manner:</li></ul><ol><li>Volume data: data will be interpolated or directly extracted from the data set.</li><li>Surface data: surface data will be interpolated or directly extracted from the data set</li><li>Point data: data will be projected to the chosen profile. Only data within a chosen distance (default is 50 km) will be used</li></ol><ul><li><code>Interpolate</code> indicates whether we want to simply extract the data from the data set (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in <code>dims</code> NOTE: THIS ONLY APPLIES TO VOLUMETRIC AND SURFACE DATA SETS</li><li>&#39;section_width&#39; indicates the maximal distance within which point data will be projected to the profile</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz))); 
julia&gt; Data_cross      =   CrossSection(Data_set3D, Depth_level=-100km)  
GeoData 
  size  : (11, 11, 1)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -100.0 km : -100.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L485-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ExtractSubvolume" href="#GeophysicalModelGenerator.ExtractSubvolume"><code>GeophysicalModelGenerator.ExtractSubvolume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ExtractSubvolume(V::GeoData; Interpolate=false, Lon_level=nothing, Lat_level=nothing, Depth_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>3D Example with interpolation:</strong></p><p>Alternatively, you can also interpolate the data onto a new grid:</p><pre><code class="language-julia hljs">julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40), Interpolate=true, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L601-L646">source</a></section><section><div><pre><code class="language-julia hljs">ExtractSubvolume(V::CartData; Interpolate=false, X_level=nothing, Y_level=nothing, Z_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>2D Example along a cross-section through 3D data:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X,Y,Z = XYZGrid(10:20,30:40,-300:25:0);
julia&gt; Data = Z.*2
julia&gt; Data_Int = Int64.(Data)
julia&gt; DataSet_Cart = CartData(X,Y,Z,(Data=Data,Data_Int=Data_Int, Velocity=(X,Y,Z)))

julia&gt; Data_cross = CrossSection(DataSet_Cart, Start=(11.0,35), End=(19, 39.0))
CartData
    size    : (100, 100, 1)
    x       ϵ [ 11.0 : 19.0]
    y       ϵ [ 35.0 : 39.0]
    z       ϵ [ -300.0 : 0.0]
    fields  : (:Data, :Data_Int, :Velocity, :FlatCrossSection)
  attributes: [&quot;note&quot;]

julia&gt; Data_extracted = ExtractSubvolume(Data_cross, X_level=(1,7), Z_level=(-200,-100))
  CartData
      size    : (50, 50, 1)
      x       ϵ [ 11.894427190999917 : 17.260990336999413]
      y       ϵ [ 35.44721359549995 : 38.130495168499706]
      z       ϵ [ -200.0 : -100.0]
      fields  : (:FlatCrossSection, :Data, :Data_Int, :Velocity)
    attributes: [&quot;note&quot;]
julia&gt; typeof(Data_extracted.fields.Data_Int)
    Array{Int64, 3}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L685-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields" href="#GeophysicalModelGenerator.InterpolateDataFields"><code>GeophysicalModelGenerator.InterpolateDataFields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Data_interp = InterpolateDataFields(V::AbstractGeneralGrid, Lon, Lat, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>Lon,Lat,Depth</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x        =   0:2:10
julia&gt; y        =   -5:5
julia&gt; z        =   -10:2:2
julia&gt; X,Y,Z    =   XYZGrid(x, y, z);
julia&gt; Data     =   Z
julia&gt; Data_set1=   CartData(X,Y,Z, (FakeData=Data,Data2=Data.+1.))
CartData
    size    : (6, 11, 7)
    x       ϵ [ 0.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ -10.0 km : 2.0 km]
    fields  : (:FakeData, :Data2)
  attributes: [&quot;note&quot;]

julia&gt; X,Y,Z    =   XYZGrid(0:4:10, -1:.1:1, -5:.1:1 );
julia&gt; Data_set2= InterpolateDataFields(Data_set1, X,Y,Z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L909-L934">source</a></section><section><div><pre><code class="language-julia hljs">InterpolateDataFields(V::UTMData, EW, NS, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>UTM,Depth</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1001-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.VoteMap" href="#GeophysicalModelGenerator.VoteMap"><code>GeophysicalModelGenerator.VoteMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VoteMap(DataSets::Vector{GeoData}, criteria::Vector{String}, dims=(50,50,50))</code></pre><p>Creates a Vote map which shows consistent features in different 2D/3D tomographic datasets.</p><p>The way it works is:</p><ul><li>Find a common region between the different GeoData sets (overlapping lon/lat/depth regions)</li><li>Interpolate the fields of all DataSets to common coordinates</li><li>Filter data points in one model (e.g., areas with a velocity anomaly &gt; 2 percent). Set everything that satisfies this criteria to 1 and everything else to 0.</li><li>Sum the results of the different datasets</li></ul><p>If a feature is consistent between different datasets, it will have larger values.</p><p><strong>Example</strong></p><p>We assume that we have 2 seismic velocity datasets <code>Data_Zhao_Pwave</code> and <code>DataKoulakov_Alps</code>:</p><pre><code class="language-julia hljs">julia&gt; Data_Zhao_Pwave
GeoData
  size  : (121, 94, 101)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:dVp_Percentage,)
julia&gt; DataKoulakov_Alps
  GeoData
    size  : (108, 81, 35)
    lon   ϵ [ 4.0 : 20.049999999999997]
    lat   ϵ [ 37.035928143712574 : 49.01197604790419]
    depth ϵ [ -700.0 km : -10.0 km]
    fields: (:dVp_percentage, :dVs_percentage)</code></pre><p>You can create a VoteMap which combines the two data sets with:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = VoteMap([Data_Zhao_Pwave,DataKoulakov_Alps],[&quot;dVp_Percentage&gt;2.5&quot;,&quot;dVp_percentage&gt;3.0&quot;])
GeoData
  size  : (50, 50, 50)
  lon   ϵ [ 4.0 : 18.0]
  lat   ϵ [ 38.0 : 49.01197604790419]
  depth ϵ [ -700.0 km : -10.0 km]
  fields: (:VoteMap,)</code></pre><p>You can also create a VoteMap of a single dataset:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = VoteMap(Data_Zhao_Pwave,&quot;dVp_Percentage&gt;2.5&quot;, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:VoteMap,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1649-L1702">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.SubtractHorizontalMean" href="#GeophysicalModelGenerator.SubtractHorizontalMean"><code>GeophysicalModelGenerator.SubtractHorizontalMean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V_sub = SubtractHorizontalMean(V::AbstractArray{T, 3}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 3D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1403-L1410">source</a></section><section><div><pre><code class="language-julia hljs">V_sub = SubtractHorizontalMean(V::AbstractArray{T, 2}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 2D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1437-L1444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface" href="#GeophysicalModelGenerator.AboveSurface"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AboveSurface(Data::GeoData, DataSurface::GeoData; above=true)</code></pre><p>Returns a boolean array of size(Data.Lon), which is true for points that are above the surface DataSurface (or for points below if above=false).</p><p>This can be used, for example, to mask points above/below the Moho in a volumetric dataset or in a profile.</p><p><strong>Example</strong></p><p>First we create a 3D data set and a 2D surface:</p><pre><code class="language-julia hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData)
julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,-40km);
julia&gt; Data_Moho       =   GeoData(Lon,Lat,Depth+Lon*km, (MohoDepth=Depth,))
  GeoData
    size  : (11, 11, 1)
    lon   ϵ [ 10.0 : 20.0]
    lat   ϵ [ 30.0 : 40.0]
    depth ϵ [ -30.0 km : -20.0 km]
    fields: (:MohoDepth,)</code></pre><p>Next, we intersect the surface with the data set:</p><pre><code class="language-julia hljs">julia&gt; Above       =   AboveSurface(Data_set3D, Data_Moho);</code></pre><p>Now, <code>Above</code> is a boolean array that is true for points above the surface and false for points below and at the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1513-L1547">source</a></section><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1580-L1584">source</a></section><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_Cart::CartData, DataSurface_Cart::CartData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1593-L1597">source</a></section><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Grid::CartGrid, DataSurface_Cart::CartData; above=true)</code></pre><p>Determines if points described by the <code>Grid</code> CartGrid structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1606-L1610">source</a></section><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are above the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface" href="#GeophysicalModelGenerator.BelowSurface"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data::GeoData, DataSurface::GeoData)</code></pre><p>Determines if points within the 3D <code>Data</code> structure are below the GeoData surface <code>DataSurface</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1571-L1575">source</a></section><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Grid::CartGrid, DataSurface_Cart::CartData)

Determines if points described by the `Grid` CartGrid structure are above the Cartesian surface `DataSurface_Cart`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1620-L1624">source</a></section><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData)</code></pre><p>Determines if points within the 3D Data<em>Cart structure are below the Cartesian surface DataSurface</em>Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1630-L1634">source</a></section><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_Cart::CartData, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D Data<em>Cart structure are below the Cartesian surface DataSurface</em>Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1639-L1643">source</a></section><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are below the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataOnSurface" href="#GeophysicalModelGenerator.InterpolateDataOnSurface"><code>GeophysicalModelGenerator.InterpolateDataOnSurface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Surf_interp = InterpolateDataOnSurface(V::ParaviewData, Surf::ParaviewData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Data
ParaviewData
  size  : (33, 33, 33)
  x     ϵ [ -3.0 : 3.0]
  y     ϵ [ -2.0 : 2.0]
  z     ϵ [ -2.0 : 0.0]
  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)
julia&gt; surf
ParaviewData
  size  : (96, 96, 1)
  x     ϵ [ -2.9671875 : 3.2671875]
  y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
  z     ϵ [ -1.5353766679763794 : -0.69925457239151]
  fields: (:Depth,)
julia&gt; Surf_interp = InterpolateDataOnSurface(Data, surf)
  ParaviewData
    size  : (96, 96, 1)
    x     ϵ [ -2.9671875 : 3.2671875]
    y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
    z     ϵ [ -1.5353766679763794 : -0.69925457239151]
    fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1274-L1302">source</a></section><section><div><pre><code class="language-julia hljs">Surf_interp = InterpolateDataOnSurface(V::GeoData, Surf::GeoData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1335-L1339">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GeophysicalModelGenerator.InterpolateTopographyOnPlane</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ParseColumns_CSV_File" href="#GeophysicalModelGenerator.ParseColumns_CSV_File"><code>GeophysicalModelGenerator.ParseColumns_CSV_File</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ParseColumns_CSV_File(data_file, num_columns)</code></pre><p>This parses numbers from CSV file that is read in with <code>CSV.File</code>. That is useful in case the CSV files has tables that contain both strings (e.g., station names) and numbers (lat/lon/height) and you are only interested in the numbers</p><p><strong>Example</strong></p><p>This example assumes that the data starts at line 18, that the columns are separated by spaces, and that it contains at most 4 columns with data:</p><pre><code class="language-julia-repl hljs">julia&gt; using CSV
julia&gt; data_file        =   CSV.File(&quot;FileName.txt&quot;,datarow=18,header=false,delim=&#39; &#39;)
julia&gt; data = ParseColumns_CSV_File(data_file, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1474-L1489">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GeophysicalModelGenerator.RotateTranslateScale!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid" href="#GeophysicalModelGenerator.PointData2NearestGrid"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(Point::CartData, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L6-L15">source</a></section><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(pt_x,pt_y,pt_z, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>CartGrid</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L28-L35">source</a></section><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(Point::GeoData, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L46-L55">source</a></section><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(pt_x,pt_y,pt_z, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>GeoData</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L68-L75">source</a></section><section><div><pre><code class="language-julia hljs">count = PointData2NearestGrid(pt_x,pt_y,pt_z, X,Y,Z; radius_factor=1)</code></pre><p>This uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D grid point specified by <code>X</code>,<code>Y</code>,<code>Z</code> 3D coordinate arrays, with regular spacing <code>(Δx,Δy,Δz)</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2UTMzone" href="#GeophysicalModelGenerator.Convert2UTMzone"><code>GeophysicalModelGenerator.Convert2UTMzone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Convert2UTMzone(d::GeoData, p::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to fixed UTM zone, around a given <code>ProjectionPoint</code>     This useful to use real data as input for a cartesian geodynamic model setup (such as in LaMEM). In that case, we need to project map coordinates to cartesian coordinates.     One way to do this is by using UTM coordinates. Close to the <code>ProjectionPoint</code> the resulting coordinates will be rectilinear and distance in meters. The map distortion becomes larger the further you are away from the center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L597-L604">source</a></section><section><div><pre><code class="language-julia hljs">Convert2UTMzone(d::CartData, proj::ProjectionPoint)</code></pre><p>This transfers a <code>CartData</code> dataset to a <code>UTMData</code> dataset, that has a single UTM zone. The point around which we project is <code>ProjectionPoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L804-L808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2CartData" href="#GeophysicalModelGenerator.Convert2CartData"><code>GeophysicalModelGenerator.Convert2CartData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Convert2CartData(d::UTMData, proj::ProjectionPoint)</code></pre><p>Converts a <code>UTMData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L816-L819">source</a></section><section><div><pre><code class="language-julia hljs">Convert2CartData(d::GeoData, proj::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L834-L837">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectCartData" href="#GeophysicalModelGenerator.ProjectCartData"><code>GeophysicalModelGenerator.ProjectCartData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L7-L16">source</a></section><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L47-L56">source</a></section><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::UTMData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the UTMData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>.     <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><pre><code class="nohighlight hljs"># Note:    
- If `d_cart` and `d` are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.DrapeOnTopo" href="#GeophysicalModelGenerator.DrapeOnTopo"><code>GeophysicalModelGenerator.DrapeOnTopo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Topo = DrapeOnTopo(Topo::GeoData, Data::GeoData)</code></pre><p>This drapes fields of a data set <code>Data</code> on the topography <code>Topo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1844-L1850">source</a></section><section><div><pre><code class="language-julia hljs">DrapeOnTopo(Topo::CartData, Data::CartData)</code></pre><p>Drapes Cartesian Data on topography</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1918-L1922">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.LithostaticPressure!" href="#GeophysicalModelGenerator.LithostaticPressure!"><code>GeophysicalModelGenerator.LithostaticPressure!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LithostaticPressure!(Plithos::Array, Density::Array, dz::Number; g=9.81)</code></pre><p>Computes lithostatic pressure from a 3D density array, assuming constant soacing <code>dz</code> in vertical direction. Optionally, the gravitational acceleration <code>g</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1934-L1939">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../paraview_output/">« Paraview output</a><a class="docs-footer-nextpage" href="../visualise/">Visualisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 29 February 2024 14:40">Thursday 29 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
