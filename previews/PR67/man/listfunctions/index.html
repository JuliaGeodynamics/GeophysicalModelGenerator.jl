<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of functions · GeophysicalModelGenerator.jl</title><meta name="title" content="List of functions · GeophysicalModelGenerator.jl"/><meta property="og:title" content="List of functions · GeophysicalModelGenerator.jl"/><meta property="twitter:title" content="List of functions · GeophysicalModelGenerator.jl"/><meta name="description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="og:description" content="Documentation for GeophysicalModelGenerator.jl."/><meta property="twitter:description" content="Documentation for GeophysicalModelGenerator.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeophysicalModelGenerator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../tutorial_load3DSeismicData/">1 - 3D seismic tomography from ASCII</a></li><li><a class="tocitem" href="../tutorial_loadregular3DSeismicData_netCDF/">2 - 3D seismic tomography from netCDF</a></li><li><a class="tocitem" href="../tutorial_MohoTopo/">3 - Visualize Moho topography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography/">4 - Create GMT-based topography</a></li><li><a class="tocitem" href="../tutorial_Coastlines/">5 - Coastlines</a></li><li><a class="tocitem" href="../tutorial_Screenshot_To_Paraview/">6 - Import screenshots</a></li><li><a class="tocitem" href="../tutorial_loadirregular3DSeismicData/">7 - Interpolate irregular 3D seismic tomography</a></li><li><a class="tocitem" href="../tutorial_GMT_Topography_GeologicalMap/">8 - ETOPO1 Topography and geological maps</a></li><li><a class="tocitem" href="../tutorial_ISC_data/">9 - ISC earthquake data</a></li><li><a class="tocitem" href="../tutorial_GPS/">10 - Plot GPS vectors</a></li><li><a class="tocitem" href="../tutorial_UTM/">11 - Read UTM data</a></li><li><a class="tocitem" href="../Tutorial_Votemaps/">12 - VoteMaps</a></li><li><a class="tocitem" href="../tutorial_local_Flegrei/">13 - Campi Flegrei</a></li><li><a class="tocitem" href="../LaPalma_example/">14 - Cartesian Volcano Model</a></li><li><a class="tocitem" href="../tutorial_time_Seismicity/">15 - Create movies</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../dataimport/">Data Import</a></li><li><a class="tocitem" href="../projection/">Projection</a></li><li><a class="tocitem" href="../paraview_output/">Paraview output</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../visualise/">Visualisation</a></li><li><a class="tocitem" href="../gravity_code/">Gravity code</a></li><li><a class="tocitem" href="../lamem/">LaMEM</a></li><li><a class="tocitem" href="../profile_processing/">Profile Processing</a></li></ul></li><li class="is-active"><a class="tocitem" href>List of functions</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>List of functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/main/docs/src/man/listfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-all-functions"><a class="docs-heading-anchor" href="#List-of-all-functions">List of all functions</a><a id="List-of-all-functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-all-functions" title="Permalink"></a></h1><p>Here an overview of all functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CartData-Tuple{CartGrid, NamedTuple}" href="#GeophysicalModelGenerator.CartData-Tuple{CartGrid, NamedTuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data = CartData(Grid::CartGrid, fields::NamedTuple; y_val=0.0)</code></pre><p>Returns a CartData set given a cartesian grid <code>Grid</code> and <code>fields</code> defined on that grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1196-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CartData-Tuple{LaMEM_grid, NamedTuple}" href="#GeophysicalModelGenerator.CartData-Tuple{LaMEM_grid, NamedTuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CartData(Grid::LaMEM_grid, fields::NamedTuple)</code></pre><p>Creates a <code>CartData</code> struct from a LaMEM grid and from fields stored on that grid. Note that one needs to have a field <code>Phases</code> and optionally a field <code>Temp</code> to create LaMEM marker files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CartData-Tuple{Tuple}" href="#GeophysicalModelGenerator.CartData-Tuple{Tuple}"><code>GeophysicalModelGenerator.CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CartData(xyz::Tuple{Array,Array,Array})</code></pre><p>This creates a <code>CartData</code> struct if you have a Tuple with 3D coordinates as input.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; data = CartData(XYZGrid(-10:10,-5:5,0))
CartData
    size    : (21, 11, 1)
    x       ϵ [ -10.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ 0.0 km : 0.0 km]
    fields  : (:Z,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L784-L799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CartGrid" href="#GeophysicalModelGenerator.CartGrid"><code>GeophysicalModelGenerator.CartGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Structure that holds data for an orthogonal cartesian grid, which can be described with 1D vectors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1022-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.GMG_Dataset" href="#GeophysicalModelGenerator.GMG_Dataset"><code>GeophysicalModelGenerator.GMG_Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that stores info about a GMG Dataset, which is useful to collect a wide variety of datasets.</p><ul><li>Name    :: String          # Name of the dataset</li><li>Type    :: String          # Volumetric, Surface, Point, Screenshot</li><li>DirName :: String          # Directory name or url of dataset</li><li>active  :: Bool            # should this data be loaded or not?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.GeoData" href="#GeophysicalModelGenerator.GeoData"><code>GeophysicalModelGenerator.GeoData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoData(lon::Any, lat:Any, depth::GeoUnit, fields::NamedTuple)</code></pre><p>Data structure that holds one or several fields with longitude, latitude and depth information.</p><ul><li><code>depth</code> can have units of meter, kilometer or be unitless; it will be converted to km.</li><li><code>fields</code> should ideally be a NamedTuple which allows you to specify the names of each of the fields.</li><li>In case you only pass one array we will convert it to a NamedTuple with default name.</li><li>A single field should be added as <code>(DataFieldName=Data,)</code> (don&#39;t forget the comma at the end).</li><li>Multiple fields  can be added as well. <code>lon</code>,<code>lat</code>,<code>depth</code> should all have the same size as each of the <code>fields</code>.</li><li>In case you want to display a vector field in paraview, add it as a tuple: <code>(Velocity=(Veast,Vnorth,Vup), Veast=Veast, Vnorth=Vnorth, Vup=Vup)</code>; we automatically apply a vector transformation when transforming this to a <code>ParaviewData</code> structure from which we generate Paraview output. As this changes the magnitude of the arrows, you will no longer see the <code>[Veast,Vnorth,Vup]</code> components in Paraview which is why it is a good ideas to store them as separate Fields.</li><li>Yet, there is one exception: if the name of the 3-component field is <code>colors</code>, we do not apply this vector transformation as this field is regarded to contain RGB colors.</li><li><code>Lat</code>,<code>Lon</code>,<code>Depth</code> should have the same size as the <code>Data</code> array. The ordering of the arrays is important. If they are 3D arrays, as in the example below, we assume that the first dimension corresponds to <code>lon</code>, second dimension to <code>lat</code> and third dimension to <code>depth</code> (which should be in km). See below for an example.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lat         =   1.0:3:10.0;
julia&gt; Lon         =   11.0:4:20.0;
julia&gt; Depth       =   (-20:5:-10)*km;
julia&gt; Lon3D,Lat3D,Depth3D = LonLatDepthGrid(Lon, Lat, Depth);
julia&gt; Lon3D
3×4×3 Array{Float64, 3}:
[:, :, 1] =
 11.0  11.0  11.0  11.0
 15.0  15.0  15.0  15.0
 19.0  19.0  19.0  19.0

[:, :, 2] =
 11.0  11.0  11.0  11.0
 15.0  15.0  15.0  15.0
 19.0  19.0  19.0  19.0

[:, :, 3] =
 11.0  11.0  11.0  11.0
 15.0  15.0  15.0  15.0
 19.0  19.0  19.0  19.0
julia&gt; Lat3D
 3×4×3 Array{Float64, 3}:
 [:, :, 1] =
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0

 [:, :, 2] =
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0

 [:, :, 3] =
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0
  1.0  4.0  7.0  10.0
julia&gt; Depth3D
  3×4×3 Array{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}, 3}:
  [:, :, 1] =
   -20.0 km  -20.0 km  -20.0 km  -20.0 km
   -20.0 km  -20.0 km  -20.0 km  -20.0 km
   -20.0 km  -20.0 km  -20.0 km  -20.0 km

  [:, :, 2] =
   -15.0 km  -15.0 km  -15.0 km  -15.0 km
   -15.0 km  -15.0 km  -15.0 km  -15.0 km
   -15.0 km  -15.0 km  -15.0 km  -15.0 km

  [:, :, 3] =
   -10.0 km  -10.0 km  -10.0 km  -10.0 km
   -10.0 km  -10.0 km  -10.0 km  -10.0 km
   -10.0 km  -10.0 km  -10.0 km  -10.0 km
julia&gt; Data        =   zeros(size(Lon3D));
julia&gt; Data_set    =   GeophysicalModelGenerator.GeoData(Lon3D,Lat3D,Depth3D,(DataFieldName=Data,))
GeoData
  size      : (3, 4, 3)
  lon       ϵ [ 11.0 : 19.0]
  lat       ϵ [ 1.0 : 10.0]
  depth     ϵ [ -20.0 km : -10.0 km]
  fields    : (:DataFieldName,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L68-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ParaviewData-Tuple{LaMEM_grid, NamedTuple}" href="#GeophysicalModelGenerator.ParaviewData-Tuple{LaMEM_grid, NamedTuple}"><code>GeophysicalModelGenerator.ParaviewData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParaviewData(Grid::LaMEM_grid, fields::NamedTuple)</code></pre><p>Creates a <code>ParaviewData</code> struct from a LaMEM grid and from fields stored on that grid. Note that one needs to have a field <code>Phases</code> and optionally a field <code>Temp</code> to create LaMEM marker files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProfileData" href="#GeophysicalModelGenerator.ProfileData"><code>GeophysicalModelGenerator.ProfileData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that holds profile data (interpolated/projected on the profile)</p><pre><code class="nohighlight hljs">struct ProfileData
    vertical        ::  Bool # vertical:true, horizontal:false
    start_lonlat    ::  Union{Nothing,Tuple{Float64,Float64}}
    end_lonlat      ::  Union{Nothing,Tuple{Float64,Float64}}
    depth           ::  Union{Nothing,Float64}
    VolData         ::  GeophysicalModelGenerator.GeoData
    SurfData        ::  Union{Nothing, NamedTuple}
    PointData       ::  Union{Nothing, NamedTuple}
end

Structure to store cross section data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectionPoint-Tuple{Float64, Float64, Int64, Bool}" href="#GeophysicalModelGenerator.ProjectionPoint-Tuple{Float64, Float64, Int64, Bool}"><code>GeophysicalModelGenerator.ProjectionPoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ProjectionPoint(EW::Float64, NS::Float64, Zone::Int64, isnorth::Bool)</code></pre><p>Defines a projection point used for map projections, by specifying UTM coordinates (EW/NS), UTM Zone and whether you are on the northern hemisphere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectionPoint-Tuple{}" href="#GeophysicalModelGenerator.ProjectionPoint-Tuple{}"><code>GeophysicalModelGenerator.ProjectionPoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ProjectionPoint(; Lat=49.9929, Lon=8.2473)</code></pre><p>Defines a projection point used for map projections, by specifying latitude and longitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{GeoData}, UTMData}" href="#Base.convert-Tuple{Type{GeoData}, UTMData}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Converts a <code>UTMData</code> structure to a <code>GeoData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L504-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{UTMData}, GeoData}" href="#Base.convert-Tuple{Type{UTMData}, GeoData}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Converts a <code>GeoData</code> structure to a <code>UTMData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L539-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.AboveSurface-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_Cart::CartData, DataSurface_Cart::CartData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1593-L1597">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface-Tuple{CartGrid, CartData}" href="#GeophysicalModelGenerator.AboveSurface-Tuple{CartGrid, CartData}"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Grid::CartGrid, DataSurface_Cart::CartData; above=true)</code></pre><p>Determines if points described by the <code>Grid</code> CartGrid structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1606-L1610">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface-Tuple{GeoData, GeoData}" href="#GeophysicalModelGenerator.AboveSurface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AboveSurface(Data::GeoData, DataSurface::GeoData; above=true)</code></pre><p>Returns a boolean array of size(Data.Lon), which is true for points that are above the surface DataSurface (or for points below if above=false).</p><p>This can be used, for example, to mask points above/below the Moho in a volumetric dataset or in a profile.</p><p><strong>Example</strong></p><p>First we create a 3D data set and a 2D surface:</p><pre><code class="language-julia hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData)
julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,-40km);
julia&gt; Data_Moho       =   GeoData(Lon,Lat,Depth+Lon*km, (MohoDepth=Depth,))
  GeoData
    size  : (11, 11, 1)
    lon   ϵ [ 10.0 : 20.0]
    lat   ϵ [ 30.0 : 40.0]
    depth ϵ [ -30.0 km : -20.0 km]
    fields: (:MohoDepth,)</code></pre><p>Next, we intersect the surface with the data set:</p><pre><code class="language-julia hljs">julia&gt; Above       =   AboveSurface(Data_set3D, Data_Moho);</code></pre><p>Now, <code>Above</code> is a boolean array that is true for points above the surface and false for points below and at the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1513-L1547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface-Tuple{LaMEM_grid, CartData}" href="#GeophysicalModelGenerator.AboveSurface-Tuple{LaMEM_grid, CartData}"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are above the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AboveSurface-Tuple{ParaviewData, ParaviewData}" href="#GeophysicalModelGenerator.AboveSurface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.AboveSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Above = AboveSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData; above=true)</code></pre><p>Determines if points within the 3D <code>Data_Cart</code> structure are above the Cartesian surface <code>DataSurface_Cart</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1580-L1584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddBox!-Tuple{Any, Any, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.AddBox!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.AddBox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddBox!(Phase, Temp, Grid::AbstractGeneralGrid; xlim=Tuple{2}, [ylim=Tuple{2}], zlim=Tuple{2},
        Origin=nothing, StrikeAngle=0, DipAngle=0,
        phase = ConstantPhase(1),
        T=nothing )</code></pre><p>Adds a box with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array (consistent with Grid)</li><li>Temp  - Temperature array (consistent with Grid)</li><li>Grid -  grid structure (usually obtained with ReadLaMEM_InputFile, but can also be other grid types)</li><li>xlim -  left/right coordinates of box</li><li>ylim -  front/back coordinates of box [optional; if not specified we use the whole box]</li><li>zlim -  bottom/top coordinates of box</li><li>Origin - the origin, used to rotate the box around. Default is the left-front-top corner</li><li>StrikeAngle - strike angle of slab</li><li>DipAngle - dip angle of slab</li><li>phase - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li>T - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code>,<code>LithosphericTemp()</code></li></ul><p><strong>Examples</strong></p><p>Example 1) Box with constant phase and temperature &amp; a dip angle of 10 degrees:</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddBox!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre><p>Example 2) Box with halfspace cooling profile</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddBox!(Phases,Temp,Grid, xlim=(0,500), zlim=(-50,0), phase=ConstantPhase(3), DipAngle=10, T=ConstantTemp(1000))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L19-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddCylinder!-Tuple{Any, Any, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.AddCylinder!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.AddCylinder!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddCylinder!(Phase, Temp, Grid::AbstractGeneralGrid; base=Tuple{3}, cap=Tuple{3}, radius=Tuple{1},
        phase = ConstantPhase(1).
        T=nothing )</code></pre><p>Adds a cylinder with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array (consistent with Grid)</li><li>Temp  - Temperature array (consistent with Grid)</li><li>Grid - Grid structure (usually obtained with ReadLaMEM_InputFile)</li><li>base - center coordinate of bottom of cylinder</li><li>cap - center coordinate of top of cylinder</li><li>radius - radius of the cylinder</li><li>phase - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li>T - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li></ul><p><strong>Example</strong></p><p>Cylinder with constant phase and temperature:</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddCylinder!(Phases,Temp,Grid, base=(-1,-1,-1.5), cap=(1,1,-0.5), radius=0.25, phase=ConstantPhase(4), T=ConstantTemp(400))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L372-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddEllipsoid!-Tuple{Any, Any, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.AddEllipsoid!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.AddEllipsoid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddEllipsoid!(Phase, Temp, Grid::AbstractGeneralGrid; cen=Tuple{3}, axes=Tuple{3},
        Origin=nothing, StrikeAngle=0, DipAngle=0,
        phase = ConstantPhase(1).
        T=nothing )</code></pre><p>Adds an Ellipsoid with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array (consistent with Grid)</li><li>Temp  - Temperature array (consistent with Grid)</li><li>Grid - LaMEM grid structure (usually obtained with ReadLaMEM_InputFile)</li><li>cen - center coordinates of sphere</li><li>axes - semi-axes of ellipsoid in X,Y,Z</li><li>Origin - the origin, used to rotate the box around. Default is the left-front-top corner</li><li>StrikeAngle - strike angle of slab</li><li>DipAngle - dip angle of slab</li><li>phase - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li>T - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li></ul><p><strong>Example</strong></p><p>Ellipsoid with constant phase and temperature, rotated 90 degrees and tilted by 45 degrees:</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddEllipsoid!(Phases,Temp,Grid, cen=(-1,-1,-1), axes=(0.2,0.1,0.5), StrikeAngle=90, DipAngle=45, phase=ConstantPhase(3), T=ConstantTemp(600))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L288-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddField-Tuple{AbstractGeneralGrid, String, Any}" href="#GeophysicalModelGenerator.AddField-Tuple{AbstractGeneralGrid, String, Any}"><code>GeophysicalModelGenerator.AddField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">V = AddField(V::AbstractGeneralGrid,field_name::String,data::Any)</code></pre><p>Add Fields Data to GeoData or CartData</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddLayer!-Tuple{Any, Any, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.AddLayer!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.AddLayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddLayer!(Phase, Temp, Grid::AbstractGeneralGrid; xlim=Tuple{2}, [ylim=Tuple{2}], zlim=Tuple{2},
        phase = ConstantPhase(1),
        T=nothing )</code></pre><p>Adds a layer with phase &amp; temperature structure to a 3D model setup. The most common use would be to add a lithospheric layer to a model setup. This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array (consistent with Grid)</li><li>Temp  - Temperature array (consistent with Grid)</li><li>Grid -  grid structure (usually obtained with ReadLaMEM_InputFile, but can also be other grid types)</li><li>xlim -  left/right coordinates of box</li><li>ylim -  front/back coordinates of box</li><li>zlim -  bottom/top coordinates of box</li><li>phase - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li>T - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li></ul><p><strong>Examples</strong></p><p>Example 1) Layer with constant phase and temperature</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddLayer!(Phases,Temp,Grid, zlim=(-50,0), phase=ConstantPhase(3), T=ConstantTemp(1000))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre><p>Example 2) Box with halfspace cooling profile</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddLayer!(Phases,Temp,Grid, zlim=(-50,0), phase=ConstantPhase(3), T=HalfspaceCoolingTemp())
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L125-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddSphere!-Tuple{Any, Any, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.AddSphere!-Tuple{Any, Any, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.AddSphere!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddSphere!(Phase, Temp, Grid::AbstractGeneralGrid; cen=Tuple{3}, radius=Tuple{1},
        phase = ConstantPhase(1).
        T=nothing )</code></pre><p>Adds a sphere with phase &amp; temperature structure to a 3D model setup.  This simplifies creating model geometries in geodynamic models</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array (consistent with Grid)</li><li>Temp  - Temperature array (consistent with Grid)</li><li>Grid - LaMEM grid structure (usually obtained with ReadLaMEM_InputFile)</li><li>cen - center coordinates of sphere</li><li>radius - radius of sphere</li><li>phase - specifies the phase of the box. See <code>ConstantPhase()</code>,<code>LithosphericPhases()</code></li><li>T - specifies the temperature of the box. See <code>ConstantTemp()</code>,<code>LinearTemp()</code>,<code>HalfspaceCoolingTemp()</code>,<code>SpreadingRateTemp()</code></li></ul><p><strong>Example</strong></p><p>Sphere with constant phase and temperature:</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Phases = zeros(Int32,   size(Grid.X));
julia&gt; Temp   = zeros(Float64, size(Grid.X));
julia&gt; AddSphere!(Phases,Temp,Grid, cen=(0,0,-1), radius=0.5, phase=ConstantPhase(2), T=ConstantTemp(800))
julia&gt; Model3D = ParaviewData(Grid, (Phases=Phases,Temp=Temp)); # Create Cartesian model
julia&gt; Write_Paraview(Model3D,&quot;LaMEM_ModelSetup&quot;)           # Save model to paraview
1-element Vector{String}:
 &quot;LaMEM_ModelSetup.vts&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L225-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddSurfaces!-Tuple{Union{CartData, ParaviewData}, Union{CartData, ParaviewData}}" href="#GeophysicalModelGenerator.AddSurfaces!-Tuple{Union{CartData, ParaviewData}, Union{CartData, ParaviewData}}"><code>GeophysicalModelGenerator.AddSurfaces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddSurfaces!(Surface1::Union{CartData,ParaviewData}, Surface2::Union{CartData,ParaviewData})</code></pre><p>Adds <code>Surface2</code> to <code>Surface1</code>. The addition happens on the <code>Surface1.z</code>; the fields remain unchanged</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1965-L1970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.AddSurfaces!-Tuple{Union{GeoData, UTMData}, Union{GeoData, UTMData}}" href="#GeophysicalModelGenerator.AddSurfaces!-Tuple{Union{GeoData, UTMData}, Union{GeoData, UTMData}}"><code>GeophysicalModelGenerator.AddSurfaces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AddSurfaces!(Surface1::Union{GeoData,UTMData}, Surface2::Union{GeoData,UTMData})</code></pre><p>Adds <code>Surface2</code> to <code>Surface1</code>. The addition happens on the <code>Surface1.depth</code>; the fields remain unchanged</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1952-L1957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.BelowSurface-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_Cart::CartData, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D Data<em>Cart structure are below the Cartesian surface DataSurface</em>Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1639-L1643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface-Tuple{CartGrid, CartData}" href="#GeophysicalModelGenerator.BelowSurface-Tuple{CartGrid, CartData}"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Grid::CartGrid, DataSurface_Cart::CartData)

Determines if points described by the `Grid` CartGrid structure are above the Cartesian surface `DataSurface_Cart`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1620-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface-Tuple{GeoData, GeoData}" href="#GeophysicalModelGenerator.BelowSurface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data::GeoData, DataSurface::GeoData)</code></pre><p>Determines if points within the 3D <code>Data</code> structure are below the GeoData surface <code>DataSurface</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1571-L1575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface-Tuple{LaMEM_grid, CartData}" href="#GeophysicalModelGenerator.BelowSurface-Tuple{LaMEM_grid, CartData}"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_LaMEM::LaMEM_grid, DataSurface_Cart::CartData)</code></pre><p>Determines if points within the 3D <code>LaMEM_grid</code> structure are below the Cartesian surface DataSurface_Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.BelowSurface-Tuple{ParaviewData, ParaviewData}" href="#GeophysicalModelGenerator.BelowSurface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.BelowSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Below = BelowSurface(Data_Cart::ParaviewData, DataSurface_Cart::ParaviewData)</code></pre><p>Determines if points within the 3D Data<em>Cart structure are below the Cartesian surface DataSurface</em>Cart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1630-L1634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Compute_Phase-Tuple{Any, Any, Any, Any, Any, LithosphericPhases}" href="#GeophysicalModelGenerator.Compute_Phase-Tuple{Any, Any, Any, Any, Any, LithosphericPhases}"><code>GeophysicalModelGenerator.Compute_Phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Phase = Compute_Phase(Phase, Temp, X, Y, Z, s::LithosphericPhases, Ztop)</code></pre><p>or</p><pre><code class="nohighlight hljs">Phase = Compute_Phase(Phase, Temp, Grid::AbstractGeneralGrid, s::LithosphericPhases)</code></pre><p>This copies the layered lithosphere onto the Phase matrix.</p><p><strong>Parameters</strong></p><ul><li>Phase - Phase array</li><li>Temp  - Temperature array</li><li>X     - x-coordinate array (consistent with Phase and Temp)</li><li>Y     - y-coordinate array (consistent with Phase and Temp)</li><li>Z     - Vertical coordinate array (consistent with Phase and Temp)</li><li>s     - LithosphericPhases</li><li>Ztop  - Vertical coordinate of top of model box</li><li>Grid  - Grid structure (usually obtained with ReadLaMEM_InputFile)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L991-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2CartData-Tuple{GeoData, ProjectionPoint}" href="#GeophysicalModelGenerator.Convert2CartData-Tuple{GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.Convert2CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convert2CartData(d::GeoData, proj::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L834-L837">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2CartData-Tuple{UTMData, ProjectionPoint}" href="#GeophysicalModelGenerator.Convert2CartData-Tuple{UTMData, ProjectionPoint}"><code>GeophysicalModelGenerator.Convert2CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convert2CartData(d::UTMData, proj::ProjectionPoint)</code></pre><p>Converts a <code>UTMData</code> structure to a <code>CartData</code> structure, which essentially transfers the dimensions to km</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L816-L819">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2UTMzone-Tuple{CartData, ProjectionPoint}" href="#GeophysicalModelGenerator.Convert2UTMzone-Tuple{CartData, ProjectionPoint}"><code>GeophysicalModelGenerator.Convert2UTMzone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convert2UTMzone(d::CartData, proj::ProjectionPoint)</code></pre><p>This transfers a <code>CartData</code> dataset to a <code>UTMData</code> dataset, that has a single UTM zone. The point around which we project is <code>ProjectionPoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L804-L808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Convert2UTMzone-Tuple{GeoData, ProjectionPoint}" href="#GeophysicalModelGenerator.Convert2UTMzone-Tuple{GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.Convert2UTMzone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convert2UTMzone(d::GeoData, p::ProjectionPoint)</code></pre><p>Converts a <code>GeoData</code> structure to fixed UTM zone, around a given <code>ProjectionPoint</code>     This useful to use real data as input for a cartesian geodynamic model setup (such as in LaMEM). In that case, we need to project map coordinates to cartesian coordinates.     One way to do this is by using UTM coordinates. Close to the <code>ProjectionPoint</code> the resulting coordinates will be rectilinear and distance in meters. The map distortion becomes larger the further you are away from the center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L597-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Create1D_grid_vector-Tuple{Vector{Float64}, Int64, Int64, Union{Nothing, Int64}, Union{Nothing, Float64}}" href="#GeophysicalModelGenerator.Create1D_grid_vector-Tuple{Vector{Float64}, Int64, Int64, Union{Nothing, Int64}, Union{Nothing, Float64}}"><code>GeophysicalModelGenerator.Create1D_grid_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns 1D coordinate vectors of grid points and of marker locations for a regular spacing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L258-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Create1D_grid_vector-Union{Tuple{I}, Tuple{T}, Tuple{Vector{T}, Vector{I}, I, I, Union{Nothing, Vector{T}, T}}} where {T&lt;:Float64, I&lt;:Int64}" href="#GeophysicalModelGenerator.Create1D_grid_vector-Union{Tuple{I}, Tuple{T}, Tuple{Vector{T}, Vector{I}, I, I, Union{Nothing, Vector{T}, T}}} where {T&lt;:Float64, I&lt;:Int64}"><code>GeophysicalModelGenerator.Create1D_grid_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns 1D coordinate vectors of grid points and of marker locations for a regular spacing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L272-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CreateCartGrid-Tuple{}" href="#GeophysicalModelGenerator.CreateCartGrid-Tuple{}"><code>GeophysicalModelGenerator.CreateCartGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid = CreateCartGrid(; size=(), x = nothing, z = nothing, y = nothing, extent = nothing, CharDim = nothing)</code></pre><p>Creates a 1D, 2D or 3D cartesian grid of given size. Grid can be created by defining the size and either the <code>extent</code> (length) of the grid in all directions, or by defining start &amp; end points (<code>x</code>,<code>y</code>,<code>z</code>). If you specify <code>CharDim</code> (a structure with characteristic dimensions created with <code>GeoParams.jl</code>), we will nondimensionalize the grd before creating the struct.</p><p>Spacing is assumed to be constant in a given direction</p><p>This can also be used for staggered grids, as we also create 1D vectors for the central points. The points you indicate in <code>size</code> are the corner points.</p><p>Note: since this is mostly for solid Earth geoscience applications, the second dimension is called z (vertical)</p><p><strong>Examples</strong></p><p>====</p><p>A basic case with non-dimensional units:</p><pre><code class="language-julia hljs">julia&gt; Grid = CreateCartGrid(size=(10,20),x=(0.,10), z=(2.,10))
Grid{Float64, 2}
           size: (10, 20)
         length: (10.0, 8.0)
         domain: x ∈ [0.0, 10.0], z ∈ [2.0, 10.0]
 grid spacing Δ: (1.1111111111111112, 0.42105263157894735)</code></pre><p>An example with dimensional units:</p><pre><code class="language-julia hljs">julia&gt; CharDim = GEO_units()
julia&gt; Grid    = CreateCartGrid(size=(10,20),x=(0.0km, 10km), z=(-20km, 10km), CharDim=CharDim)
CartGrid{Float64, 2}
           size: (10, 20)
         length: (0.01, 0.03)
         domain: x ∈ [0.0, 0.01], z ∈ [-0.02, 0.01]
 grid spacing Δ: (0.0011111111111111111, 0.0015789473684210528)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1037-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CreatePartitioningFile-Tuple{String, Int64}" href="#GeophysicalModelGenerator.CreatePartitioningFile-Tuple{String, Int64}"><code>GeophysicalModelGenerator.CreatePartitioningFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CreatePartitioningFile(LaMEM_input::String, NumProc::Int64; LaMEM_dir::String=pwd(), LaMEM_options::String=&quot;&quot;, MPI_dir=&quot;&quot;, verbose=true)</code></pre><p>This executes LaMEM for the input file <code>LaMEM_input</code> &amp; creates a parallel partitioning file for <code>NumProc</code> processors. The directory where the LaMEM binary is can be specified; if not it is assumed to be in the current directory. Likewise for the <code>mpiexec</code> directory (if not specified it is assumed to be available on the command line).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L974-L981">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CreateProfileVolume!-Tuple{ProfileData, AbstractGeneralGrid}" href="#GeophysicalModelGenerator.CreateProfileVolume!-Tuple{ProfileData, AbstractGeneralGrid}"><code>GeophysicalModelGenerator.CreateProfileVolume!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CreateProfileVolume!(Profile::ProfileData, VolData::AbstractGeneralGrid; DimsVolCross::NTuple=(100,100), Depth_extent=nothing)</code></pre><p>Creates a cross-section through a volumetric 3D dataset <code>VolData</code> with the data supplied in <code>Profile</code>. <code>Depth_extent</code> can be the minimum &amp; maximum depth for vertical profiles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CrossSection-Tuple{AbstractGeneralGrid}" href="#GeophysicalModelGenerator.CrossSection-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.CrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CrossSection(DataSet::AbstractGeneralGrid; dims=(100,100), Interpolate=false, Depth_level=nothing, Lat_level=nothing, Lon_level=nothing, Start=nothing, End=nothing, Depth_extent=nothing, section_width=50km)</code></pre><p>Creates a cross-section through a <code>GeoData</code> object.</p><ul><li>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</li><li>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</li><li>Depending on the type of input data (volume, surface or point data), cross sections will be created in a different manner:</li></ul><ol><li>Volume data: data will be interpolated or directly extracted from the data set.</li><li>Surface data: surface data will be interpolated or directly extracted from the data set</li><li>Point data: data will be projected to the chosen profile. Only data within a chosen distance (default is 50 km) will be used</li></ol><ul><li><code>Interpolate</code> indicates whether we want to simply extract the data from the data set (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in <code>dims</code> NOTE: THIS ONLY APPLIES TO VOLUMETRIC AND SURFACE DATA SETS</li><li>&#39;section_width&#39; indicates the maximal distance within which point data will be projected to the profile</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz))); 
julia&gt; Data_cross      =   CrossSection(Data_set3D, Depth_level=-100km)  
GeoData 
  size  : (11, 11, 1)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -100.0 km : -100.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L485-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CrossSectionPoints-Tuple{GeoData}" href="#GeophysicalModelGenerator.CrossSectionPoints-Tuple{GeoData}"><code>GeophysicalModelGenerator.CrossSectionPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function CrossSectionPoints(P::GeoData; Depth_level=nothing, Lat_level=nothing, Lon_level=nothing, Start=nothing, End=nothing, section_width=50 )</code></pre><p>Creates a projection of separate points (saved as a GeoData object) onto a chosen plane. Only points with a maximum distance of section_width are taken into account</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L318-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CrossSectionSurface-Tuple{AbstractGeneralGrid}" href="#GeophysicalModelGenerator.CrossSectionSurface-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.CrossSectionSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><p>CrossSectionSurface(Surface::GeoData; dims=(100,), Interpolate=false, Depth<em>level=nothing; Lat</em>level=nothing; Lon_level=nothing; Start=nothing, End=nothing )</p><p>Creates a cross-section through a surface (2D) <code>GeoData</code> object.</p><ul><li><p>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</p></li><li><p>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</p></li><li><p>IMPORTANT: The surface to be extracted has to be given as a gridded GeoData object. It may also contain NaNs where it is not defined. Any points lying outside of the defined surface will be considered NaN.</p></li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,-50km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set2D      =   GeoData(Lon,Lat,Depth,(Depth=Depth,));
julia&gt; Data_cross      =   CrossSectionSurface(Data_set2D, Lat_level =15)
GeoData
  size      : (100,)
  lon       ϵ [ 10.0 : 20.0]
  lat       ϵ [ 15.0 : 15.0]
  depth     ϵ [ NaN : NaN]
  fields    : (:Depth,)
  attributes: [&quot;note&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L213-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.CrossSectionVolume-Tuple{AbstractGeneralGrid}" href="#GeophysicalModelGenerator.CrossSectionVolume-Tuple{AbstractGeneralGrid}"><code>GeophysicalModelGenerator.CrossSectionVolume</code></a> — <span class="docstring-category">Method</span></header><section><div><p>CrossSectionVolume(Volume::AbstractGeneralGrid; dims=(100,100), Interpolate=false, Depth<em>level=nothing; Lat</em>level=nothing; Lon<em>level=nothing; Start=nothing, End=nothing, Depth</em>extent=nothing )</p><p>Creates a cross-section through a volumetric (3D) <code>GeoData</code> object.</p><ul><li>Cross-sections can be horizontal (map view at a given depth), if <code>Depth_level</code> is specified</li><li>They can also be vertical, either by specifying <code>Lon_level</code> or <code>Lat_level</code> (for a fixed lon/lat), or by defining both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> points.</li><li>When both <code>Start=(lon,lat)</code> &amp; <code>End=(lon,lat)</code> are given, one can also provide a the depth extent of the profile by providing Depth<em>extent=(depth</em>min,depth_max)</li><li><code>Interpolate</code> indicates whether we want to simply extract the data from the 3D volume (default) or whether we want to linearly interpolate it on a new grid, which has dimensions as specified in <code>dims</code></li><li><code>Depth_extent</code> is an optional parameter that can indicate the depth extent over which you want to interpolate the vertical cross-section. Default is the full vertical extent of the 3D dataset</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)));
julia&gt; Data_cross      =   CrossSectionVolume(Data_set3D, Depth_level=-100km)
GeoData
  size  : (11, 11, 1)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -100.0 km : -100.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L82-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.DrapeOnTopo-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.DrapeOnTopo-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.DrapeOnTopo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DrapeOnTopo(Topo::CartData, Data::CartData)</code></pre><p>Drapes Cartesian Data on topography</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1918-L1922">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.DrapeOnTopo-Tuple{GeoData, GeoData}" href="#GeophysicalModelGenerator.DrapeOnTopo-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.DrapeOnTopo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Topo = DrapeOnTopo(Topo::GeoData, Data::GeoData)</code></pre><p>This drapes fields of a data set <code>Data</code> on the topography <code>Topo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1844-L1850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ExtractProfileData!" href="#GeophysicalModelGenerator.ExtractProfileData!"><code>GeophysicalModelGenerator.ExtractProfileData!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ExtractProfileData!(Profile::ProfileData,VolData::GeoData, SurfData::NamedTuple, PointData::NamedTuple; DimsVolCross=(100,100),Depth_extent=nothing,DimsSurfCross=(100,),section_width=50)</code></pre><p>Extracts data along a vertical or horizontal profile</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ExtractProfileData-Tuple{String, Int64, String}" href="#GeophysicalModelGenerator.ExtractProfileData-Tuple{String, Int64, String}"><code>GeophysicalModelGenerator.ExtractProfileData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtractProfileData(ProfileCoordFile::String,ProfileNumber::Int64,DataSetFile::String; DimsVolCross=(100,100),DepthVol=nothing,DimsSurfCross=(100,),WidthPointProfile=50km)</code></pre><p>This is a convenience function (mostly for backwards compatibility with the MATLAB GUI) that loads the data from file &amp; projects it onto a profile</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ExtractSubvolume-Tuple{CartData}" href="#GeophysicalModelGenerator.ExtractSubvolume-Tuple{CartData}"><code>GeophysicalModelGenerator.ExtractSubvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtractSubvolume(V::CartData; Interpolate=false, X_level=nothing, Y_level=nothing, Z_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>2D Example along a cross-section through 3D data:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X,Y,Z = XYZGrid(10:20,30:40,-300:25:0);
julia&gt; Data = Z.*2
julia&gt; Data_Int = Int64.(Data)
julia&gt; DataSet_Cart = CartData(X,Y,Z,(Data=Data,Data_Int=Data_Int, Velocity=(X,Y,Z)))

julia&gt; Data_cross = CrossSection(DataSet_Cart, Start=(11.0,35), End=(19, 39.0))
CartData
    size    : (100, 100, 1)
    x       ϵ [ 11.0 : 19.0]
    y       ϵ [ 35.0 : 39.0]
    z       ϵ [ -300.0 : 0.0]
    fields  : (:Data, :Data_Int, :Velocity, :FlatCrossSection)
  attributes: [&quot;note&quot;]

julia&gt; Data_extracted = ExtractSubvolume(Data_cross, X_level=(1,7), Z_level=(-200,-100))
  CartData
      size    : (50, 50, 1)
      x       ϵ [ 11.894427190999917 : 17.260990336999413]
      y       ϵ [ 35.44721359549995 : 38.130495168499706]
      z       ϵ [ -200.0 : -100.0]
      fields  : (:FlatCrossSection, :Data, :Data_Int, :Velocity)
    attributes: [&quot;note&quot;]
julia&gt; typeof(Data_extracted.fields.Data_Int)
    Array{Int64, 3}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L685-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ExtractSubvolume-Tuple{GeoData}" href="#GeophysicalModelGenerator.ExtractSubvolume-Tuple{GeoData}"><code>GeophysicalModelGenerator.ExtractSubvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtractSubvolume(V::GeoData; Interpolate=false, Lon_level=nothing, Lat_level=nothing, Depth_level=nothing, dims=(50,50,50))</code></pre><p>Extract or &quot;cuts-out&quot; a piece of a 2D or 3D GeoData set, defined by <code>Lon</code>, <code>Lat</code> and <code>Depth</code> coordinates.</p><p>This is useful if you are only interested in a part of a much bigger larger data set.</p><ul><li><code>Lon_level</code>,<code>Lat_level</code> and <code>Depth_level</code> should be tuples that indicate <code>(minimum_value, maximum_value)</code> along the respective direction. If not specified we use the full range.</li><li>By default, <code>Interpolate=false</code> and we find the closest indices within the data set (so your new data set will not go exactly from minimum to maximum).</li><li>Alternatively, if <code>Interpolate=true</code> we interpolate the data onto a new grid that has dimensions <code>dims</code>. This can be useful to compare data sets that are originally given in different resolutions.</li></ul><p><strong>3D Example with no interpolation:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)))
GeoData
  size  : (11, 11, 13)
  lon   ϵ [ 10.0 : 20.0]
  lat   ϵ [ 30.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)
julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40))
GeoData
  size  : (3, 6, 13)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre><p>By default it extracts the data points closest to the area defined by Lon<em>level/Lat</em>level/Depth_level.</p><p><strong>3D Example with interpolation:</strong></p><p>Alternatively, you can also interpolate the data onto a new grid:</p><pre><code class="language-julia hljs">julia&gt; Data_extracted = ExtractSubvolume(Data_set3D,Lon_level=(10,12),Lat_level=(35,40), Interpolate=true, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 10.0 : 12.0]
  lat   ϵ [ 35.0 : 40.0]
  depth ϵ [ -300.0 km : 0.0 km]
  fields: (:Depthdata, :LonData, :Velocity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L601-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.FlattenCrossSection-Tuple{CartData}" href="#GeophysicalModelGenerator.FlattenCrossSection-Tuple{CartData}"><code>GeophysicalModelGenerator.FlattenCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FlattenCrossSection(V::CartData)</code></pre><p>Takes a diagonal 3D CrossSection and flattens it to be converted to a 2D Grid by CreateCartGrid</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Grid                    = CreateCartGrid(size=(100,100,100), x=(0.0km, 99.9km), y=(-10.0km, 20.0km), z=(-40km,4km));
X,Y,Z                   = XYZGrid(Grid.coord1D...);
DataSet                 = CartData(X,Y,Z,(Depthdata=Z,));

Data_Cross              = CrossSection(DataSet, dims=(100,100), Interpolate=true, Start=(ustrip(Grid.min[1]),ustrip(Grid.max[2])), End=(ustrip(Grid.max[1]), ustrip(Grid.min[2])))

x_new = FlattenCrossSection(Data_Cross)

This flattened CrossSection can be added to original Data_Cross by AddField()

Data_Cross = AddField(Data_Cross,&quot;FlatCrossSection&quot;, x_new)
CartData
    size    : (100, 100, 1)
    x       ϵ [ 0.0 : 99.9]
    y       ϵ [ -10.0 : 20.0]
    z       ϵ [ -40.0 : 4.0]
    fields  : (:Depthdata, :FlatCrossSection)
  attributes: [&quot;note&quot;]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L534-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.FlattenCrossSection-Tuple{GeoData}" href="#GeophysicalModelGenerator.FlattenCrossSection-Tuple{GeoData}"><code>GeophysicalModelGenerator.FlattenCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FlattenCrossSection(V::GeoData)
This function takes a 3D cross section through a GeoData structure and computes the distance along the cross section for later 2D processing/plotting
```julia-repl
julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data            =   Depth*2;                # some data
julia&gt; Vx,Vy,Vz        =   ustrip(Data*3),ustrip(Data*4),ustrip(Data*5);
julia&gt; Data_set3D      =   GeoData(Lon,Lat,Depth,(Depthdata=Data,LonData=Lon, Velocity=(Vx,Vy,Vz)));
julia&gt; Data_cross      =   CrossSection(Data_set3D, Start=(10,30),End=(20,40))
julia&gt; x_profile       =   FlattenCrossSection(Data_cross)
julia&gt; Data_cross      =   AddField(Data_cross,&quot;x_profile&quot;,x_profile)

```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L571-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.GetLonLatDepthMag_QuakeML-Tuple{String}" href="#GeophysicalModelGenerator.GetLonLatDepthMag_QuakeML-Tuple{String}"><code>GeophysicalModelGenerator.GetLonLatDepthMag_QuakeML</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data = GetLonLatDepthMag_QuakeML(filename::String)</code></pre><p>Extracts longitude, latitude, depth and magnitude from a QuakeML file that has been e.g. downloaded from ISC. The data is then returned in GeoData format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_import.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.GetProcessorPartitioning-Tuple{Any}" href="#GeophysicalModelGenerator.GetProcessorPartitioning-Tuple{Any}"><code>GeophysicalModelGenerator.GetProcessorPartitioning</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nProcX,nProcY,nProcZ, xc,yc,zc, nNodeX,nNodeY,nNodeZ = GetProcessorPartitioning(filename; is64bit=false)</code></pre><p>Reads a LaMEM processor partitioning file, used to create marker files, and returns the parallel layout. By default this is done for a 32bit PETSc installation, which will fail if you actually use a 64bit version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L559-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields-Tuple{AbstractGeneralGrid, Any, Any, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields-Tuple{AbstractGeneralGrid, Any, Any, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data_interp = InterpolateDataFields(V::AbstractGeneralGrid, Lon, Lat, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>Lon,Lat,Depth</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x        =   0:2:10
julia&gt; y        =   -5:5
julia&gt; z        =   -10:2:2
julia&gt; X,Y,Z    =   XYZGrid(x, y, z);
julia&gt; Data     =   Z
julia&gt; Data_set1=   CartData(X,Y,Z, (FakeData=Data,Data2=Data.+1.))
CartData
    size    : (6, 11, 7)
    x       ϵ [ 0.0 km : 10.0 km]
    y       ϵ [ -5.0 km : 5.0 km]
    z       ϵ [ -10.0 km : 2.0 km]
    fields  : (:FakeData, :Data2)
  attributes: [&quot;note&quot;]

julia&gt; X,Y,Z    =   XYZGrid(0:4:10, -1:.1:1, -5:.1:1 );
julia&gt; Data_set2= InterpolateDataFields(Data_set1, X,Y,Z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L909-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields-Tuple{UTMData, Any, Any, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields-Tuple{UTMData, Any, Any, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields(V::UTMData, EW, NS, Depth)</code></pre><p>Interpolates a data field <code>V</code> on a grid defined by <code>UTM,Depth</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1001-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{CartData, Any, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{CartData, Any, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D(V::CartData, X, Y)</code></pre><p>Interpolates a data field <code>V</code> on a 2D CartData grid defined by <code>X</code>,<code>Y</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1137-L1141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.InterpolateDataFields2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D(Original::CartData, New::CartData; Rotate=0.0, Translate=(0,0,0), Scale=(1.0,1.0,1.0))</code></pre><p>Interpolates a data field <code>Original</code> on a 2D CartData grid <code>New</code>. Typically used for horizontal surfaces.</p><p>Note: <code>Original</code> should have orthogonal coordinates. If it has not, e.g., because it was rotated, you&#39;ll have to specify the angle <code>Rotate</code> that it was rotated by</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1148-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{GeoData, AbstractRange, AbstractRange}" href="#GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{GeoData, AbstractRange, AbstractRange}"><code>GeophysicalModelGenerator.InterpolateDataFields2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Surf_interp = InterpolateDataFields2D(V::GeoData, x::AbstractRange, y::AbstractRange;  Lat::Number, Lon::Number)</code></pre><p>Interpolates a 3D data set <code>V</code> with a projection point <code>proj=(Lat, Lon)</code> on a plane defined by <code>x</code> and <code>y</code>, where <code>x</code> and <code>y</code> are uniformly spaced. Returns the 2D array <code>Surf_interp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1176-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{GeoData, Any, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{GeoData, Any, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D(V::GeoData, Lon, Lat)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>Lon,Lat</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1061-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{UTMData, Any, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields2D-Tuple{UTMData, Any, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D(V::UTMData, EW, NS)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>UTM</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1126-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields2D_vecs-NTuple{6, Any}" href="#GeophysicalModelGenerator.InterpolateDataFields2D_vecs-NTuple{6, Any}"><code>GeophysicalModelGenerator.InterpolateDataFields2D_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields2D_vecs(x_vec, y_vec, depth, fields_new, X, Y)</code></pre><p>Interpolates a data field <code>V</code> on a 2D grid defined by <code>UTM</code>. Typically used for horizontal surfaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1194-L1198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataFields_CrossSection-Tuple{CartData, Vararg{Any, 4}}" href="#GeophysicalModelGenerator.InterpolateDataFields_CrossSection-Tuple{CartData, Vararg{Any, 4}}"><code>GeophysicalModelGenerator.InterpolateDataFields_CrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolateDataFields_CrossSection(V::CartData, X,Y,Z,Xcross)</code></pre><p>Interpolates data fields along a cross-section defined by <code>Xcross</code> and <code>Z</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L826-L830">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataOnSurface-Tuple{GeoData, GeoData}" href="#GeophysicalModelGenerator.InterpolateDataOnSurface-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.InterpolateDataOnSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Surf_interp = InterpolateDataOnSurface(V::GeoData, Surf::GeoData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1335-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.InterpolateDataOnSurface-Tuple{ParaviewData, ParaviewData}" href="#GeophysicalModelGenerator.InterpolateDataOnSurface-Tuple{ParaviewData, ParaviewData}"><code>GeophysicalModelGenerator.InterpolateDataOnSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Surf_interp = InterpolateDataOnSurface(V::ParaviewData, Surf::ParaviewData)</code></pre><p>Interpolates a 3D data set <code>V</code> on a surface defined by <code>Surf</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Data
ParaviewData
  size  : (33, 33, 33)
  x     ϵ [ -3.0 : 3.0]
  y     ϵ [ -2.0 : 2.0]
  z     ϵ [ -2.0 : 0.0]
  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)
julia&gt; surf
ParaviewData
  size  : (96, 96, 1)
  x     ϵ [ -2.9671875 : 3.2671875]
  y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
  z     ϵ [ -1.5353766679763794 : -0.69925457239151]
  fields: (:Depth,)
julia&gt; Surf_interp = InterpolateDataOnSurface(Data, surf)
  ParaviewData
    size  : (96, 96, 1)
    x     ϵ [ -2.9671875 : 3.2671875]
    y     ϵ [ -1.9791666666666667 : 1.9791666666666667]
    z     ϵ [ -1.5353766679763794 : -0.69925457239151]
    fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1274-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.IsInsideClosedSTL" href="#GeophysicalModelGenerator.IsInsideClosedSTL"><code>GeophysicalModelGenerator.IsInsideClosedSTL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inside = IsInsideClosedSTL(mesh::Mesh, Pt, eps=1e-3)</code></pre><p>Determine whether a point <code>Pt</code> is inside a 3D closed triangular <code>*.stl</code> surface or not.</p><p>This implements the winding number method, following the python code: https://github.com/marmakoide/inside-3d-mesh</p><p>This again is described in the following <a href="https://igl.ethz.ch/projects/winding-number/">paper</a> by Alec Jacobson, Ladislav Kavan and Olga Sorkine-Hornung.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/stl.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.LithostaticPressure!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}, Number}} where {T, N}" href="#GeophysicalModelGenerator.LithostaticPressure!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}, Number}} where {T, N}"><code>GeophysicalModelGenerator.LithostaticPressure!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LithostaticPressure!(Plithos::Array, Density::Array, dz::Number; g=9.81)</code></pre><p>Computes lithostatic pressure from a 3D density array, assuming constant soacing <code>dz</code> in vertical direction. Optionally, the gravitational acceleration <code>g</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1934-L1939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Load_Dataset_file-Tuple{String}" href="#GeophysicalModelGenerator.Load_Dataset_file-Tuple{String}"><code>GeophysicalModelGenerator.Load_Dataset_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Datasets = Load_Dataset_file(file_datasets::String)</code></pre><p>This loads a CSV textfile that lists datasets, which is expected to have the following format:</p><ul><li><code>Name</code>,<code>Location</code>,<code>Type</code>, <code>[Active]</code></li><li>AlpArray,./Seismicity/ALPARRAY/AlpArraySeis.jld2,Point, true</li><li>Plomerova2022,https://seafile.rlp.net/f/abccb8d3302b4ef5af17/?dl=1,Volume</li></ul><p>Note that the first line of the file is skipped.</p><p>Here, the meaning of the variables is:</p><ul><li><code>Name</code>: The name of the dataset to be loaded</li><li><code>Location</code>: the location of the file (directory and filename) on your local machine, or an url where we can download the file from the web. The url is expected to start with &quot;http&quot;.</li><li><code>Type</code>: type of the dataset (Volume, Surface, Point, Screenshot)</li><li><code>Active</code>: Do we want this file to be loaded or not? Optional parameter that defaults to <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L134-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.LonLatDepthGrid-Tuple{Any, Any, Any}" href="#GeophysicalModelGenerator.LonLatDepthGrid-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.LonLatDepthGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lon, Lat, Depth = LonLatDepthGrid(Lon::Any, Lat::Any, Depth:Any)</code></pre><p>Creates 3D arrays of <code>Lon</code>, <code>Lat</code>, <code>Depth</code> from 1D vectors or numbers</p><p><strong>Example 1: Create 3D grid</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,(-10:-1)km);
julia&gt; size(Lon)
(11, 11, 10)</code></pre><p><strong>Example 2: Create 2D lon/lat grid @ a given depth</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  LonLatDepthGrid(10:20,30:40,-50km);
julia&gt; size(Lon)
(11, 11)</code></pre><p><strong>Example 3: Create 2D lon/depth grid @ a given lat</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  LonLatDepthGrid(10:20,30,(-10:-1)km);
julia&gt; size(Lon)
(11, 11)</code></pre><p><strong>Example 4: Create 1D vertical line @ a given lon/lat point</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth =  LonLatDepthGrid(10,30,(-10:-1)km);
julia&gt; size(Lon)
(10, )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L845-L877">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Movie_Paraview-Tuple{}" href="#GeophysicalModelGenerator.Movie_Paraview-Tuple{}"><code>GeophysicalModelGenerator.Movie_Paraview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pvd = Movie_Paraview(; name=&quot;Movie&quot;, pvd=pvd, Finalize::Bool=false, Initialize::Bool=true)</code></pre><p>If you want to make a movie of your data set, you can use this routine to initialize and to finalize the movie-file. It will create a <code>*.pvd</code> file, which you can open in Paraview </p><p>Individual timesteps are added to the movie by passing <code>pvd</code> and the time of the timestep to the <code>Write_Paraview</code> routine.</p><p><strong>Example</strong></p><p>Usually this is used inside a <code>*.jl</code> script, as in this pseudo-example:</p><pre><code class="language-julia hljs">movie = Movie_Paraview(name=&quot;Movie&quot;, Initialize=true)
for itime=1:10
    name = &quot;test&quot;*string(itime)
    movie = Write_Paraview(Data, name, pvd=movie, time=itime)
end
Movie_Paraview(pvd=movie, Finalize=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Paraview_output.jl#L162-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ParseColumns_CSV_File-Tuple{Any, Any}" href="#GeophysicalModelGenerator.ParseColumns_CSV_File-Tuple{Any, Any}"><code>GeophysicalModelGenerator.ParseColumns_CSV_File</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParseColumns_CSV_File(data_file, num_columns)</code></pre><p>This parses numbers from CSV file that is read in with <code>CSV.File</code>. That is useful in case the CSV files has tables that contain both strings (e.g., station names) and numbers (lat/lon/height) and you are only interested in the numbers</p><p><strong>Example</strong></p><p>This example assumes that the data starts at line 18, that the columns are separated by spaces, and that it contains at most 4 columns with data:</p><pre><code class="language-julia-repl hljs">julia&gt; using CSV
julia&gt; data_file        =   CSV.File(&quot;FileName.txt&quot;,datarow=18,header=false,delim=&#39; &#39;)
julia&gt; data = ParseColumns_CSV_File(data_file, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1474-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ParseValue_CommandLineArgs-NTuple{4, Any}" href="#GeophysicalModelGenerator.ParseValue_CommandLineArgs-NTuple{4, Any}"><code>GeophysicalModelGenerator.ParseValue_CommandLineArgs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">This parses a LaMEM command line argument string and checks if the keyword exists there</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L144-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ParseValue_LaMEM_InputFile-Tuple{Any, Any, Any}" href="#GeophysicalModelGenerator.ParseValue_LaMEM_InputFile-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.ParseValue_LaMEM_InputFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value = ParseValue_LaMEM_InputFile(file,keyword,type; args::String=nothing)</code></pre><p>Extracts a certain <code>keyword</code> from a LaMEM input <code>file</code> and convert it to a certain type. Optionally, you can also pass command-line arguments which will override the value read from the input file.</p><p><strong>Example 1:</strong></p><pre><code class="language-julia hljs">julia&gt; nmark_z = ParseValue_LaMEM_InputFile(&quot;SaltModels.dat&quot;,&quot;nmark_z&quot;,Int64)</code></pre><p><strong>Example 2:</strong></p><pre><code class="language-julia hljs">julia&gt; nmark_z = ParseValue_LaMEM_InputFile(&quot;SaltModels.dat&quot;,&quot;nmark_z&quot;,Int64, args=&quot;-nel_x 128 -coord_x -4,4&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PetscBinaryWrite_Vec-Tuple{Any, Any}" href="#GeophysicalModelGenerator.PetscBinaryWrite_Vec-Tuple{Any, Any}"><code>GeophysicalModelGenerator.PetscBinaryWrite_Vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PetscBinaryWrite_Vec(filename, A)</code></pre><p>Writes a vector <code>A</code> to disk, such that it can be read with <code>PetscBinaryRead</code> (which assumes a Big Endian type)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L534-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid-NTuple{6, Any}" href="#GeophysicalModelGenerator.PointData2NearestGrid-NTuple{6, Any}"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count = PointData2NearestGrid(pt_x,pt_y,pt_z, X,Y,Z; radius_factor=1)</code></pre><p>This uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D grid point specified by <code>X</code>,<code>Y</code>,<code>Z</code> 3D coordinate arrays, with regular spacing <code>(Δx,Δy,Δz)</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid-Tuple{Any, Any, Any, CartData}" href="#GeophysicalModelGenerator.PointData2NearestGrid-Tuple{Any, Any, Any, CartData}"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(pt_x,pt_y,pt_z, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>CartGrid</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid-Tuple{Any, Any, Any, GeoData}" href="#GeophysicalModelGenerator.PointData2NearestGrid-Tuple{Any, Any, Any, GeoData}"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(pt_x,pt_y,pt_z, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>pt_x</code>,<code>pt_y</code>,<code>pt_z</code> coordinate vectors) are in the  vicinity of 3D <code>GeoData</code> specified by <code>Grid</code>. The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.PointData2NearestGrid-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(Point::CartData, Grid::CartData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.PointData2NearestGrid-Tuple{GeoData, GeoData}" href="#GeophysicalModelGenerator.PointData2NearestGrid-Tuple{GeoData, GeoData}"><code>GeophysicalModelGenerator.PointData2NearestGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid_counts = PointData2NearestGrid(Point::GeoData, Grid::GeoData; radius_factor=1)</code></pre><p>Uses nearest neighbour interpolation to count how many points (given by <code>Point</code>) are in the vicinity of a 3D <code>Grid</code>.  The search radius is <code>R=radius_factor*(Δx² + Δy² + Δz²)^(1/3)</code></p><p><code>Point</code> should have 1D coordinate vectors</p><p><code>Grid_counts</code> is <code>Grid</code> but with an additional field <code>Count</code> that has the number of hits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/event_counts.jl#L46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, CartData}" href="#GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, CartData}"><code>GeophysicalModelGenerator.ProjectCartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, GeoData, ProjectionPoint}" href="#GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, GeoData, ProjectionPoint}"><code>GeophysicalModelGenerator.ProjectCartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::GeoData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the GeoData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>. <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><p><strong>Note:</strong></p><ul><li>If <code>d_cart</code> and <code>d</code> are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, UTMData, ProjectionPoint}" href="#GeophysicalModelGenerator.ProjectCartData-Tuple{CartData, UTMData, ProjectionPoint}"><code>GeophysicalModelGenerator.ProjectCartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d_cart = ProjectCartData(d_cart::CartData, d::UTMData, p::ProjectionPoint)</code></pre><p>Projects all datafields from the UTMData struct <code>d</code> to the CartData struct <code>d_cart</code>, around the projection point <code>p</code>.     <code>d_cart</code> <em>must</em> be an orthogonal cartesian grid (deformed doesn&#39;t work; use <code>Convert2CartData(d, proj)</code>, where <code>proj</code> is a projection point in that case).</p><pre><code class="nohighlight hljs"># Note:    
- If `d_cart` and `d` are horizontal surfaces (3rd dimension has size==1), it also interpolates the depth coordinate.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/transformation.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ReadData_PVTR-Tuple{Any, Any}" href="#GeophysicalModelGenerator.ReadData_PVTR-Tuple{Any, Any}"><code>GeophysicalModelGenerator.ReadData_PVTR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data::ParaviewData = ReadData_PVTR(fname, dir)</code></pre><p>Reads a parallel, rectilinear, <code>*.vts</code> file with the name <code>fname</code> and located in <code>dir</code> and create a 3D <code>Data</code> struct from it.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Data = ReadData_PVTR(&quot;Haaksbergen.pvtr&quot;, &quot;./Timestep_00000005_3.35780500e-01/&quot;)
ParaviewData
  size  : (33, 33, 33)
  x     ϵ [ -3.0 : 3.0]
  y     ϵ [ -2.0 : 2.0]
  z     ϵ [ -2.0 : 0.0]
  fields: (:phase, :density, :visc_total, :visc_creep, :velocity, :pressure, :temperature, :dev_stress, :strain_rate, :j2_dev_stress, :j2_strain_rate, :plast_strain, :plast_dissip, :tot_displ, :yield, :moment_res, :cont_res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L817-L832">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ReadData_VTR-Tuple{Any, Any}" href="#GeophysicalModelGenerator.ReadData_VTR-Tuple{Any, Any}"><code>GeophysicalModelGenerator.ReadData_VTR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coord, Data_3D_Arrays, Name_Vec = ReadData_VTR(fname)</code></pre><p>Reads a VTR (structured grid) VTK file <code>fname</code> and extracts the coordinates, data arrays and names of the data. In general, this only contains a piece of the data, and one should open a <code>*.pvtr</code> file to retrieve the full data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L608-L613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ReadLaMEM_InputFile-Tuple{Any}" href="#GeophysicalModelGenerator.ReadLaMEM_InputFile-Tuple{Any}"><code>GeophysicalModelGenerator.ReadLaMEM_InputFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid::LaMEM_grid = ReadLaMEM_InputFile(file, args::Union{String,Nothing}=nothing)</code></pre><p>Parses a LaMEM input file and stores grid information in the <code>Grid</code> structure. Optionally, you can pass LaMEM command-line arguments as well.</p><p><strong>Example 1</strong></p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;SaltModels.dat&quot;)
LaMEM Grid:
nel         : (32, 32, 32)
marker/cell : (3, 3, 3)
markers     : (96, 96, 96)
x           ϵ [-3.0 : 3.0]
y           ϵ [-2.0 : 2.0]
z           ϵ [-2.0 : 0.0]</code></pre><p><strong>Example 2 (with command-line arguments)</strong></p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;SaltModels.dat&quot;, args=&quot;-nel_x 64 -coord_x -4,4&quot;)
LaMEM Grid:
  nel         : (64, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (192, 96, 96)
  x           ϵ [-4.0 : 4.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L166-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.ReadPickedProfiles-Tuple{String}" href="#GeophysicalModelGenerator.ReadPickedProfiles-Tuple{String}"><code>GeophysicalModelGenerator.ReadPickedProfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This reads the picked profiles from disk and returns a vector of ProfileData</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L367-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.RemoveField-Tuple{AbstractGeneralGrid, String}" href="#GeophysicalModelGenerator.RemoveField-Tuple{AbstractGeneralGrid, String}"><code>GeophysicalModelGenerator.RemoveField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">V = RemoveField(V::AbstractGeneralGrid,field_name::String)</code></pre><p>Removes the field with name <code>field_name</code> from the GeoData or CartData dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.RotateTranslateScale-Tuple{Union{CartData, ParaviewData}}" href="#GeophysicalModelGenerator.RotateTranslateScale-Tuple{Union{CartData, ParaviewData}}"><code>GeophysicalModelGenerator.RotateTranslateScale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data_R = RotateTranslateScale(Data::Union{ParaviewData, CartData}; Rotate=0, Translate=(0,0,0), Scale=(1.0,1.0,1.0), Xc=(0.0,0.0))</code></pre><p>Does an in-place rotation, translation and scaling of the Cartesian dataset <code>Data</code>.</p><p><strong>Parameters</strong></p><p>Note that we apply the transformations in exactly this order:</p><ul><li><code>Scale</code>:        scaling applied to the <code>x,y,z</code> coordinates of the data set</li><li><code>Rotate</code>:       rotation around the <code>x/y</code> axis (around the center of the box)</li><li><code>Translate</code>:    translation</li><li><code>Xc</code>:           center of rotation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; X,Y,Z   =   XYZGrid(10:20,30:40,-50:-10);
julia&gt; Data_C  =   ParaviewData(X,Y,Z,(Depth=Z,))
ParaviewData
  size  : (11, 11, 41)
  x     ϵ [ 10.0 : 20.0]
  y     ϵ [ 30.0 : 40.0]
  z     ϵ [ -50.0 : -10.0]
  fields: (:Depth,)
julia&gt; Data_R = RotateTranslateScale(Data_C, Rotate=30);
julia&gt; Data_R
ParaviewData
  size  : (11, 11, 41)
  x     ϵ [ 8.169872981077807 : 21.83012701892219]
  y     ϵ [ 28.16987298107781 : 41.83012701892219]
  z     ϵ [ -50.0 : -10.0]
  fields: (:Depth,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1772-L1803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Save_LaMEMMarkersParallel-Tuple{CartData}" href="#GeophysicalModelGenerator.Save_LaMEMMarkersParallel-Tuple{CartData}"><code>GeophysicalModelGenerator.Save_LaMEMMarkersParallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save_LaMEMMarkersParallel(Grid::CartData; PartitioningFile=empty, directory=&quot;./markers&quot;, verbose=true, is64bit=false)</code></pre><p>Saves a LaMEM marker file from the <code>CartData</code> structure <code>Grid</code>. It must have a field called <code>Phases</code>, holding phase information (as integers) and optionally a field <code>Temp</code> with temperature info. It is possible to provide a LaMEM partitioning file <code>PartitioningFile</code>. If not, output is assumed to be for one processor. By default it is assumed that the partitioning file was generated on a 32bit PETSc installation. If <code>Int64</code> was used instead, set the flag.</p><p>The size of <code>Grid</code> should be consistent with what is provided in the LaMEM input file. In practice, the size of the mesh can be retrieved from a LaMEM input file using <code>ReadLaMEM_InputFile</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; Grid    = ReadLaMEM_InputFile(&quot;LaMEM_input_file.dat&quot;)
julia&gt; Phases  = zeros(Int32,size(Grid.X));
julia&gt; Temp    = ones(Float64,size(Grid.X));
julia&gt; Model3D = CartData(Grid, (Phases=Phases,Temp=Temp))
julia&gt; Save_LaMEMMarkersParallel(Model3D)
Writing LaMEM marker file -&gt; ./markers/mdb.00000000.dat</code></pre><p>If you want to create a LaMEM input file for multiple processors:</p><pre><code class="nohighlight hljs">julia&gt; Save_LaMEMMarkersParallel(Model3D, PartitioningFile=&quot;ProcessorPartitioning_4cpu_1.2.2.bin&quot;)
Writing LaMEM marker file -&gt; ./markers/mdb.00000000.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000001.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000002.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000003.dat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L370-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Save_LaMEMTopography-Tuple{CartData, String}" href="#GeophysicalModelGenerator.Save_LaMEMTopography-Tuple{CartData, String}"><code>GeophysicalModelGenerator.Save_LaMEMTopography</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save_LaMEMTopography(Topo::CartData, filename::String)</code></pre><p>This writes a topography file <code>Topo</code> for use in LaMEM, which should have size <code>(nx,ny,1)</code> and contain the field <code>:Topography</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L927-L931">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Screenshot_To_CartData-Tuple{String, Any, Any}" href="#GeophysicalModelGenerator.Screenshot_To_CartData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.Screenshot_To_CartData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data = Screenshot_To_CartData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing)</code></pre><p>Does the same as <code>Screenshot_To_GeoData</code>, but returns a <code>CartData</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_import.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Screenshot_To_GeoData-Tuple{String, Any, Any}" href="#GeophysicalModelGenerator.Screenshot_To_GeoData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.Screenshot_To_GeoData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Screenshot_To_GeoData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, Cartesian=false, UTM=false, UTMzone, isnorth=true, fieldname::Symbol=:colors)</code></pre><p>Take a screenshot of Georeferenced image either a <code>lat/lon</code>, <code>x,y</code> (if <code>Cartesian=true</code>) or in UTM coordinates (if <code>UTM=true</code>) at a given depth or along profile and converts it to a <code>GeoData</code>, <code>CartData</code> or <code>UTMData</code> struct, which can be saved to Paraview</p><p>The lower left and upper right coordinates of the image need to be specified in tuples of <code>(lon,lat,depth)</code> or <code>(UTM_ew, UTM_ns, depth)</code>, where <code>depth</code> is negative inside the Earth (and in km).</p><p>The lower right and upper left corners can be specified optionally (to take non-orthogonal images into account). If they are not specified, the image is considered orthogonal and the corners are computed from the other two.</p><p><em>Note</em>: if your data is in <code>UTM</code> coordinates you also need to provide the <code>UTMzone</code> and whether we are on the northern hemisphere or not (<code>isnorth</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_import.jl#L162-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Screenshot_To_UTMData-Tuple{String, Any, Any}" href="#GeophysicalModelGenerator.Screenshot_To_UTMData-Tuple{String, Any, Any}"><code>GeophysicalModelGenerator.Screenshot_To_UTMData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data = Screenshot_To_UTMData(filename::String, Corner_LowerLeft, Corner_UpperRight; Corner_LowerRight=nothing, Corner_UpperLeft=nothing, UTMzone::Int64=nothing, isnorth::Bool=true, fieldname=:colors)</code></pre><p>Does the same as <code>Screenshot_To_GeoData</code>, but returns for UTM data Note that you have to specify the <code>UTMzone</code> and <code>isnorth</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_import.jl#L304-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.SubtractHorizontalMean-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T" href="#GeophysicalModelGenerator.SubtractHorizontalMean-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T"><code>GeophysicalModelGenerator.SubtractHorizontalMean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">V_sub = SubtractHorizontalMean(V::AbstractArray{T, 3}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 3D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1403-L1410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.SubtractHorizontalMean-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeophysicalModelGenerator.SubtractHorizontalMean-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeophysicalModelGenerator.SubtractHorizontalMean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">V_sub = SubtractHorizontalMean(V::AbstractArray{T, 2}; Percentage=false)</code></pre><p>Subtracts the horizontal average of the 2D data array V.</p><p>If <code>Percentage=true</code>, the result is given as percentage; otherwise absolute values are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1437-L1444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.SubtractSurfaces!-Tuple{Union{CartData, ParaviewData}, Union{CartData, ParaviewData}}" href="#GeophysicalModelGenerator.SubtractSurfaces!-Tuple{Union{CartData, ParaviewData}, Union{CartData, ParaviewData}}"><code>GeophysicalModelGenerator.SubtractSurfaces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SubtractSurfaces!(Surface1::Union{CartData,ParaviewData}, Surface2::Union{CartData,ParaviewData})</code></pre><p>Subtracts <code>Surface2</code> to <code>Surface1</code>. The addition happens on the <code>Surface1.z</code>; the fields remain unchanged</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1993-L1998">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.SubtractSurfaces!-Tuple{Union{GeoData, UTMData}, Union{GeoData, UTMData}}" href="#GeophysicalModelGenerator.SubtractSurfaces!-Tuple{Union{GeoData, UTMData}, Union{GeoData, UTMData}}"><code>GeophysicalModelGenerator.SubtractSurfaces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SubtractSurfaces!(Surface1::Union{GeoData,UTMData}, Surface2::Union{GeoData,UTMData})</code></pre><p>Subtracts <code>Surface2</code> to <code>Surface1</code>. The addition happens on the <code>Surface1.depth</code>; the fields remain unchanged</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1979-L1984">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Velocity_SphericalToCartesian!-Tuple{GeoData, Tuple}" href="#GeophysicalModelGenerator.Velocity_SphericalToCartesian!-Tuple{GeoData, Tuple}"><code>GeophysicalModelGenerator.Velocity_SphericalToCartesian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Velocity_SphericalToCartesian!(Data::GeoData, Velocity::Tuple)</code></pre><p>In-place conversion of velocities in spherical velocities <code>[Veast, Vnorth, Vup]</code> to cartesian coordinates (for use in paraview).</p><p>NOTE: the magnitude of the vector will be the same, but the individual <code>[Veast, Vnorth, Vup]</code> components will not be retained correctly (as a different <code>[x,y,z]</code> coordinate system is used in paraview). Therefore, if you want to display or color that correctly in Paraview, you need to store these magnitudes as separate fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L932-L941">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Visualise" href="#GeophysicalModelGenerator.Visualise"><code>GeophysicalModelGenerator.Visualise</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Interactive widget that allows you to explore a 3D data set <code>DataSet</code> in an interactive manner. It requires you to load <code>GLMakie</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/GeophysicalModelGenerator.jl#L60-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.VoteMap-Tuple{Vector{GeoData}, Vector{String}}" href="#GeophysicalModelGenerator.VoteMap-Tuple{Vector{GeoData}, Vector{String}}"><code>GeophysicalModelGenerator.VoteMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoteMap(DataSets::Vector{GeoData}, criteria::Vector{String}, dims=(50,50,50))</code></pre><p>Creates a Vote map which shows consistent features in different 2D/3D tomographic datasets.</p><p>The way it works is:</p><ul><li>Find a common region between the different GeoData sets (overlapping lon/lat/depth regions)</li><li>Interpolate the fields of all DataSets to common coordinates</li><li>Filter data points in one model (e.g., areas with a velocity anomaly &gt; 2 percent). Set everything that satisfies this criteria to 1 and everything else to 0.</li><li>Sum the results of the different datasets</li></ul><p>If a feature is consistent between different datasets, it will have larger values.</p><p><strong>Example</strong></p><p>We assume that we have 2 seismic velocity datasets <code>Data_Zhao_Pwave</code> and <code>DataKoulakov_Alps</code>:</p><pre><code class="language-julia hljs">julia&gt; Data_Zhao_Pwave
GeoData
  size  : (121, 94, 101)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:dVp_Percentage,)
julia&gt; DataKoulakov_Alps
  GeoData
    size  : (108, 81, 35)
    lon   ϵ [ 4.0 : 20.049999999999997]
    lat   ϵ [ 37.035928143712574 : 49.01197604790419]
    depth ϵ [ -700.0 km : -10.0 km]
    fields: (:dVp_percentage, :dVs_percentage)</code></pre><p>You can create a VoteMap which combines the two data sets with:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = VoteMap([Data_Zhao_Pwave,DataKoulakov_Alps],[&quot;dVp_Percentage&gt;2.5&quot;,&quot;dVp_percentage&gt;3.0&quot;])
GeoData
  size  : (50, 50, 50)
  lon   ϵ [ 4.0 : 18.0]
  lat   ϵ [ 38.0 : 49.01197604790419]
  depth ϵ [ -700.0 km : -10.0 km]
  fields: (:VoteMap,)</code></pre><p>You can also create a VoteMap of a single dataset:</p><pre><code class="language-julia hljs">julia&gt; Data_VoteMap = VoteMap(Data_Zhao_Pwave,&quot;dVp_Percentage&gt;2.5&quot;, dims=(50,51,52))
GeoData
  size  : (50, 51, 52)
  lon   ϵ [ 0.0 : 18.0]
  lat   ϵ [ 38.0 : 51.95]
  depth ϵ [ -1001.0 km : -1.0 km]
  fields: (:VoteMap,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L1649-L1702">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Write_Paraview" href="#GeophysicalModelGenerator.Write_Paraview"><code>GeophysicalModelGenerator.Write_Paraview</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pvd = Write_Paraview(DataSet::ParaviewData, filename=&quot;test&quot;; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a structure with <code>Geodata</code> to a paraview (or VTK) file. If you have unstructured points (e.g., earthquake data), set <code>PointsData=true</code>. In case you want to create a movie in Paraview, and this is a timestep of that movie you also have to pass <code>time</code> and <code>pvd</code></p><p><strong>Example 1: Write a 3D volume</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth   =   LonLatDepthGrid(10:20,30:40,(-300:25:0)km);
julia&gt; Data_set        =   GeoData(Lat,Lon,Depth,(Depthdata=Depth,LonData=Lon))  
julia&gt; Write_Paraview(Data_set, &quot;test_depth3D&quot;)</code></pre><p><strong>Example 2: Horizontal slice @ given depth</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  
julia&gt; Write_Paraview(Data_set, &quot;test&quot;)</code></pre><p><strong>Example 3: Case with topography</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth    =   LonLatDepthGrid(10:20,30:40,10km);
julia&gt; Depth[2:4,2:4,1] .=  25km     
julia&gt; Data_set         =   GeoData(Lat,Lon,Depth,(Topography=Depth,))  
julia&gt; Write_Paraview(Data_set, &quot;test2&quot;)</code></pre><p><strong>Example 4: Profile</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   LonLatDepthGrid(10:20,35,(-300:25:0)km);
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth,Depth=Depth))  
julia&gt; Write_Paraview(Data_set, &quot;test&quot;)</code></pre><p><strong>Example 5: Velocity vectors</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   LonLatDepthGrid(10:20,30:40,10km);
julia&gt; Ve, Vn, Vz     =   ones(size(Depth)), ones(size(Depth))*0.5, zeros(size(Depth));
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth, Velocity=(Ve,Vn,Vz)))
GeoData 
  size  : (11, 11, 1)
  lon   ϵ [ 30.0 - 40.0]
  lat   ϵ [ 10.0 - 20.0]
  depth ϵ [ 10.0 km - 10.0 km]
  fields: (:DataSet, :Velocity)  
julia&gt; Write_Paraview(Data_set, &quot;test_Velocity&quot;)</code></pre><p><strong>Example 6: Unconnected points (e.g., earthquake locations)</strong></p><p>Note that these points should be 1D vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; Lon,Lat,Depth  =   LonLatDepthGrid(10:5:20,35:2:40,(-300:50:0)km);
julia&gt; Lon=Lon[:]; Lat=Lat[:]; Depth=Depth[:];
julia&gt; Data_set       =   GeoData(Lat,Lon,Depth,(DataSet=Depth[:],Depth=Depth*10));  
julia&gt; Write_Paraview(Data_set, &quot;test_Points&quot;, PointsData=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Paraview_output.jl#L7-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Write_Paraview-Tuple{CartData, Any}" href="#GeophysicalModelGenerator.Write_Paraview-Tuple{CartData, Any}"><code>GeophysicalModelGenerator.Write_Paraview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Write_Paraview(DataSet::CartData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a <code>CartData</code> structure to paraview. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Paraview_output.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.Write_Paraview-Tuple{UTMData, Any}" href="#GeophysicalModelGenerator.Write_Paraview-Tuple{UTMData, Any}"><code>GeophysicalModelGenerator.Write_Paraview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Write_Paraview(DataSet::UTMData, filename::Any; PointsData=false, pvd=nothing, time=nothing, directory=nothing, verbose=true)</code></pre><p>Writes a <code>UTMData</code> structure to paraview. Note that this data is <em>not</em> transformed into an Earth-like framework, but remains cartesian instead. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Paraview_output.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.XYZGrid-Tuple{Any, Any, Any}" href="#GeophysicalModelGenerator.XYZGrid-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.XYZGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y,Z = XYZGrid(X_vec::Any, Y_vec::Any, Z_vec::Any)</code></pre><p>Creates a <code>X,Y,Z</code> grid. It works just as <code>LonLatDepthGrid</code> apart from the better suited name.</p><p><strong>Example 1: Create 3D grid</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X,Y,Z =  XYZGrid(10:20,30:40,(-10:-1)km);
julia&gt; size(X)
(11, 11, 10)</code></pre><p>See <code>LonLatDepthGrid</code> for more examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L913-L926">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.combine_VolData-Tuple{NamedTuple}" href="#GeophysicalModelGenerator.combine_VolData-Tuple{NamedTuple}"><code>GeophysicalModelGenerator.combine_VolData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VolData_combined = combine_VolData(VolData::NamedTuple; lat=nothing, lon=nothing, depth=nothing, dims=(100,100,100), dataset_preferred = 1)</code></pre><p>This takes different volumetric datasets (specified in <code>VolData</code>) &amp; merges them into a single one. You need to either provide the &quot;reference&quot; dataset within the NamedTuple (<code>dataset_preferred</code>), or the lat/lon/depth and dimensions of the new dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{CartData}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{CartData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::CartData)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L980-L984">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{CartGrid}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{CartGrid}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::CartGrid)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1185-L1189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{GeoData}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{GeoData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LON,LAT,Z = coordinate_grids(Data::GeoData)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L990-L994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{LaMEM_grid}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{LaMEM_grid}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::LaMEM_grid)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/LaMEM_io.jl#L1015-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{ParaviewData}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{ParaviewData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y,Z = coordinate_grids(Data::ParaviewData)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1010-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.coordinate_grids-Tuple{UTMData}" href="#GeophysicalModelGenerator.coordinate_grids-Tuple{UTMData}"><code>GeophysicalModelGenerator.coordinate_grids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EW,NS,Z = coordinate_grids(Data::UTMData)</code></pre><p>Returns 3D coordinate arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L1000-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.download_data" href="#GeophysicalModelGenerator.download_data"><code>GeophysicalModelGenerator.download_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_data(url::String, local_filename=&quot;temp.dat&quot;; dir=pwd() )</code></pre><p>Downloads a remote dataset with name <code>url</code> from a remote location and saves it to the current directory</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; url  = &quot;https://seafile.rlp.net/f/10f867e410bb4d95b3fe/?dl=1&quot;;
julia&gt; download_data(url)
&quot;/Users/kausb/.julia/dev/GeophysicalModelGenerator/temp.dat&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/IO.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.flip" href="#GeophysicalModelGenerator.flip"><code>GeophysicalModelGenerator.flip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Data = flip(Data::GeoData, dimension=3)</code></pre><p>This flips the data in the structure in a certain dimension (default is z [3])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/data_types.jl#L574-L578">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.load_GMG" href="#GeophysicalModelGenerator.load_GMG"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_GMG(filename::String, dir=pwd())</code></pre><p>Loads a <code>GeoData</code>/<code>CartData</code>/<code>UTMData</code> data set from jld2 file <code>filename</code> Note: the <code>filename</code> can also be a remote <code>url</code>, in which case we first download that file to a temporary directory before opening it</p><p><strong>Example 1 - Load local file</strong></p><pre><code class="language-julia hljs">julia&gt; data = load_GMG(&quot;test&quot;)
GeoData 
  size      : (4, 3, 3)
  lon       ϵ [ 1.0 : 10.0]
  lat       ϵ [ 11.0 : 19.0]
  depth     ϵ [ -20.0 : -10.0]
  fields    : (:DataFieldName,)
  attributes: [&quot;note&quot;]</code></pre><p><strong>Example 2 - remote download</strong></p><pre><code class="language-julia hljs">julia&gt; url  = &quot;https://seafile.rlp.net/f/10f867e410bb4d95b3fe/?dl=1&quot;
julia&gt; load_GMG(url)
GeoData 
  size      : (149, 242, 1)
  lon       ϵ [ -24.875 : 35.375]
  lat       ϵ [ 34.375 : 71.375]
  depth     ϵ [ -11.76 : -34.7]
  fields    : (:MohoDepth,)
  attributes: [&quot;author&quot;, &quot;year&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/IO.jl#L25-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.load_GMG-Tuple{GMG_Dataset}" href="#GeophysicalModelGenerator.load_GMG-Tuple{GMG_Dataset}"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data::NamedTuple = load_GMG(data::GMG_Dataset)</code></pre><p>Loads a dataset specified in GMG_Dataset <code>data</code> and returns it as a named tuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.load_GMG-Tuple{Vector{GMG_Dataset}}" href="#GeophysicalModelGenerator.load_GMG-Tuple{Vector{GMG_Dataset}}"><code>GeophysicalModelGenerator.load_GMG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data = load_GMG(Datasets::Vector{GMG_Dataset})</code></pre><p>This loads all the active datasets in <code>Datasets</code>, and returns a NamedTuple with Volume, Surface, Point, Screenshot and Topography data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/ProfileProcessing.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.makeVolcTopo-Tuple{LaMEM_grid}" href="#GeophysicalModelGenerator.makeVolcTopo-Tuple{LaMEM_grid}"><code>GeophysicalModelGenerator.makeVolcTopo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>makeVolcTopo(Grid::LaMEM_grid; center::Array{Float64, 1}, height::Float64, radius::Float64, crater::Float64,             base=0.0m, background=nothing)</p><p>Creates a generic volcano topography (cones and truncated cones)</p><p><strong>Parameters</strong></p><ul><li>Grid - LaMEM grid (created by ReadLaMEM_InputFile)</li><li>center - x- and -coordinates of center of volcano</li><li>height - height of volcano</li><li>radius - radius of volcano</li></ul><p><strong>Optional Parameters</strong></p><ul><li>crater - this will create a truncated cone and the option defines the radius of the flat top</li><li>base - this sets the flat topography around the volcano</li><li>background - this allows loading in a topography and only adding the volcano on top (also allows stacking of several cones to get a volcano with different slopes)</li></ul><p><strong>Example</strong></p><p>Cylinder with constant phase and temperature:</p><pre><code class="language-julia hljs">julia&gt; Grid = ReadLaMEM_InputFile(&quot;test_files/SaltModels.dat&quot;)
LaMEM Grid:
  nel         : (32, 32, 32)
  marker/cell : (3, 3, 3)
  markers     : (96, 96, 96)
  x           ϵ [-3.0 : 3.0]
  y           ϵ [-2.0 : 2.0]
  z           ϵ [-2.0 : 0.0]
julia&gt; Topo = makeVolcTopo(Grid, center=[0.0,0.0], height=0.4, radius=1.5, crater=0.5, base=0.1)
CartData
    size    : (33, 33, 1)
    x       ϵ [ -3.0 : 3.0]
    y       ϵ [ -2.0 : 2.0]
    z       ϵ [ 0.1 : 0.4]
    fields  : (:Topography,)
  attributes: [&quot;note&quot;]
julia&gt; Topo = makeVolcTopo(Grid, center=[0.0,0.0], height=0.8, radius=0.5, crater=0.0, base=0.4, background=Topo.fields.Topography)
CartData
    size    : (33, 33, 1)
    x       ϵ [ -3.0 : 3.0]
    y       ϵ [ -2.0 : 2.0]
    z       ϵ [ 0.1 : 0.8]
    fields  : (:Topography,)
  attributes: [&quot;note&quot;]
julia&gt; Write_Paraview(Topo,&quot;VolcanoTopo&quot;)           # Save topography to paraview
Saved file: VolcanoTopo.vts</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/Setup_geometry.jl#L472-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.meshgrid-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#GeophysicalModelGenerator.meshgrid-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeophysicalModelGenerator.meshgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meshgrid(vx,vy,vz)</code></pre><p>Computes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.remove_NaN_Surface!-Tuple{Any, Any, Any}" href="#GeophysicalModelGenerator.remove_NaN_Surface!-Tuple{Any, Any, Any}"><code>GeophysicalModelGenerator.remove_NaN_Surface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_NaN_Surface!(Z,X,Y)</code></pre><p>Removes NaN&#39;s from a grid <code>Z</code> by taking the closest points as specified by <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/utils.jl#L2009-L2013">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.save_GMG-Tuple{String, Union{CartData, GeoData, UTMData}}" href="#GeophysicalModelGenerator.save_GMG-Tuple{String, Union{CartData, GeoData, UTMData}}"><code>GeophysicalModelGenerator.save_GMG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_GMG(filename::String, data::Union{GeoData, CartDat, UTMData}; dir=pwd())</code></pre><p>Saves the dataset <code>data</code> to a JLD2 <code>file</code> (name without extension) in the directory <code>dir</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Lon3D,Lat3D,Depth3D = LonLatDepthGrid(1.0:3:10.0, 11.0:4:20.0, (-20:5:-10)*km);
julia&gt; Data_set    =   GeophysicalModelGenerator.GeoData(Lon3D,Lat3D,Depth3D,(DataFieldName=Depth3D,))   
julia&gt; save_GMG(&quot;test&quot;,Data_set)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/IO.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeophysicalModelGenerator.voxGrav-NTuple{4, Array{Float64, 3}}" href="#GeophysicalModelGenerator.voxGrav-NTuple{4, Array{Float64, 3}}"><code>GeophysicalModelGenerator.voxGrav</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">voxGrav(X::Array{Float64, 3}, Y::Array{Float64, 3}, Z::Array{Float64, 3}, RHO::Array{Float64, 3};
refMod=&quot;AVG&quot;, lengthUnit=&quot;m&quot;, rhoTol=1e-9, Topo=[], outName=&quot;Bouguer&quot;, printing=true)

Computes Bouguer anomalies and gradients

Required arguments:
X,Y,Z:       3D matrices with the coordinates of the grid (X should vary in the first dimension, Y in the second, Z (vertical) in the third)
RHO:         3D matrix with the density at each grid point [kg/m^3]

Optional arguments:
refMod:      1D vector with the reference density for each depth
             Alternatively, the strings &quot;NE&quot;, &quot;SE&quot;, &quot;SW&quot;, &quot;NW&quot;, &quot;AVG&quot; can be used.
             In that case, one of the corners of `RHO` is used as reference model.
             In case of &quot;AVG&quot; the reference model is the average of each depth slice.
lengthUnit:  The unit of the coordinates and topography file. Either &quot;m&quot; or &quot;km&quot;
rhoTol:      density differences smaller than rhoTol will be ignored [kg/m^3]
Topo:        2D matrix with the topography of the surface (only relevant for the paraview output)
outName:     name of the paraview output (do not include file type)
printing:    activate printing of additional information [true or false]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeodynamics/GeophysicalModelGenerator.jl/blob/0a9b1dd9c1e159ff61db0c061bb89413895f2534/src/voxel_gravity.jl#L12-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../profile_processing/">« Profile Processing</a><a class="docs-footer-nextpage" href="../authors/">Authors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 29 February 2024 14:40">Thursday 29 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
